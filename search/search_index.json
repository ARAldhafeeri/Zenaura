{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Zenaura Docs","text":"<p>Zenaura is a cutting-edge Python library that empowers developers to build high-performance, stateful Single Page Applications (SPAs) with ease. Built upon Pydide and PyScript, Zenaura leverages a virtual DOM to optimize the responsiveness and interactivity of your web UIs.</p>"},{"location":"#what-you-will-learn","title":"What you will learn?","text":"<ul> <li>Quick Start: Rapidly create your first modern web application using your existing Python skills.</li> <li>Fundamentals: Master the core building blocks of Zenaura: servers, clients, components, pages, state management, and more.</li> <li>Beyond the Basics: Delve into Zenaura's virtual DOM, architecture, event handling, forms, and server-side rendering.</li> <li>Advanced Techniques: Explore global components, state observers, interactions with the virtual DOM, data fetching, and deployment to GitHub Pages.</li> <li>Comprehensive Examples: From simple counters to full-fledged admin portals, learn by building.</li> <li>Complete API Reference: Easily search and reference all of Zenaura's capabilities.</li> </ul>"},{"location":"#why-zenaura","title":"Why zenaura ?","text":"<p>Pythonic Development: With Zenaura, you can leverage your existing Python skills to build powerful web applications, eliminating the need to learn new languages or frameworks.</p> <p>High Performance: By utilizing a virtual DOM and stateful components, Zenaura ensures that your web applications are highly responsive and performant, even with complex user interfaces.</p> <p>Stateful Single Page Applications: Zenaura enables you to create stateful Single Page Applications (SPAs) effortlessly, allowing for seamless navigation and dynamic content updates without page reloads.</p> <p>Simplicity and Flexibility: Zenaura's intuitive API and modular architecture make it easy to learn and adapt to your project's specific needs. Whether you're building a simple blog or a complex enterprise application, Zenaura provides the tools you need.</p> <p>Comprehensive Documentation and Support: The Zenaura documentation is extensive and user-friendly, offering clear explanations, practical examples, and a comprehensive API reference. Additionally, the Zenaura community is active and supportive, providing assistance and guidance whenever you need it.</p> <p>Ecosystem Integration: Zenaura integrates seamlessly with popular Python libraries and frameworks, allowing you to leverage existing tools and infrastructure in your projects.</p> <p>Active Development and Updates: Zenaura is actively maintained and regularly updated with new features, improvements, and bug fixes, ensuring that your applications stay modern and secure.</p>"},{"location":"#next-steps","title":"Next Steps","text":"<p>Ready to get started with Zenaura? Check out our Quick Start guide to create your first web application in minutes. Or, dive deeper into the Fundamentals to master the core concepts and building blocks of Zenaura.</p> <p>If you're already familiar with the basics, explore the Beyond the Basics section to learn advanced techniques and best practices for building robust and scalable web applications.</p> <p>For comprehensive examples and practical use cases, visit our Examples page, where you'll find step-by-step tutorials and project templates for various types of applications.</p> <p>And whenever you need reference information or detailed explanations of Zenaura's features and APIs, don't forget to consult our API Reference.</p> <p>Welcome to the world of Zenaura\u2014where Python meets the web, and development becomes a breeze. Let's build something amazing together!</p>"},{"location":"algorithm/","title":"Algorithm","text":""},{"location":"algorithm/#zenaura.client.algorithm.algorithm.DiffingAlgorithm","title":"<code>DiffingAlgorithm</code>","text":"<p>             Bases: <code>Searcher</code>, <code>Updater</code></p> <p>The diffing algorithm in Zenaura virtual DOM.</p> <p>This class is responsible for comparing the old and new virtual DOM trees and generating a list of changes that need to be applied to the real DOM.</p> <p>The diffing algorithm is implemented in two steps:</p> <ol> <li>Search: The <code>Searcher</code> class traverses the old and new virtual DOM trees and identifies the nodes that have changed.</li> <li>Update: The <code>Updater</code> class applies the changes to the real DOM.</li> </ol> <p>The diffing algorithm is designed to be efficient and performant. It uses a number of techniques to minimize the number of changes that need to be applied to the real DOM.</p> <p>Attributes:</p> <ul> <li><code>Searcher</code>: An instance of the <code>Searcher</code> class.</li> <li><code>Updater</code>: An instance of the <code>Updater</code> class.</li> </ul> <p>Methods:</p> <ul> <li><code>diff(old_tree, new_tree)</code>: Compares the old and new virtual DOM trees and generates a list of changes that need to be applied to the real DOM.</li> </ul> <p>Example:</p> <pre><code># Create an instance of the DiffingAlgorithm class.\ndiffing_algorithm = DiffingAlgorithm()\n\n# Compare the old and new virtual DOM trees.\nchanges = diffing_algorithm.diff(old_tree, new_tree)\n\n# Apply the changes to the real DOM.\ndiffing_algorithm.update(changes)\n</code></pre> Source code in <code>zenaura\\client\\algorithm\\algorithm.py</code> <pre><code>class DiffingAlgorithm(\n    Searcher,\n    Updater\n):\n    \"\"\"\n        The diffing algorithm in Zenaura virtual DOM.\n\n        This class is responsible for comparing the old and new virtual DOM trees and generating a list of changes that need to be applied to the real DOM.\n\n        The diffing algorithm is implemented in two steps:\n\n        1. **Search:** The `Searcher` class traverses the old and new virtual DOM trees and identifies the nodes that have changed.\n        2. **Update:** The `Updater` class applies the changes to the real DOM.\n\n        The diffing algorithm is designed to be efficient and performant. It uses a number of techniques to minimize the number of changes that need to be applied to the real DOM.\n\n        **Attributes:**\n\n        * `Searcher`: An instance of the `Searcher` class.\n        * `Updater`: An instance of the `Updater` class.\n\n        **Methods:**\n\n        * `diff(old_tree, new_tree)`: Compares the old and new virtual DOM trees and generates a list of changes that need to be applied to the real DOM.\n\n        **Example:**\n\n        ```python\n        # Create an instance of the DiffingAlgorithm class.\n        diffing_algorithm = DiffingAlgorithm()\n\n        # Compare the old and new virtual DOM trees.\n        changes = diffing_algorithm.diff(old_tree, new_tree)\n\n        # Apply the changes to the real DOM.\n        diffing_algorithm.update(changes)\n        ```\n    \"\"\"\n</code></pre>"},{"location":"algorithm/#zenaura.client.algorithm.operations.ADD_ATTRIBUTE","title":"<code>ADD_ATTRIBUTE = 'ADD_ATTRIBUTE'</code>  <code>module-attribute</code>","text":"<p>{     name : \"ADD_ATTRIBUTE\",     context: {         \"attr_name\" : \"attr-name\",         \"attr_value\" : \"attr-value\",     } }</p>"},{"location":"algorithm/#zenaura.client.algorithm.operations.ADD_NODE","title":"<code>ADD_NODE = 'ADD_NODE'</code>  <code>module-attribute</code>","text":"<p>{     name : \"ADD_NODE\",     context: {         \"children\" : child-node,     } }</p>"},{"location":"algorithm/#zenaura.client.algorithm.operations.NODE_INNER_TEXT","title":"<code>NODE_INNER_TEXT = 'NODE_INNER_TEXT'</code>  <code>module-attribute</code>","text":"<p>{     name : \"NODE_INNER_TEXT\",     context: {         \"text\" : \"sanitized-text\",     } }</p>"},{"location":"algorithm/#zenaura.client.algorithm.operations.REMOVE_ATTRIBUTE","title":"<code>REMOVE_ATTRIBUTE = 'REMOVE_ATTRIBUTE'</code>  <code>module-attribute</code>","text":"<p>{     name : \"REMOVE_ATTRIBUTE\",     context: {         \"attr_name\" : \"attr-name\",     } }</p>"},{"location":"algorithm/#zenaura.client.algorithm.operations.REMOVE_NODE","title":"<code>REMOVE_NODE = 'REMOVE_NODE'</code>  <code>module-attribute</code>","text":"<p>{     name : \"REMOVE_NODE\",     context: {         \"children\" : child-node,     } }</p>"},{"location":"algorithm/#zenaura.client.algorithm.operations.REPLACE_ATTRIBUTE","title":"<code>REPLACE_ATTRIBUTE = 'REPLACE_ATTRIBUTE'</code>  <code>module-attribute</code>","text":"<p>{     name : \"REPLACE_ATTRIBUTE\",     context: {         \"attr_name\" : \"attr-name\",         \"attr_value\" : \"attr-value\",     } }</p>"},{"location":"CLI/cli/","title":"Zenaura CLI Guide","text":"<p>The Zenaura CLI tool simplifies the process of creating, building, and running Zenaura projects. This guide will walk you through the basic commands and functionalities provided by the Zenaura CLI.</p>"},{"location":"CLI/cli/#installation","title":"Installation","text":"<p>Zenaura cli comes out of the box with zenaura framework: <pre><code>pip install zenaura\n</code></pre></p>"},{"location":"CLI/cli/#cli-commands","title":"CLI Commands","text":"<p>The Zenaura CLI provides three main commands: <code>init</code>, <code>build</code>, and <code>run</code>.</p>"},{"location":"CLI/cli/#init","title":"init","text":"<p>The <code>init</code> command sets up a new Zenaura project with the necessary structure and files.</p> <pre><code>zenaura init\n</code></pre> <p>This command creates a <code>public</code> directory with initial files and folders, including:</p> <ul> <li><code>components.py</code></li> <li><code>presentational.py</code></li> <li><code>main.py</code></li> <li><code>routes.py</code></li> <li><code>config.json</code></li> <li><code>index.html</code></li> <li><code>main.css</code></li> <li><code>__init__.py</code></li> </ul> <p>It also creates two additional files in the project root:</p> <ul> <li><code>build.py</code></li> <li><code>index.py</code></li> </ul>"},{"location":"CLI/cli/#build","title":"build","text":"<p>The <code>build</code> command runs the <code>build.py</code> script to prepare your project for deployment.</p> <pre><code>zenaura build\n</code></pre>"},{"location":"CLI/cli/#run","title":"run","text":"<p>The <code>run</code> command starts the development server using the <code>index.py</code> script.</p> <pre><code>zenaura run\n</code></pre>"},{"location":"CLI/cli/#example-workflow","title":"Example Workflow","text":"<p>Here is an example of a typical workflow using the Zenaura CLI:</p> <ol> <li> <p>Initialize a new project:     <pre><code>zenaura init\n</code></pre></p> </li> <li> <p>Build the project:     <pre><code>zenaura build\n</code></pre></p> </li> <li> <p>Run the project:     <pre><code>zenaura run\n</code></pre></p> </li> </ol>"},{"location":"CLI/cli/#notes","title":"Notes","text":"<ul> <li>Hot-reloading: The hot-reloading feature is currently under development. To ensure your changes are reflected in the browser, use the <code>build</code> command before running the project.</li> <li>Python Versions: Ensure you are using a compatible Python version with Zenaura and the required packages.</li> </ul> <p>By following this guide, you can efficiently manage your Zenaura projects using the CLI tool. Enjoy building dynamic and interactive UIs with Zenaura!</p>"},{"location":"advanced/fetch_data/","title":"Fetching Data and Integrating APIs with Zenaura","text":"<p>Zenaura simplifies the process of fetching data from APIs and integrating it into your Python-based web applications. </p>"},{"location":"advanced/fetch_data/#key-concepts","title":"Key Concepts","text":"<ol> <li> <p>Async/Await:  Zenaura embraces asynchronous programming for efficient data fetching. <code>async def</code> functions allow your application to perform other tasks while waiting for API responses.</p> </li> <li> <p><code>mutator</code>: The <code>mutator</code> decorator is used to mark functions that modify component state. This ensures the component automatically re-renders to reflect the updated data.</p> </li> </ol> <p>Example Client-Side Component (<code>DataFetcher</code>)</p>"},{"location":"advanced/fetch_data/#create-zenaura-application","title":"Create zenaura application","text":"<pre><code>zenaura init\n</code></pre>"},{"location":"advanced/fetch_data/#add-requests-to-configjson","title":"Add requests to config.json","text":"<pre><code># stays same\n    \"packages\": [\n      \"zenaura==0.9.94\",\n      \"requests\"\n    ],\n# stays same\n</code></pre>"},{"location":"advanced/fetch_data/#presentational-components","title":"Presentational components","text":"<pre><code>from zenaura.client.tags.builder import Builder\n\ndef Div(class_name, children):\n    div = Builder('div').with_attribute('class', class_name).build()\n    div.children = children\n    return div\n\ndef Image(src, alt, width, height, classname=\"\"):\n    return Builder(\"img\").with_attributes(\n        src=src,\n        alt=alt,\n        width=width,\n        height=height,\n    ).with_attribute(\"class\", classname).build()\n\ndef Header1(text):\n    return Builder('h1').with_text(text).build()\n\ndef Paragraph(text):\n    return Builder('p').with_text(text).build()\n\ndef Spinner(text):\n    return Div(\"spinner-container\", [\n            Header1(text),\n        ]\n    )\n\ndef LoadingComponent():\n    \"\"\"Displays a loading indicator while data is being fetched.\"\"\"\n    return Div(\"loading\", [\n        Spinner(\"spinner\"),  # Replace 'Spinner' with your actual spinner component\n        Paragraph(\"Loading data...\")\n    ])\n\ndef ErrorComponent(error):\n    \"\"\"Displays an error message when data fetching fails.\"\"\"\n    return Div(\"error\", [\n        Image(\"./public/error.png\", \"error\", \"45\", \"45\"),\n        Header1(\"Error Fetching Data\"),\n        Paragraph(error)\n    ])\n</code></pre>"},{"location":"advanced/fetch_data/#main-component","title":"main component","text":"<pre><code>from zenaura.client.component import Component\nfrom zenaura.client.mutator import mutator \nfrom public.presentational import * \nimport requests\ndef DataDisplayComponent(data):\n    return Div(\"data-dict\", [\n            Div(\"item\", [Paragraph(key), Paragraph(str(value))])\n            for key, value in data.items()\n        ])\n\nclass DataFetcher(Component):\n    def __init__(self):\n        super().__init__()\n        self.state = {\"data\": None, \"error\": None}  # Initial state\n\n    async def fetch_data(self):\n        try:\n            api_url = 'https://randomuser.me/api/'  # Your API endpoint\n            response = requests.get(api_url)\n            if response.ok:\n                self.state[\"data\"] = response.json()\n            else:\n                self.state[\"error\"] = \"API request failed\"\n        except Exception as e:\n            self.state[\"error\"] = str(e)\n\n    @mutator\n    async def attached(self):\n        await self.fetch_data()\n        print(self.state[\"data\"])\n\n\n    def render(self):\n        if self.state[\"error\"]:\n            return ErrorComponent(error=self.state[\"error\"])\n        elif self.state[\"data\"]:\n            return DataDisplayComponent(data=self.state[\"data\"])\n        else:\n            return LoadingComponent()  \n</code></pre>"},{"location":"advanced/fetch_data/#build-and-run-zenaura-app","title":"Build and run zenaura app","text":"<pre><code>zenaura build\nzenaura run\n</code></pre> <p>now if we went to http://localhost:5000, and open the console we will see this </p> <pre><code>{\n  \"results\": [\n    {\n      \"gender\": \"male\",\n      \"name\": {\n        \"title\": \"Mr\",\n        \"first\": \"Charles\",\n        \"last\": \"Clark\"\n      },\n      \"location\": {\n        \"street\": {\n          \"number\": 5328,\n          \"name\": \"Vimy St\"\n        },\n        \"city\": \"Grand Falls\",\n        \"state\": \"Nunavut\",\n        \"country\": \"Canada\",\n        \"postcode\": \"Z1S 2U2\",\n        \"coordinates\": {\n          \"latitude\": \"-69.8976\",\n          \"longitude\": \"-134.5780\"\n        },\n        \"timezone\": {\n          \"offset\": \"-6:00\",\n          \"description\": \"Central Time (US &amp; Canada), Mexico City\"\n        }\n      },\n      \"email\": \"charles.clark@example.com\",\n      \"login\": {\n        \"uuid\": \"3338f687-3461-4a72-88e9-33eb19c9077d\",\n        \"username\": \"tinymeercat320\",\n        \"password\": \"kang\",\n        \"salt\": \"mrAgPCkY\",\n        \"md5\": \"1e1006b14c2e083026c86c129be8c0b8\",\n        \"sha1\": \"e29949ab4b75c8fa07b79312098e28edb7e10e27\",\n        \"sha256\": \"e3f3e1ffcf4e73ece750f437f70ac840a941b154e002a5d7327ee84111f59230\"\n      },\n      \"dob\": {\n        \"date\": \"1957-01-26T13:12:12.937Z\",\n        \"age\": 67\n      },\n      \"registered\": {\n        \"date\": \"2020-10-19T19:29:09.124Z\",\n        \"age\": 3\n      },\n      \"phone\": \"C57 P04-4851\",\n      \"cell\": \"R98 P02-7749\",\n      \"id\": {\n        \"name\": \"SIN\",\n        \"value\": \"389514100\"\n      },\n      \"picture\": {\n        \"large\": \"https://randomuser.me/api/portraits/men/70.jpg\",\n        \"medium\": \"https://randomuser.me/api/portraits/med/men/70.jpg\",\n        \"thumbnail\": \"https://randomuser.me/api/portraits/thumb/men/70.jpg\"\n      },\n      \"nat\": \"CA\"\n    }\n  ],\n  \"info\": {\n    \"seed\": \"61b28009e82e3240\",\n    \"results\": 1,\n    \"page\": 1,\n    \"version\": \"1.4\"\n  }\n}\n</code></pre>"},{"location":"advanced/fetch_data/#explanation","title":"Explanation","text":"<ul> <li>State: The <code>state</code> dictionary holds the fetched data (<code>data</code>) and any potential error messages (<code>error</code>).</li> <li><code>fetch_data</code>: This <code>async</code> function handles the API request using <code>requests</code>.</li> <li><code>data</code> &amp; <code>error</code>:  update the state based on the API response or error.</li> <li><code>attached</code>: Automatically fetches data when the component is added to the DOM, and re-render the component with the data.</li> </ul> <p>In all, this component will set data to data state, error to error if error exists, it uses python requests library to fetch requests, and on success renders an error or data. </p>"},{"location":"advanced/fetch_data/#key-improvements","title":"Key Improvements","text":"<ul> <li>Clearer structure and separation of concerns.</li> <li>Error handling mechanism.</li> <li>Flexibility to use different state management approaches.</li> </ul>"},{"location":"advanced/lifecycle/","title":"Component Lifecycle","text":""},{"location":"advanced/lifecycle/#lifecycle-methods-a-deep-dive-into-zenauras-virtual-dom-component-management","title":"Lifecycle Methods: A Deep Dive into Zenaura's Virtual DOM Component Management","text":"<p> Zenaura's component lifecycle management, facilitated by its virtual DOM (VDOM), offers a structured approach to handling component interactions within a web application's UI. Understanding these lifecycle methods is crucial for developers seeking to optimize component behavior and create seamless user experiences. Note the component lifecycle start with attached and until the last lifecycle which is on_settled. Within every transition even inside a lifecycle, on_error is there to gracefully handle errors.</p>"},{"location":"advanced/lifecycle/#mount-lifecycles-initializing-component-presence","title":"Mount LifeCycles: Initializing Component Presence","text":"<p>The <code>MountLifeCycles</code> class, extending <code>HydratorVirtualDomAdapter</code>, focuses on the initial stages of a component's lifecycle when it's integrated into the DOM:</p> <ul> <li><code>attached(comp)</code> (async): This method is triggered immediately after a component is mounted onto the DOM. It serves as the ideal space for essential setup tasks:<ul> <li>State Initialization: Establish the component's internal data and variables.</li> <li>Event Listener Setup: Attach handlers to respond to user interactions or other events.</li> <li>API Calls: Fetch external data to populate or update the component.</li> <li>Animations: Initiate visual transitions or effects upon mounting.</li> </ul> </li> </ul> <pre><code>async def attached(self, comp):\n    if hasattr(comp, 'attached'):\n        await comp.attached()\n</code></pre> <p>Key Point: The <code>attached</code> method only executes if the component itself defines an <code>attached</code> method. This flexibility allows developers to customize component behavior as needed.</p>"},{"location":"advanced/lifecycle/#render-lifecycle-managing-component-updates","title":"Render LifeCycle: Managing Component Updates","text":"<p>The <code>RenderLifeCycle</code> class focuses on the dynamic aspects of a component's existence, particularly when updates and re-renders occur:</p> <ul> <li><code>on_mutation(comp)</code> (async): This method is invoked before the actual DOM update takes place. It's designed for tasks that need to be executed right before the component's visual representation is altered:<ul> <li>State Updates Based on Props: Modify the component's internal state based on changes in its props (data passed from parent components).</li> <li>Pre-Update API Calls or Logic: Perform any necessary calculations or data fetching before the UI is refreshed.</li> </ul> </li> </ul> <pre><code>async def on_mutation(self, comp):\n    if hasattr(comp, 'on_mutation'):\n        await comp.on_mutation()\n</code></pre> <ul> <li><code>on_settled(comp)</code> (async): This method is activated after the DOM update is complete and the component has settled into its new state. It's ideal for post-render actions:<ul> <li>Focusing Elements: Automatically place the user's cursor in an input field.</li> <li>Scrolling: Programmatically scroll the page to a specific section or element.</li> <li>Custom Events: Trigger events to notify other parts of your application about the update.</li> </ul> </li> </ul> <pre><code>async def on_settled(self, comp):\n    if hasattr(comp, 'on_settled'):\n        await comp.on_settled()\n</code></pre> <p>Absolutely! Let's add the <code>on_error</code> lifecycle method to our deep dive guide:</p>"},{"location":"advanced/lifecycle/#error-handling-with-on_error","title":"Error Handling with <code>on_error</code>","text":"<p>In addition to the standard lifecycle methods, Zenaura provides the <code>on_error</code> lifecycle method to gracefully handle errors that might occur during the rendering process.</p> <ul> <li><code>on_error(comp, error)</code> (async): This method is triggered if an error is raised while a component is being rendered or updated. It receives two arguments:<ul> <li><code>comp</code>: The component instance where the error occurred.</li> <li><code>error</code>: The exception object representing the error.</li> </ul> </li> </ul> <pre><code>async def on_error(self, comp, error):\n    if hasattr(comp, 'on_error'):\n        await comp.on_error(error)\n</code></pre> <p>Purpose: The primary purpose of <code>on_error</code> is to allow you to:</p> <ul> <li>Log the Error:  Record details about the error for debugging and analysis.</li> <li>Display User-Friendly Messages:  Present a clear and informative error message to the user, rather than a technical stack trace.</li> <li>Fallback UI:  Render alternative content or a simplified version of the component to maintain some level of functionality.</li> <li>State Recovery:  Attempt to recover from the error by resetting the component's state or taking other corrective actions.</li> </ul>"},{"location":"advanced/lifecycle/#example-usage","title":"Example Usage","text":"<pre><code>class MyComponent:\n    # ... other lifecycle methods ...\n\n    async def on_error(self, error):\n        print(f\"Error in MyComponent: {error}\")  # Log the error\n        self.state['error_message'] = \"An error occurred while loading data.\"  # Update UI with error message\n</code></pre> <p>In this example, the <code>on_error</code> method logs the error to the console and updates the component's state to display an error message to the user.</p>"},{"location":"advanced/lifecycle/#best-practices","title":"Best Practices","text":"<ul> <li>Always Define <code>on_error</code>:  Include the <code>on_error</code> method in your components, even if you initially just log the error. It's better to have a basic error handler in place than to let errors crash your application silently.</li> <li>Be Specific:  Tailor your error handling to the specific types of errors that might occur in each component.</li> <li>Prioritize User Experience:  Focus on providing clear and helpful error messages to guide the user.</li> <li>Logging: Use logging to record error details for later analysis.</li> </ul> <p>By incorporating the <code>on_error</code> lifecycle method and following these best practices, you can create more robust and user-friendly Zenaura components that can gracefully recover from unexpected errors.</p>"},{"location":"advanced/lifecycle/#why-lifecycle-methods-matter","title":"Why Lifecycle Methods Matter","text":"<p>Understanding and utilizing lifecycle methods in Zenaura's VDOM system empowers developers to:</p> <ul> <li>Organize Logic: Break down complex component behavior into well-defined stages.</li> <li>Optimize Performance: Execute tasks precisely when needed, avoiding unnecessary computations.</li> <li>Enhance User Experience:  Create smooth, visually appealing updates and transitions.</li> <li>Customize Behavior: Tailor each component's lifecycle to suit specific requirements.</li> </ul>"},{"location":"advanced/lifecycle/#example-usage_1","title":"Example Usage","text":"<pre><code>class MyComponent:\n    async def attached(self):\n        # Fetch initial data from API\n        self.data = await fetch_data()\n\n    async def on_mutation(self):\n        # Update state based on props if needed\n        if self.props['filter'] != self.state['filter']:\n            self.state['filter'] = self.props['filter']\n            self.data = await fetch_filtered_data(self.state['filter'])\n\n    async def on_settled(self):\n        # Highlight the selected item in a list after re-render\n        highlight_selected_item()\n</code></pre> <p>In this example, the <code>attached</code> method fetches initial data, <code>on_mutation</code> handles state updates and subsequent data filtering, and <code>on_settled</code> manages UI interactions after the update.</p>"},{"location":"advanced/pydide/","title":"Pyodide: Python Scientific Stack in the Browser","text":"<p>Pyodide is a remarkable project that brings the full power of the Python scientific stack to your web browser. It enables you to run Python code, including popular libraries like NumPy, SciPy, Matplotlib, Pandas, and more, directly within the browser environment.</p>"},{"location":"advanced/pydide/#key-features-and-advantages","title":"Key Features and Advantages","text":"<ul> <li>WebAssembly (Wasm): Pyodide leverages the performance and portability of WebAssembly to execute Python code efficiently.</li> <li>Scientific Stack: Access a vast array of scientific computing libraries, making it ideal for data analysis, visualization, machine learning, and other computational tasks.</li> <li>REPL (Interactive Shell): Experiment with Python code interactively in your browser using Pyodide's built-in REPL.</li> <li>Notebook Environments: Integrate Pyodide with popular notebook interfaces like JupyterLite for a familiar interactive development experience.</li> <li>Flexibility: Use Pyodide as a standalone library or as part of larger frameworks like PyScript.</li> </ul>"},{"location":"advanced/pydide/#how-pyodide-works","title":"How Pyodide Works","text":"<ol> <li>Emscripten: Pyodide uses Emscripten, a powerful compiler toolchain, to translate the CPython interpreter (the standard Python implementation) and its associated libraries into WebAssembly modules.</li> <li>WebAssembly Runtime: These WebAssembly modules are then loaded and executed within the browser's WebAssembly runtime.</li> <li>JavaScript Bridge: Pyodide provides a bridge between Python and JavaScript, allowing you to call JavaScript functions from Python and vice versa.</li> </ol>"},{"location":"advanced/pydide/#getting-started-with-pyodide","title":"Getting Started with Pyodide","text":"<ol> <li>Include Pyodide: Add the following <code>&lt;script&gt;</code> tag in your HTML file's <code>&lt;head&gt;</code> section:</li> </ol> <pre><code>&lt;script src=\"https://cdn.jsdelivr.net/pyodide/v0.23.4/full/pyodide.js\"&gt;&lt;/script&gt;\n</code></pre> <ol> <li>Load Packages: Use Pyodide's <code>loadPackage</code> function to import the necessary libraries:</li> </ol> <pre><code>async function main() {\n  let pyodide = await loadPyodide();\n  await pyodide.loadPackage([\"numpy\", \"matplotlib\"]);\n\n  // ... your Python code here\n}\n</code></pre> <ol> <li>Execute Python Code: Use Pyodide's <code>runPython</code> function to execute your Python code strings:</li> </ol> <pre><code>pyodide.runPython(`\n  import numpy as np\n  import matplotlib.pyplot as plt\n\n  x = np.arange(0, 2 * np.pi, 0.1)\n  y = np.sin(x)\n\n  plt.plot(x, y)\n  plt.show()\n`);\n</code></pre> <p>Example: Interactive Plot</p> <p>The above code snippet demonstrates how to create an interactive sine wave plot directly in your web page using Pyodide and Matplotlib.</p> <p>Advanced Pyodide Concepts</p> <ul> <li>Custom Packages:  Package and load your own Python modules into Pyodide.</li> <li>File System Access: Use Pyodide's virtual file system to interact with files.</li> <li>Web Workers: Run Pyodide in a background thread (Web Worker) for improved performance.</li> </ul> <p>Documentation and Resources</p> <ul> <li>Pyodide Documentation: https://pyodide.org/en/stable/</li> <li>Pyodide GitHub Repository: https://github.com/pyodide/pyodide</li> </ul>"},{"location":"advanced/pyscript/","title":"PyScript: Python in the Browser","text":"<p>PyScript is a framework that allows you to run Python code directly in your web browser. This opens up a wealth of possibilities, from creating interactive data visualizations and educational tools to building full-fledged web applications using your Python skills.</p>"},{"location":"advanced/pyscript/#key-features-and-advantages","title":"Key Features and Advantages","text":"<ul> <li>Ease of Use: PyScript eliminates the need for complex server setups or installations. Your Python code runs seamlessly within the browser environment.</li> <li>Expressiveness: Leverage the full power and readability of Python, a language known for its simplicity and versatility.</li> <li>Scalability: Your applications can run on any device with a modern web browser, from desktops to tablets and mobile phones.</li> <li>Shareability: PyScript applications are easily shared via URLs, making them accessible to a wide audience.</li> <li>Security: PyScript runs in the sandboxed environment of the browser, offering inherent security benefits.</li> </ul>"},{"location":"advanced/pyscript/#how-pyscript-works","title":"How PyScript Works","text":"<ol> <li>Pyodide:  At the core of PyScript is Pyodide, a port of CPython (the reference implementation of Python) to WebAssembly. This allows Python code to be interpreted and executed within the browser.</li> <li>DOM Interaction: PyScript provides mechanisms to interact with the Document Object Model (DOM), the structure of a web page. You can manipulate HTML elements, handle events, and dynamically update content using Python.</li> <li>FFI (Foreign Function Interface): PyScript enables seamless communication between Python and JavaScript through the FFI. This means you can access web APIs, utilize JavaScript libraries, and even call Python functions from JavaScript code.</li> </ol>"},{"location":"advanced/pyscript/#getting-started-with-pyscript","title":"Getting Started with PyScript","text":"<ol> <li>Include PyScript: Add the following lines within the <code>&lt;head&gt;</code> section of your HTML file:</li> </ol> <pre><code>&lt;link rel=\"stylesheet\" href=\"https://pyscript.net/alpha/pyscript.css\" /&gt;\n&lt;script defer src=\"https://pyscript.net/alpha/pyscript.js\"&gt;&lt;/script&gt;\n</code></pre> <ol> <li>Write Python Code: Embed your Python code within <code>&lt;py-script&gt;</code> tags:</li> </ol> <pre><code>&lt;py-script&gt;\n  print(\"Hello from PyScript!\")\n&lt;/py-script&gt;\n</code></pre> <p>Example: Interactive Plot</p> <pre><code>&lt;py-script&gt;\nimport matplotlib.pyplot as plt\n\nx = [1, 2, 3, 4]\ny = [1, 4, 9, 16]\nplt.plot(x, y)\nplt.show()\n&lt;/py-script&gt;\n</code></pre> <p>This code will render a simple line plot directly in your web page.</p>"},{"location":"advanced/pyscript/#advanced-pyscript-concepts","title":"Advanced PyScript Concepts","text":"<ul> <li>Components: Create reusable UI elements (e.g., buttons, input fields) with custom logic.</li> <li>Plugins: Extend PyScript's functionality with plugins for tasks like code formatting and REPL (interactive shell) integration.</li> <li>Offline Mode: Cache PyScript resources for offline use.</li> </ul>"},{"location":"advanced/pyscript/#documentation-and-resources","title":"Documentation and Resources","text":"<p>The official PyScript documentation is your best resource for in-depth information and examples:</p> <ul> <li>PyScript Documentation: https://docs.pyscript.net/</li> </ul>"},{"location":"advanced/virtual_dom/","title":"Zenaura Virtual DOM: A Conceptual Deep Dive","text":"<p>  Zenaura's Virtual DOM revolutionizes how you build dynamic web interfaces. It introduces a layer of abstraction between your UI components and the browser's actual DOM, enabling faster updates and a smoother user experience.</p>"},{"location":"advanced/virtual_dom/#1-the-power-of-the-virtual-dom","title":"1. The Power of the Virtual DOM","text":"<ul> <li> <p>What is it?  The VDOM is a lightweight in-memory representation of your web page's structure, similar to a JavaScript object. It mirrors the real DOM but is much faster to manipulate.</p> </li> <li> <p>Why use it? Directly updating the actual DOM can be slow and inefficient. The VDOM allows Zenaura to intelligently determine the minimal set of changes needed and apply them efficiently, resulting in improved performance.</p> </li> </ul>"},{"location":"advanced/virtual_dom/#2-how-zenaura-vdom-works","title":"2. How Zenaura VDOM Works","text":"<ol> <li>Initial Render: When your Zenaura components render, they create a VDOM tree. This tree represents the initial state of your UI.</li> <li>State Changes: Data within your components are linked to mutators which are user events that when changed (e.g., through user interactions or API calls), the associated components re-render, creating a new VDOM tree.</li> <li>Diffing (Reconciliation): Zenaura compares the old VDOM tree with the new one to identify the differences. This process is called \"diffing\" or \"reconciliation.\"</li> <li>Efficient Updates: Zenaura applies only the necessary changes to the real DOM, updating elements, attributes, or text content as needed. It gather all the updates, intelligently determine the minimal set of operations, patch and schedule the update to the real DOM in asyncrounous non-blocking way. This insure smooth user experience, and very low latency, and fast app rendering.</li> </ol>"},{"location":"advanced/virtual_dom/#3-the-role-of-zenaura-components","title":"3. The Role of Zenaura Components","text":"<ul> <li> <p>Building Blocks: Your UI is composed of Zenaura <code>Component</code> classes. Each component defines its structure (<code>render</code> method) and how it reacts to data changes.</p> </li> <li> <p>Data-Driven: Components are data-driven. They render their structure based on their internal <code>state</code>. When state changes, the <code>render</code> method is called again, generating a new VDOM.</p> </li> <li> <p>Mutators (Optional): Zenaura provides the <code>@mutator</code> decorator for methods that modify component state. This ensures the VDOM is efficiently re-render the component intentionally, minimizing poor UI/UX resulting from developers re-rendering the component unintentionally.</p> </li> <li> <p>Lifecycle methods: Components can define lifecycle methods that extend the functionality of the component, you might want to do something before the component renders so you use <code>attached</code> lifecycle method, you might want to do something before the component re-renders so you use <code>on_mutation</code> lifecycle method, you might want to do something after the component re-renders so you use <code>on_seatled</code>, finally you might want to catch errors in the component so you use <code>on_error</code> lifecycle method. There is dedicated guides in advanced concepts section for lifecycle methods and handling errors.</p> </li> </ul>"},{"location":"advanced/virtual_dom/#4-zenaura-vdom-in-action-code-snippet","title":"4. Zenaura VDOM in Action: Code Snippet","text":"<pre><code>@Reuseable  # Marks the component as potentially having multiple instances\nclass Counter(Component):\n    # ... (state, mutators)\n\n    def render(self) -&gt; Node:\n        # Create VDOM nodes (div, button, etc.) based on component state\n        # ...\n</code></pre> <p>In this example:</p> <ul> <li><code>Counter</code> is a reusable component representing a counter widget.</li> <li>The <code>render</code> method constructs a VDOM tree describing the component's structure.</li> <li>User actions (like clicking buttons) trigger mutators that update the state, causing <code>render</code> to be called again, and the VDOM to be refreshed.</li> </ul>"},{"location":"advanced/virtual_dom/#benefits-of-zenaura-vdom","title":"Benefits of Zenaura VDOM","text":"<ul> <li>Performance: Minimizes expensive DOM manipulations, resulting in smoother UI updates.</li> <li>Declarative UI: Focus on describing what your UI should look like, not how to update it step by step.</li> <li>Component Reusability: Build modular components that encapsulate their own logic and state.</li> </ul>"},{"location":"advanced/virtual_dom/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Zenaura VDOM is a powerful tool for building high-performance, interactive web applications.</li> <li>Understanding the VDOM concept is key to mastering Zenaura development.</li> <li>Leverage the VDOM's capabilities to create efficient and maintainable UIs.</li> </ul>"},{"location":"api/client/app/","title":"Router","text":""},{"location":"api/client/app/#zenaura.client.app.App","title":"<code>App</code>","text":"<p>Represents a router for managing routes and navigation.</p> <p>This class provides methods for adding routes, navigating between pages, and handling the current location.</p> <p>Attributes:</p> Name Type Description <code>routes</code> <code>dict</code> <p>A dictionary mapping paths to their associated pages and titles.</p> <code>paths</code> <code>list</code> <p>A list of paths registered in the router.</p> <code>history</code> <code>PageHistory</code> <p>An object that manages the history of visited pages.</p> Source code in <code>zenaura\\client\\app.py</code> <pre><code>class App:\n    \"\"\"\n    Represents a router for managing routes and navigation.\n\n    This class provides methods for adding routes, navigating between pages, and handling the current location.\n\n    Attributes:\n        routes (dict): A dictionary mapping paths to their associated pages and titles.\n        paths (list): A list of paths registered in the router.\n        history (PageHistory): An object that manages the history of visited pages.\n\n    Methods:\n        __init__()\n            Initializes the App with empty routes and paths, and sets up the initial route handling.\n        navigate(path)\n            Navigates to the specified path by mounting the associated page and updating the document title and browser history.\n        handle_location()\n            Handles the current location by mounting the associated page and updating the document title.\n        add_route(route)\n            Adds a route to the router's configuration.\n        back()\n            Navigates back to the previous Page in the history stack.\n        forward()\n            Navigates forward to the next Page in the history stack.\n        get_current_route()\n            Get the page and title of the current route, or None if not found.\n    \"\"\"\n    def __init__(self, layout=None):\n        \"\"\"\n            Initializes the App with empty routes and paths, and sets up the initial route handling.\n        \"\"\"\n        # key -&gt; path , value -&gt; [page, document.title]\n        self.routes = defaultdict(str)\n        self.paths = []\n        self.history = PageHistory()\n        self._laytout = layout\n\n    @property\n    def layout(self):\n        return self._layout\n\n    @layout.setter\n    def layout(self, new_layout):\n        self._layout = new_layout \n\n    async def not_found(self):\n        document.title = \"Page Not Found\"\n        page = Page([notFound])\n        await zenaura_dom.mount(page)\n        self.history.visit(page)\n\n    async def mount_layout(self) -&gt; None:\n        \"\"\"\n            Trigger mount method for layout components if layout is defined\n        \"\"\"\n        if self._layout:\n            # mount  global components \n            comps = self._layout.top + self._layout.bottom\n            for comp in comps:\n                if hasattr(comp, \"attached\"):\n                    await comp.attached()\n\n\n    async def navigate(self, path) -&gt; None:\n        \"\"\"\n        Navigates to the specified path by mounting the associated pageonent and updating the document title and browser history.\n\n        Parameters\n        ----------\n        path : str\n            The path to navigate to.\n        \"\"\"\n        # handle route\n        matched_route, params = self._match_route(path)\n        if not matched_route:\n            await self.not_found()\n            return\n\n        [page, title, middleware, ssr] = matched_route\n\n        if callable(middleware):\n            middleware()\n\n        if ssr:  # Ignore mount step for server side rendering pages.\n            await zenaura_dom.mount(page)\n            self.history.visit(page)\n            document.title = title\n            return\n\n        if not self.history.current.page:  # self.history.current is initially None\n            pass\n        else:\n            self.hyd_rdom_toggle_pages_visibilty(self.history.current.page, page)\n\n        window.history.pushState(path, title, path)  # Update browser history\n\n        # trigger layout components mount if layout is defined, after \n        # the reason after pushState, middleware\n        # global components may be be coupled to a state of route path or middleware\n        await self.mount_layout()\n        # mount page\n        await zenaura_dom.mount(page)\n        self.history.visit(page)\n        document.title = title\n\n    def hyd_rdom_toggle_pages_visibilty(self, previous_page: Page, current_page: Page):\n        p_page = document.querySelector(f'[data-zenaura=\"{previous_page.id}\"]')\n        if p_page:\n            p_page.hidden = True  # Hide the previous page\n        curr_page = document.querySelector(f'[data-zenaura=\"{current_page.id}\"]')\n        if curr_page:\n            curr_page.hidden = False  # Show the current page\n\n    async def handle_location(self) -&gt; None:\n        \"\"\"\n        Handles the current location by mounting the associated page and updating the document title.\n        \"\"\"\n        # handle home route\n        path = window.location.pathname\n        matched_route, params = self._match_route(path)\n        if not matched_route:\n            await self.not_found()\n            return\n        [page, title, middleware, ssr] = self.routes[path]\n        window.history.pushState(path, title, path)  # Update browser history\n\n        if callable(middleware):\n            middleware()\n\n        # trigger layout components mount if layout is defined, after \n        # the reason after pushState, middleware\n        # global components may be be coupled to a state of route path or middleware\n        await self.mount_layout()\n        if ssr:  # Ignore mount step for server side rendering pages.\n            await zenaura_dom.mount(page)\n            self.history.visit(page)\n            document.title = title\n            return\n        if not self.history.current.page:  # self.history.current is initially None\n           pass\n        else:\n            self.hyd_rdom_toggle_pages_visibilty(self.history.current.page, page)\n\n        # visit page\n        self.history.visit(page)\n        await zenaura_dom.mount(page)  # Trigger attached lifecycle for each component within the page.\n\n\n    def add_route(self, route : Route) -&gt; None:\n        \"\"\"\n        Adds a route to the router's configuration.\n\n        Parameters\n        ----------\n        route : Route\n            The route to be added to the router's configuration.\n        \"\"\"\n        self.routes[route.path] = [route.page, route.title, route.middleware, route.ssr]\n        self.paths.append(route.path)\n\n    async def back(self) -&gt; None:\n        \"\"\"\n        Navigates back to the previous Page in the history stack.\n        \"\"\"\n        previous_page = self.history.current.page\n        curr_page = self.history.back()\n        rdom_hyd.hyd_rdom_toggle_pages_visibilty(previous_page, curr_page)\n        await zenaura_dom.mount(curr_page)  # trigger attached lifecycle for each component within the page.\n\n\n    async def forward(self) -&gt; None:\n        \"\"\"\n        Navigates forward to the next Page in the history stack.\n        \"\"\"\n        previous_page = self.history.current.page\n        curr_page = self.history.forward()\n        rdom_hyd.hyd_rdom_toggle_pages_visibilty(previous_page, curr_page)\n        await zenaura_dom.mount(curr_page)  # trigger attached lifecycle for each component within the page.\n\n\n    def get_current_route(self) -&gt; Optional[Tuple[Page, str]]:\n        \"\"\"\n        Get the page and title of the current route, or None if not found.\n        \"\"\"\n        path = window.location.pathname\n        matched_route, info = self._match_route(path)\n        return matched_route, info\n\n    # TODO still needs a lot of work\n    def _match_route(self, path: str) -&gt; Tuple[Optional[Tuple[Page, str, Dict[str, Any]]], Dict[str, str]]:\n        \"\"\"\n        Matches the given path to a registered route and extracts parameters.\n\n        Args:\n            path (str): The path to match.\n\n        Returns:\n            Tuple[Optional[Tuple[Page, str, Dict[str, Any]]], Dict[str, str]]:\n                A tuple containing the matched route information (if any) and extracted parameters.\n        \"\"\"\n        for route_path, (page, title, middleware, ssr) in self.routes.items():\n            if \"*\" in route_path:  # Wildcard route\n                route_parts = route_path.split(\"*\")\n                if path.startswith(route_parts[0]):\n                    params = path[len(route_parts[0]):]\n                    query = defaultdict(str)\n                    if \"?\" in params: # get all queries\n                        newq = \"\".join(params).split(\"?\")\n                        params = newq[0]\n                        newq = newq[1]\n                        for q in newq.split(\"&amp;\"):\n                            k,v = q.split(\"=\")\n                            query[k] = v\n                    if \"/\" in params: # get all params\n                        params = params.split(\"/\")\n\n                    params = {\"wildcard\": {\"params\" : params, \"query\" : query} }\n\n                    return (page, title, middleware, ssr), params\n            elif \":\" in route_path:  # Parameterized route\n                route_parts = route_path.split(\"/\")\n                path_parts = path.split(\"/\")\n                if len(route_parts) == len(path_parts):\n                    params = {}\n                    for i, part in enumerate(route_parts):\n                        if part.startswith(\":\"):\n                            param_name = part[1:]\n                            params[param_name] = path_parts[i]\n                    return (page, title, middleware, ssr), params\n            elif route_path == path:  # Exact match\n                return (page, title, middleware, ssr), {}\n        return None, {}  # No match found\n</code></pre>"},{"location":"api/client/app/#zenaura.client.app.App.__init__","title":"<code>__init__(layout=None)</code>","text":"<p>Initializes the App with empty routes and paths, and sets up the initial route handling.</p> Source code in <code>zenaura\\client\\app.py</code> <pre><code>def __init__(self, layout=None):\n    \"\"\"\n        Initializes the App with empty routes and paths, and sets up the initial route handling.\n    \"\"\"\n    # key -&gt; path , value -&gt; [page, document.title]\n    self.routes = defaultdict(str)\n    self.paths = []\n    self.history = PageHistory()\n    self._laytout = layout\n</code></pre>"},{"location":"api/client/app/#zenaura.client.app.App.add_route","title":"<code>add_route(route)</code>","text":"<p>Adds a route to the router's configuration.</p>"},{"location":"api/client/app/#zenaura.client.app.App.add_route--parameters","title":"Parameters","text":"<p>route : Route     The route to be added to the router's configuration.</p> Source code in <code>zenaura\\client\\app.py</code> <pre><code>def add_route(self, route : Route) -&gt; None:\n    \"\"\"\n    Adds a route to the router's configuration.\n\n    Parameters\n    ----------\n    route : Route\n        The route to be added to the router's configuration.\n    \"\"\"\n    self.routes[route.path] = [route.page, route.title, route.middleware, route.ssr]\n    self.paths.append(route.path)\n</code></pre>"},{"location":"api/client/app/#zenaura.client.app.App.back","title":"<code>back()</code>  <code>async</code>","text":"<p>Navigates back to the previous Page in the history stack.</p> Source code in <code>zenaura\\client\\app.py</code> <pre><code>async def back(self) -&gt; None:\n    \"\"\"\n    Navigates back to the previous Page in the history stack.\n    \"\"\"\n    previous_page = self.history.current.page\n    curr_page = self.history.back()\n    rdom_hyd.hyd_rdom_toggle_pages_visibilty(previous_page, curr_page)\n    await zenaura_dom.mount(curr_page)  # trigger attached lifecycle for each component within the page.\n</code></pre>"},{"location":"api/client/app/#zenaura.client.app.App.forward","title":"<code>forward()</code>  <code>async</code>","text":"<p>Navigates forward to the next Page in the history stack.</p> Source code in <code>zenaura\\client\\app.py</code> <pre><code>async def forward(self) -&gt; None:\n    \"\"\"\n    Navigates forward to the next Page in the history stack.\n    \"\"\"\n    previous_page = self.history.current.page\n    curr_page = self.history.forward()\n    rdom_hyd.hyd_rdom_toggle_pages_visibilty(previous_page, curr_page)\n    await zenaura_dom.mount(curr_page)  # trigger attached lifecycle for each component within the page.\n</code></pre>"},{"location":"api/client/app/#zenaura.client.app.App.get_current_route","title":"<code>get_current_route()</code>","text":"<p>Get the page and title of the current route, or None if not found.</p> Source code in <code>zenaura\\client\\app.py</code> <pre><code>def get_current_route(self) -&gt; Optional[Tuple[Page, str]]:\n    \"\"\"\n    Get the page and title of the current route, or None if not found.\n    \"\"\"\n    path = window.location.pathname\n    matched_route, info = self._match_route(path)\n    return matched_route, info\n</code></pre>"},{"location":"api/client/app/#zenaura.client.app.App.handle_location","title":"<code>handle_location()</code>  <code>async</code>","text":"<p>Handles the current location by mounting the associated page and updating the document title.</p> Source code in <code>zenaura\\client\\app.py</code> <pre><code>async def handle_location(self) -&gt; None:\n    \"\"\"\n    Handles the current location by mounting the associated page and updating the document title.\n    \"\"\"\n    # handle home route\n    path = window.location.pathname\n    matched_route, params = self._match_route(path)\n    if not matched_route:\n        await self.not_found()\n        return\n    [page, title, middleware, ssr] = self.routes[path]\n    window.history.pushState(path, title, path)  # Update browser history\n\n    if callable(middleware):\n        middleware()\n\n    # trigger layout components mount if layout is defined, after \n    # the reason after pushState, middleware\n    # global components may be be coupled to a state of route path or middleware\n    await self.mount_layout()\n    if ssr:  # Ignore mount step for server side rendering pages.\n        await zenaura_dom.mount(page)\n        self.history.visit(page)\n        document.title = title\n        return\n    if not self.history.current.page:  # self.history.current is initially None\n       pass\n    else:\n        self.hyd_rdom_toggle_pages_visibilty(self.history.current.page, page)\n\n    # visit page\n    self.history.visit(page)\n    await zenaura_dom.mount(page)  # Trigger attached lifecycle for each component within the page.\n</code></pre>"},{"location":"api/client/app/#zenaura.client.app.App.mount_layout","title":"<code>mount_layout()</code>  <code>async</code>","text":"<p>Trigger mount method for layout components if layout is defined</p> Source code in <code>zenaura\\client\\app.py</code> <pre><code>async def mount_layout(self) -&gt; None:\n    \"\"\"\n        Trigger mount method for layout components if layout is defined\n    \"\"\"\n    if self._layout:\n        # mount  global components \n        comps = self._layout.top + self._layout.bottom\n        for comp in comps:\n            if hasattr(comp, \"attached\"):\n                await comp.attached()\n</code></pre>"},{"location":"api/client/app/#zenaura.client.app.App.navigate","title":"<code>navigate(path)</code>  <code>async</code>","text":"<p>Navigates to the specified path by mounting the associated pageonent and updating the document title and browser history.</p>"},{"location":"api/client/app/#zenaura.client.app.App.navigate--parameters","title":"Parameters","text":"<p>path : str     The path to navigate to.</p> Source code in <code>zenaura\\client\\app.py</code> <pre><code>async def navigate(self, path) -&gt; None:\n    \"\"\"\n    Navigates to the specified path by mounting the associated pageonent and updating the document title and browser history.\n\n    Parameters\n    ----------\n    path : str\n        The path to navigate to.\n    \"\"\"\n    # handle route\n    matched_route, params = self._match_route(path)\n    if not matched_route:\n        await self.not_found()\n        return\n\n    [page, title, middleware, ssr] = matched_route\n\n    if callable(middleware):\n        middleware()\n\n    if ssr:  # Ignore mount step for server side rendering pages.\n        await zenaura_dom.mount(page)\n        self.history.visit(page)\n        document.title = title\n        return\n\n    if not self.history.current.page:  # self.history.current is initially None\n        pass\n    else:\n        self.hyd_rdom_toggle_pages_visibilty(self.history.current.page, page)\n\n    window.history.pushState(path, title, path)  # Update browser history\n\n    # trigger layout components mount if layout is defined, after \n    # the reason after pushState, middleware\n    # global components may be be coupled to a state of route path or middleware\n    await self.mount_layout()\n    # mount page\n    await zenaura_dom.mount(page)\n    self.history.visit(page)\n    document.title = title\n</code></pre>"},{"location":"api/client/app/#zenaura.client.app.NotFound","title":"<code>NotFound</code>","text":"<p>             Bases: <code>Component</code></p> <p>Represents a page for displaying a \"page not found\" message.</p>"},{"location":"api/client/app/#zenaura.client.app.NotFound--methods","title":"Methods","text":"<p>render()     Returns a Node representing the \"page not found\" message.</p> Source code in <code>zenaura\\client\\app.py</code> <pre><code>@Reuseable\nclass NotFound(Component):\n    \"\"\"\n    Represents a page for displaying a \"page not found\" message.\n\n    Methods\n    -------\n    render()\n        Returns a Node representing the \"page not found\" message.\n    \"\"\"\n    def render(self):\n        em = Node(\"div\")\n        em.append_child(Node(name=\"text\", children=[\"page not found\"]))\n        return em\n</code></pre>"},{"location":"api/client/app/#zenaura.client.app.Route","title":"<code>Route</code>","text":"<p>Represents a route configuration for the App.</p> Source code in <code>zenaura\\client\\app.py</code> <pre><code>class Route:\n    \"\"\"\n        Represents a route configuration for the App.\n    \"\"\"\n    def __init__(self, title, path, page, middleware=None, ssr=False):\n        \"\"\"\n        Initializes a Route with the specified title, path, and pageonent.\n        Attributes\n        ----------\n        title : str\n            The title of the route.\n        path : str\n            The path of the route.\n        page : Page\n            A page of pageonents.\n        handler : Optional[Callable]\n            Optional route-specific logic handler.\n        middleware : Optional[Callable]\n            Optional route-specific logic handler.\n        ssr : bool\n            Whether the route is server-side rendered.\n        \"\"\"\n        self.title = title\n        self.path = path\n        self.page = page\n        self.ssr=ssr\n\n        if not isinstance(page, Page):\n            raise TypeError(\"Only a Page can be mounted on a route\")\n        self.middleware: Optional[Callable] = middleware  # For optional route-specific logic\n</code></pre>"},{"location":"api/client/app/#zenaura.client.app.Route.__init__","title":"<code>__init__(title, path, page, middleware=None, ssr=False)</code>","text":"<p>Initializes a Route with the specified title, path, and pageonent. Attributes</p> <p>title : str     The title of the route. path : str     The path of the route. page : Page     A page of pageonents. handler : Optional[Callable]     Optional route-specific logic handler. middleware : Optional[Callable]     Optional route-specific logic handler. ssr : bool     Whether the route is server-side rendered.</p> Source code in <code>zenaura\\client\\app.py</code> <pre><code>def __init__(self, title, path, page, middleware=None, ssr=False):\n    \"\"\"\n    Initializes a Route with the specified title, path, and pageonent.\n    Attributes\n    ----------\n    title : str\n        The title of the route.\n    path : str\n        The path of the route.\n    page : Page\n        A page of pageonents.\n    handler : Optional[Callable]\n        Optional route-specific logic handler.\n    middleware : Optional[Callable]\n        Optional route-specific logic handler.\n    ssr : bool\n        Whether the route is server-side rendered.\n    \"\"\"\n    self.title = title\n    self.path = path\n    self.page = page\n    self.ssr=ssr\n\n    if not isinstance(page, Page):\n        raise TypeError(\"Only a Page can be mounted on a route\")\n    self.middleware: Optional[Callable] = middleware  # For optional route-specific logic\n</code></pre>"},{"location":"api/client/component/","title":"component","text":"Source code in <code>zenaura\\client\\component.py</code> <pre><code>class UUIDManager:\n    @staticmethod\n    def generate_uuid(cls_name, count):\n        # Combine class name and count to create a unique string\n        unique_string = f\"{cls_name}{count}\"\n        # Hash the unique string to produce a 32-bit UUID\n        uuid_hash = hashlib.md5(unique_string.encode()).hexdigest()[:8]\n        return uuid_hash\n</code></pre> <p>Decorator to mark a component as reusable.</p> <p>Reusable components can be instantiated multiple times and will maintain their own state.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type</code> <p>The component class to be decorated.</p> required <p>Returns:</p> Name Type Description <code>type</code> <p>The decorated component class.</p> Source code in <code>zenaura\\client\\component.py</code> <pre><code>def Reuseable(cls):\n    \"\"\"\n    Decorator to mark a component as reusable.\n\n    Reusable components can be instantiated multiple times and will maintain their own state.\n\n    Args:\n        cls (type): The component class to be decorated.\n\n    Returns:\n        type: The decorated component class.\n    \"\"\"\n\n    original_init = cls.__init__\n\n    def new_init(self, *args, **kwargs):\n        original_init(self, *args, **kwargs)\n        cls.count = next(cls._component_count)\n        self.id = UUIDManager.generate_uuid(cls.__name__, self.count)\n        _is_reuseable[cls.__name__] = True\n\n    cls.__init__ = new_init\n    return cls\n</code></pre>"},{"location":"api/client/component/#zenaura.client.component.Component","title":"<code>Component</code>","text":"<p>Base class for all Zenaura components.</p> <p>Components are the building blocks of Zenaura applications. They represent reusable units of functionality that can be composed to create complex user interfaces.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>A unique identifier for the component.</p> <code>state</code> <code>dict</code> <p>The state of the component.</p> <code>_state</code> <code>dict</code> <p>The internal state of the component.</p> <code>_track_instances</code> <code>dict</code> <p>A dictionary tracking the number of instances created for each component class.</p> <code>_component_count</code> <code>count</code> <p>An iterator that generates unique counts for each component instance.</p> <p>Methods:</p> Name Description <code>__init_subclass__</code> <p>Initializes the subclass and sets the initial count for the component class.</p> <code>__init__</code> <p>Initializes the component instance and sets the unique identifier.</p> <code>get_state</code> <p>Returns the state of the component.</p> <code>set_state</code> <p>Sets the state of the component.</p> <code>render</code> <p>Abstract method that must be implemented by subclasses to define the behavior of the component.</p> Source code in <code>zenaura\\client\\component.py</code> <pre><code>class Component:\n    \"\"\"\n    Base class for all Zenaura components.\n\n    Components are the building blocks of Zenaura applications. They represent reusable units of functionality that can be composed to create complex user interfaces.\n\n    Attributes:\n        id (str): A unique identifier for the component.\n        state (dict): The state of the component.\n        _state (dict): The internal state of the component.\n        _track_instances (dict): A dictionary tracking the number of instances created for each component class.\n        _component_count (itertools.count): An iterator that generates unique counts for each component instance.\n\n    Methods:\n        __init_subclass__(cls, **kwargs):\n            Initializes the subclass and sets the initial count for the component class.\n        __init__(self):\n            Initializes the component instance and sets the unique identifier.\n        get_state(self):\n            Returns the state of the component.\n        set_state(self, state):\n            Sets the state of the component.\n        render(self):\n            Abstract method that must be implemented by subclasses to define the behavior of the component.\n    \"\"\"\n\n    _state = defaultdict(str)\n    _track_instances = defaultdict(int)\n    _component_count = itertools.count(0)\n\n    def __init_subclass__(cls, **kwargs):\n        \"\"\"\n        Initializes the subclass and sets the initial count for the component class.\n        \"\"\"\n        cls.count = next(cls._component_count)\n        cls.id = UUIDManager.generate_uuid(cls.__name__, cls.count)\n        super().__init_subclass__(**kwargs)\n\n    def __init__(self):\n        \"\"\"\n        Initializes the component instance and sets the unique identifier.\n        \"\"\"\n        cls = self.__class__\n        Component._track_instances[cls.__name__] += 1\n        if Component._track_instances[cls.__name__] &gt; 1 and not _is_reuseable[cls.__name__]:\n            raise TypeError(\n\"\"\"\n    Zenaura class component are limted by design. \\n\n    Decorate component with @Reuseable to implicitly  \\n\n    state the component is meant to be reused:  \\n\n    example :  \\n\n        class ThisIsLimited(Component):  \\n\n            pass\n        c1 = ThisIsLimited() // no error  \\n\n        c2 = ThisIsLimited() // throws error  \\n\n\n        @Reuseable  \\n\n        class ThisIsReuseable(Component):  \\n\n        c1 = ThisIsReuseable() // no error  \\n\n        c2 = ThisIsReuseable() // no error  \\n\n\"\"\"\n            )\n\n\n        # print(Component._track_instances[cls.__name__], cls.__name__, is_decorated_with_reuseable(cls))\n\n    @property\n    def state(self):\n        \"\"\"\n        Get the state of the component.\n\n        Returns:\n        dict: The state of the component.\n        \"\"\"\n\n        return self.get_state()\n\n    @state.setter\n    def state(self, value):\n        \"\"\"\n        Set the state of the component.\n\n        Args:\n        value (dict): The new state of the component.\n\n        Returns:\n        None\n        \"\"\"\n\n        self.set_state(value)\n\n    def get_state(self):\n        \"\"\"\n        Get the state of the component.\n\n        Returns:\n        dict: The state of the component.\n        \"\"\"\n\n        return self._state\n\n    def set_state(self, state):\n        \"\"\"\n        Set the state of the component.\n\n        Args:\n        state (dict): The new state of the component.\n\n        Returns:\n        None\n        \"\"\"\n\n        self._state = state  # Update the internal state\n\n    @abstractmethod\n    def render():\n        \"\"\"\n        Abstract method to be implemented by subclasses.\n\n        This method should be implemented by subclasses to define the behavior of the component.\n\n        Returns:\n        None\n        \"\"\"\n</code></pre>"},{"location":"api/client/component/#zenaura.client.component.Component.state","title":"<code>state</code>  <code>property</code> <code>writable</code>","text":"<p>Get the state of the component.</p> <p>Returns: dict: The state of the component.</p>"},{"location":"api/client/component/#zenaura.client.component.Component.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the component instance and sets the unique identifier.</p> Source code in <code>zenaura\\client\\component.py</code> <pre><code>    def __init__(self):\n        \"\"\"\n        Initializes the component instance and sets the unique identifier.\n        \"\"\"\n        cls = self.__class__\n        Component._track_instances[cls.__name__] += 1\n        if Component._track_instances[cls.__name__] &gt; 1 and not _is_reuseable[cls.__name__]:\n            raise TypeError(\n\"\"\"\n    Zenaura class component are limted by design. \\n\n    Decorate component with @Reuseable to implicitly  \\n\n    state the component is meant to be reused:  \\n\n    example :  \\n\n        class ThisIsLimited(Component):  \\n\n            pass\n        c1 = ThisIsLimited() // no error  \\n\n        c2 = ThisIsLimited() // throws error  \\n\n\n        @Reuseable  \\n\n        class ThisIsReuseable(Component):  \\n\n        c1 = ThisIsReuseable() // no error  \\n\n        c2 = ThisIsReuseable() // no error  \\n\n\"\"\"\n            )\n</code></pre>"},{"location":"api/client/component/#zenaura.client.component.Component.__init_subclass__","title":"<code>__init_subclass__(**kwargs)</code>","text":"<p>Initializes the subclass and sets the initial count for the component class.</p> Source code in <code>zenaura\\client\\component.py</code> <pre><code>def __init_subclass__(cls, **kwargs):\n    \"\"\"\n    Initializes the subclass and sets the initial count for the component class.\n    \"\"\"\n    cls.count = next(cls._component_count)\n    cls.id = UUIDManager.generate_uuid(cls.__name__, cls.count)\n    super().__init_subclass__(**kwargs)\n</code></pre>"},{"location":"api/client/component/#zenaura.client.component.Component.get_state","title":"<code>get_state()</code>","text":"<p>Get the state of the component.</p> <p>Returns: dict: The state of the component.</p> Source code in <code>zenaura\\client\\component.py</code> <pre><code>def get_state(self):\n    \"\"\"\n    Get the state of the component.\n\n    Returns:\n    dict: The state of the component.\n    \"\"\"\n\n    return self._state\n</code></pre>"},{"location":"api/client/component/#zenaura.client.component.Component.render","title":"<code>render()</code>  <code>abstractmethod</code>","text":"<p>Abstract method to be implemented by subclasses.</p> <p>This method should be implemented by subclasses to define the behavior of the component.</p> <p>Returns: None</p> Source code in <code>zenaura\\client\\component.py</code> <pre><code>@abstractmethod\ndef render():\n    \"\"\"\n    Abstract method to be implemented by subclasses.\n\n    This method should be implemented by subclasses to define the behavior of the component.\n\n    Returns:\n    None\n    \"\"\"\n</code></pre>"},{"location":"api/client/component/#zenaura.client.component.Component.set_state","title":"<code>set_state(state)</code>","text":"<p>Set the state of the component.</p> <p>Args: state (dict): The new state of the component.</p> <p>Returns: None</p> Source code in <code>zenaura\\client\\component.py</code> <pre><code>def set_state(self, state):\n    \"\"\"\n    Set the state of the component.\n\n    Args:\n    state (dict): The new state of the component.\n\n    Returns:\n    None\n    \"\"\"\n\n    self._state = state  # Update the internal state\n</code></pre>"},{"location":"api/client/component/#zenaura.client.component.Reuseable","title":"<code>Reuseable(cls)</code>","text":"<p>Decorator to mark a component as reusable.</p> <p>Reusable components can be instantiated multiple times and will maintain their own state.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type</code> <p>The component class to be decorated.</p> required <p>Returns:</p> Name Type Description <code>type</code> <p>The decorated component class.</p> Source code in <code>zenaura\\client\\component.py</code> <pre><code>def Reuseable(cls):\n    \"\"\"\n    Decorator to mark a component as reusable.\n\n    Reusable components can be instantiated multiple times and will maintain their own state.\n\n    Args:\n        cls (type): The component class to be decorated.\n\n    Returns:\n        type: The decorated component class.\n    \"\"\"\n\n    original_init = cls.__init__\n\n    def new_init(self, *args, **kwargs):\n        original_init(self, *args, **kwargs)\n        cls.count = next(cls._component_count)\n        self.id = UUIDManager.generate_uuid(cls.__name__, self.count)\n        _is_reuseable[cls.__name__] = True\n\n    cls.__init__ = new_init\n    return cls\n</code></pre>"},{"location":"api/client/mocks/","title":"mocks","text":""},{"location":"api/client/mocks/#zenaura.client.mocks.Content","title":"<code>Content</code>","text":"<p>Represents the content of an element.</p> <p>Attributes:</p> Name Type Description <code>firstChild</code> <code>str</code> <p>The text content of the first child element.</p> Source code in <code>zenaura\\client\\mocks.py</code> <pre><code>class Content:\n    \"\"\"\n    Represents the content of an element.\n\n    Attributes:\n        firstChild (str): The text content of the first child element.\n    \"\"\"\n\n    def __init__(self):\n        self.firstChild = \"\"\n</code></pre>"},{"location":"api/client/mocks/#zenaura.client.mocks.MockDocument","title":"<code>MockDocument</code>","text":"<p>Represents the HTML document object model (DOM).</p> <p>Attributes:</p> Name Type Description <code>body</code> <code>MockElement</code> <p>The body element of the document.</p> <code>elementsById</code> <code>dict</code> <p>A dictionary of elements in the document, indexed by their ID.</p> <code>title</code> <code>str</code> <p>The title of the document.</p> Source code in <code>zenaura\\client\\mocks.py</code> <pre><code>class MockDocument:  # Use MagicMock for flexibility\n    \"\"\"\n    Represents the HTML document object model (DOM).\n\n    Attributes:\n        body (MockElement): The body element of the document.\n        elementsById (dict): A dictionary of elements in the document, indexed by their ID.\n        title (str): The title of the document.\n    \"\"\"\n\n    def __init__(self):\n        self.body = MockElement(\"body\")  # Create a body element\n        self.elementsById = {\"root\": self.body}  # Store elements by ID\n        self.title = \"\"\n\n    def getElementById(self, element_id):\n        \"\"\"\n        Gets the element with the given ID.\n\n        Args:\n            element_id (str): The ID of the element.\n\n        Returns:\n            MockElement: The element with the given ID, or None if the element does not exist.\n        \"\"\"\n\n        return self.elementsById.get(element_id)\n\n    def createElement(self, tag_name):\n        \"\"\"\n        Creates a new MockElement with the given tag name.\n\n        Args:\n            tag_name (str): The tag name of the new element.\n\n        Returns:\n            MockElement: The newly created element.\n        \"\"\"\n\n        return MockElement(tag_name)\n\n    def setElementById(self, element_id, element):\n        \"\"\"\n        Sets the element with the given ID.\n\n        Args:\n            element_id (str): The ID of the element.\n            element (MockElement): The element to set.\n        \"\"\"\n\n        # for mocking purposes\n        self.elementsById[element_id] = element\n\n    def createTextNode(self, txt):\n        \"\"\"\n        Creates a new MockTextNode with the given text.\n\n        Args:\n            txt (str): The text content of the new node.\n\n        Returns:\n            MockTextNode: The newly created node.\n        \"\"\"\n\n        textNode = MockTextNode(txt)\n        return textNode\n\n    def querySelector(self, query: str):\n        \"\"\"\n        Selects the first element that matches the given CSS selector.\n\n        Args:\n            query (str): The CSS selector to use.\n\n        Returns:\n            MockElement: The first element that matches the selector, or None if no element matches.\n        \"\"\"\n\n        query = query.replace(\"[\", \"\").replace(\"]\", \"\").replace('\"', \"\").split(\"=\")\n        id = query[-1]\n        if id in self.elementsById:\n            return self.elementsById[id]\n        return False\n</code></pre>"},{"location":"api/client/mocks/#zenaura.client.mocks.MockDocument.createElement","title":"<code>createElement(tag_name)</code>","text":"<p>Creates a new MockElement with the given tag name.</p> <p>Parameters:</p> Name Type Description Default <code>tag_name</code> <code>str</code> <p>The tag name of the new element.</p> required <p>Returns:</p> Name Type Description <code>MockElement</code> <p>The newly created element.</p> Source code in <code>zenaura\\client\\mocks.py</code> <pre><code>def createElement(self, tag_name):\n    \"\"\"\n    Creates a new MockElement with the given tag name.\n\n    Args:\n        tag_name (str): The tag name of the new element.\n\n    Returns:\n        MockElement: The newly created element.\n    \"\"\"\n\n    return MockElement(tag_name)\n</code></pre>"},{"location":"api/client/mocks/#zenaura.client.mocks.MockDocument.createTextNode","title":"<code>createTextNode(txt)</code>","text":"<p>Creates a new MockTextNode with the given text.</p> <p>Parameters:</p> Name Type Description Default <code>txt</code> <code>str</code> <p>The text content of the new node.</p> required <p>Returns:</p> Name Type Description <code>MockTextNode</code> <p>The newly created node.</p> Source code in <code>zenaura\\client\\mocks.py</code> <pre><code>def createTextNode(self, txt):\n    \"\"\"\n    Creates a new MockTextNode with the given text.\n\n    Args:\n        txt (str): The text content of the new node.\n\n    Returns:\n        MockTextNode: The newly created node.\n    \"\"\"\n\n    textNode = MockTextNode(txt)\n    return textNode\n</code></pre>"},{"location":"api/client/mocks/#zenaura.client.mocks.MockDocument.getElementById","title":"<code>getElementById(element_id)</code>","text":"<p>Gets the element with the given ID.</p> <p>Parameters:</p> Name Type Description Default <code>element_id</code> <code>str</code> <p>The ID of the element.</p> required <p>Returns:</p> Name Type Description <code>MockElement</code> <p>The element with the given ID, or None if the element does not exist.</p> Source code in <code>zenaura\\client\\mocks.py</code> <pre><code>def getElementById(self, element_id):\n    \"\"\"\n    Gets the element with the given ID.\n\n    Args:\n        element_id (str): The ID of the element.\n\n    Returns:\n        MockElement: The element with the given ID, or None if the element does not exist.\n    \"\"\"\n\n    return self.elementsById.get(element_id)\n</code></pre>"},{"location":"api/client/mocks/#zenaura.client.mocks.MockDocument.querySelector","title":"<code>querySelector(query)</code>","text":"<p>Selects the first element that matches the given CSS selector.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The CSS selector to use.</p> required <p>Returns:</p> Name Type Description <code>MockElement</code> <p>The first element that matches the selector, or None if no element matches.</p> Source code in <code>zenaura\\client\\mocks.py</code> <pre><code>def querySelector(self, query: str):\n    \"\"\"\n    Selects the first element that matches the given CSS selector.\n\n    Args:\n        query (str): The CSS selector to use.\n\n    Returns:\n        MockElement: The first element that matches the selector, or None if no element matches.\n    \"\"\"\n\n    query = query.replace(\"[\", \"\").replace(\"]\", \"\").replace('\"', \"\").split(\"=\")\n    id = query[-1]\n    if id in self.elementsById:\n        return self.elementsById[id]\n    return False\n</code></pre>"},{"location":"api/client/mocks/#zenaura.client.mocks.MockDocument.setElementById","title":"<code>setElementById(element_id, element)</code>","text":"<p>Sets the element with the given ID.</p> <p>Parameters:</p> Name Type Description Default <code>element_id</code> <code>str</code> <p>The ID of the element.</p> required <code>element</code> <code>MockElement</code> <p>The element to set.</p> required Source code in <code>zenaura\\client\\mocks.py</code> <pre><code>def setElementById(self, element_id, element):\n    \"\"\"\n    Sets the element with the given ID.\n\n    Args:\n        element_id (str): The ID of the element.\n        element (MockElement): The element to set.\n    \"\"\"\n\n    # for mocking purposes\n    self.elementsById[element_id] = element\n</code></pre>"},{"location":"api/client/mocks/#zenaura.client.mocks.MockElement","title":"<code>MockElement</code>","text":"<p>Represents an HTML element in the DOM.</p> <p>Attributes:</p> Name Type Description <code>tagName</code> <code>str</code> <p>The tag name of the element.</p> <code>innerHTML</code> <code>str</code> <p>The HTML content of the element.</p> <code>outerHTML</code> <code>str</code> <p>The complete HTML representation of the element, including its children.</p> <code>attributes</code> <code>dict</code> <p>A dictionary of the element's attributes.</p> <code>childNodes</code> <code>list</code> <p>A list of the element's child nodes.</p> <code>parentNode</code> <code>MockElement</code> <p>The parent element of the node.</p> <code>content</code> <code>Content</code> <p>The content of the element.</p> Source code in <code>zenaura\\client\\mocks.py</code> <pre><code>class MockElement:\n    \"\"\"\n    Represents an HTML element in the DOM.\n\n    Attributes:\n        tagName (str): The tag name of the element.\n        innerHTML (str): The HTML content of the element.\n        outerHTML (str): The complete HTML representation of the element, including its children.\n        attributes (dict): A dictionary of the element's attributes.\n        childNodes (list): A list of the element's child nodes.\n        parentNode (MockElement): The parent element of the node.\n        content (Content): The content of the element.\n    \"\"\"\n\n    def __init__(self, tag_name=None, innerHTML=\"\"):\n        self.tagName = tag_name\n        self.innerHTML = innerHTML\n        self.outerHTML = \"\"\n        self.attributes = {}\n        self.childNodes = []\n        self.parentNode = None\n        self.content = Content()\n\n    def setAttribute(self, name, value):\n        \"\"\"\n        Sets the value of an attribute on the element.\n\n        Args:\n            name (str): The name of the attribute.\n            value (str): The value of the attribute.\n        \"\"\"\n\n        self.attributes[name] = value\n\n    def getAttribute(self, name):\n        \"\"\"\n        Gets the value of an attribute on the element.\n\n        Args:\n            name (str): The name of the attribute.\n\n        Returns:\n            str: The value of the attribute, or None if the attribute does not exist.\n        \"\"\"\n\n        return self.attributes.get(name)\n\n    def removeAttribute(self, name):\n        \"\"\"\n        Removes an attribute from the element.\n\n        Args:\n            name (str): The name of the attribute.\n        \"\"\"\n\n        self.attributes.pop(name, None)\n\n    def appendChild(self, child):\n        \"\"\"\n        Appends a child node to the element.\n\n        Args:\n            child (MockElement or MockTextNode): The child node to append.\n        \"\"\"\n\n        if child not in self.childNodes:\n            self.childNodes.append(child)\n            if isinstance(child, MockElement):\n                child.parentNode = self\n\n    def removeChild(self, child):\n        \"\"\"\n        Removes a child node from the element.\n\n        Args:\n            child (MockElement or MockTextNode): The child node to remove.\n        \"\"\"\n\n        if child in self.childNodes:\n            self.childNodes.remove(child)\n            child.parentNode = None\n\n    def createElement(self, tag_name):\n        \"\"\"\n        Creates a new MockElement with the given tag name.\n\n        Args:\n            tag_name (str): The tag name of the new element.\n\n        Returns:\n            MockElement: The newly created element.\n        \"\"\"\n\n        return MockElement(tag_name)\n\n    def __repr__(self):  # Helpful for debugging\n        return f\"&lt;MockElement '{self.tagName}'&gt;\"\n</code></pre>"},{"location":"api/client/mocks/#zenaura.client.mocks.MockElement.appendChild","title":"<code>appendChild(child)</code>","text":"<p>Appends a child node to the element.</p> <p>Parameters:</p> Name Type Description Default <code>child</code> <code>MockElement or MockTextNode</code> <p>The child node to append.</p> required Source code in <code>zenaura\\client\\mocks.py</code> <pre><code>def appendChild(self, child):\n    \"\"\"\n    Appends a child node to the element.\n\n    Args:\n        child (MockElement or MockTextNode): The child node to append.\n    \"\"\"\n\n    if child not in self.childNodes:\n        self.childNodes.append(child)\n        if isinstance(child, MockElement):\n            child.parentNode = self\n</code></pre>"},{"location":"api/client/mocks/#zenaura.client.mocks.MockElement.createElement","title":"<code>createElement(tag_name)</code>","text":"<p>Creates a new MockElement with the given tag name.</p> <p>Parameters:</p> Name Type Description Default <code>tag_name</code> <code>str</code> <p>The tag name of the new element.</p> required <p>Returns:</p> Name Type Description <code>MockElement</code> <p>The newly created element.</p> Source code in <code>zenaura\\client\\mocks.py</code> <pre><code>def createElement(self, tag_name):\n    \"\"\"\n    Creates a new MockElement with the given tag name.\n\n    Args:\n        tag_name (str): The tag name of the new element.\n\n    Returns:\n        MockElement: The newly created element.\n    \"\"\"\n\n    return MockElement(tag_name)\n</code></pre>"},{"location":"api/client/mocks/#zenaura.client.mocks.MockElement.getAttribute","title":"<code>getAttribute(name)</code>","text":"<p>Gets the value of an attribute on the element.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attribute.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>The value of the attribute, or None if the attribute does not exist.</p> Source code in <code>zenaura\\client\\mocks.py</code> <pre><code>def getAttribute(self, name):\n    \"\"\"\n    Gets the value of an attribute on the element.\n\n    Args:\n        name (str): The name of the attribute.\n\n    Returns:\n        str: The value of the attribute, or None if the attribute does not exist.\n    \"\"\"\n\n    return self.attributes.get(name)\n</code></pre>"},{"location":"api/client/mocks/#zenaura.client.mocks.MockElement.removeAttribute","title":"<code>removeAttribute(name)</code>","text":"<p>Removes an attribute from the element.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attribute.</p> required Source code in <code>zenaura\\client\\mocks.py</code> <pre><code>def removeAttribute(self, name):\n    \"\"\"\n    Removes an attribute from the element.\n\n    Args:\n        name (str): The name of the attribute.\n    \"\"\"\n\n    self.attributes.pop(name, None)\n</code></pre>"},{"location":"api/client/mocks/#zenaura.client.mocks.MockElement.removeChild","title":"<code>removeChild(child)</code>","text":"<p>Removes a child node from the element.</p> <p>Parameters:</p> Name Type Description Default <code>child</code> <code>MockElement or MockTextNode</code> <p>The child node to remove.</p> required Source code in <code>zenaura\\client\\mocks.py</code> <pre><code>def removeChild(self, child):\n    \"\"\"\n    Removes a child node from the element.\n\n    Args:\n        child (MockElement or MockTextNode): The child node to remove.\n    \"\"\"\n\n    if child in self.childNodes:\n        self.childNodes.remove(child)\n        child.parentNode = None\n</code></pre>"},{"location":"api/client/mocks/#zenaura.client.mocks.MockElement.setAttribute","title":"<code>setAttribute(name, value)</code>","text":"<p>Sets the value of an attribute on the element.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the attribute.</p> required <code>value</code> <code>str</code> <p>The value of the attribute.</p> required Source code in <code>zenaura\\client\\mocks.py</code> <pre><code>def setAttribute(self, name, value):\n    \"\"\"\n    Sets the value of an attribute on the element.\n\n    Args:\n        name (str): The name of the attribute.\n        value (str): The value of the attribute.\n    \"\"\"\n\n    self.attributes[name] = value\n</code></pre>"},{"location":"api/client/mocks/#zenaura.client.mocks.MockLocation","title":"<code>MockLocation</code>","text":"<p>Represents the location object of the browser window.</p> <p>Attributes:</p> Name Type Description <code>href</code> <code>str</code> <p>The URL of the current page.</p> <code>pathname</code> <code>str</code> <p>The path portion of the URL.</p> Source code in <code>zenaura\\client\\mocks.py</code> <pre><code>class MockLocation:\n    \"\"\"\n    Represents the location object of the browser window.\n\n    Attributes:\n        href (str): The URL of the current page.\n        pathname (str): The path portion of the URL.\n    \"\"\"\n\n    def __init__(self):\n        self.href = \"http://localhost:8000\"  # Example\n        self.pathname = \"\"\n</code></pre>"},{"location":"api/client/mocks/#zenaura.client.mocks.MockTextNode","title":"<code>MockTextNode</code>","text":"<p>Represents a text node in the DOM.</p> <p>Attributes:</p> Name Type Description <code>nodeValue</code> <code>str</code> <p>The text content of the node.</p> <code>parentNode</code> <code>MockElement</code> <p>The parent element of the node.</p> Source code in <code>zenaura\\client\\mocks.py</code> <pre><code>class MockTextNode:\n    \"\"\"\n    Represents a text node in the DOM.\n\n    Attributes:\n        nodeValue (str): The text content of the node.\n        parentNode (MockElement): The parent element of the node.\n    \"\"\"\n\n    def __init__(self, text):\n        self.nodeValue = text\n        self.parentNode = None\n</code></pre>"},{"location":"api/client/mocks/#zenaura.client.mocks.MockWindow","title":"<code>MockWindow</code>","text":"<p>Represents the browser window object.</p> <p>Attributes:</p> Name Type Description <code>innerWidth</code> <code>int</code> <p>The width of the window in pixels.</p> <code>innerHeight</code> <code>int</code> <p>The height of the window in pixels.</p> <code>location</code> <code>MockLocation</code> <p>The location object of the window.</p> <code>history</code> <code>MockWindowHistory</code> <p>The history object of the window.</p> Source code in <code>zenaura\\client\\mocks.py</code> <pre><code>class MockWindow:\n    \"\"\"\n    Represents the browser window object.\n\n    Attributes:\n        innerWidth (int): The width of the window in pixels.\n        innerHeight (int): The height of the window in pixels.\n        location (MockLocation): The location object of the window.\n        history (MockWindowHistory): The history object of the window.\n    \"\"\"\n\n    def __init__(self):\n        self.innerWidth = 1024\n        self.innerHeight = 768\n        self.location = MockLocation()\n        self.history = MockWindowHistory()\n</code></pre>"},{"location":"api/client/mocks/#zenaura.client.mocks.MockWindowHistory","title":"<code>MockWindowHistory</code>","text":"<p>Represents the history object of the browser window.</p> <p>Attributes:</p> Name Type Description <code>history</code> <code>list</code> <p>A list of the pages that have been visited.</p> Source code in <code>zenaura\\client\\mocks.py</code> <pre><code>class MockWindowHistory:\n    \"\"\"\n    Represents the history object of the browser window.\n\n    Attributes:\n        history (list): A list of the pages that have been visited.\n    \"\"\"\n\n    def __init__(self):\n        self.history = []\n\n    def pushState(self, *args, **kwargs):\n        \"\"\"\n        Adds a new entry to the history stack.\n\n        Args:\n            *args: Arguments to be passed to the history.pushState() method.\n            **kwargs: Keyword arguments to be passed to the history.pushState() method.\n        \"\"\"\n\n        self.history.append([args, kwargs])\n</code></pre>"},{"location":"api/client/mocks/#zenaura.client.mocks.MockWindowHistory.pushState","title":"<code>pushState(*args, **kwargs)</code>","text":"<p>Adds a new entry to the history stack.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Arguments to be passed to the history.pushState() method.</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments to be passed to the history.pushState() method.</p> <code>{}</code> Source code in <code>zenaura\\client\\mocks.py</code> <pre><code>def pushState(self, *args, **kwargs):\n    \"\"\"\n    Adds a new entry to the history stack.\n\n    Args:\n        *args: Arguments to be passed to the history.pushState() method.\n        **kwargs: Keyword arguments to be passed to the history.pushState() method.\n    \"\"\"\n\n    self.history.append([args, kwargs])\n</code></pre>"},{"location":"api/client/page/","title":"page","text":""},{"location":"api/client/page/#zenaura.client.page.Page","title":"<code>Page</code>","text":"<p>Represents a page in a Zenaura application.</p> <p>A Page is a container for components that are displayed together. It manages the lifecycle of its child components and handles rendering them to the DOM.</p> <p>Attributes:</p> Name Type Description <code>count</code> <code>int</code> <p>A unique identifier for the page.</p> <code>id</code> <code>str</code> <p>A unique UUID for the page.</p> <code>children</code> <code>List[Component]</code> <p>The list of components that belong to this page.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>children</code> is not a list or if any child is not a <code>Component</code>.</p> Source code in <code>zenaura\\client\\page.py</code> <pre><code>class Page:\n    \"\"\"\n    Represents a page in a Zenaura application.\n\n    A Page is a container for components that are displayed together. It manages the\n    lifecycle of its child components and handles rendering them to the DOM.\n\n    Attributes:\n        count (int): A unique identifier for the page.\n        id (str): A unique UUID for the page.\n        children (List[Component]): The list of components that belong to this page.\n\n    Raises:\n        TypeError: If `children` is not a list or if any child is not a `Component`.\n    \"\"\"\n\n    _page_count = itertools.count(0)\n\n    def __init__(self, children: List[Component], attributes: Dict = None):\n        \"\"\"\n        Initializes a new Page instance.\n\n        Args:\n            children (List[Component]): The list of components to be added to the page.\n            attributes Dict : list of attributes for the page wrapper div\n        \"\"\"\n\n        self.count = next(self._page_count)\n        self.id = UUIDManager.generate_uuid(self.__class__.__name__, self.count)\n        self.children = children\n        self.attributes ={} if not attributes else attributes\n\n        if not isinstance(self.children, list):\n            raise TypeError(\"children must be a list\")\n\n        for child in self.children:\n            if not isinstance(child, Component):\n                raise TypeError(\"page children must be a Component\")\n</code></pre>"},{"location":"api/client/page/#zenaura.client.page.Page.__init__","title":"<code>__init__(children, attributes=None)</code>","text":"<p>Initializes a new Page instance.</p> <p>Parameters:</p> Name Type Description Default <code>children</code> <code>List[Component]</code> <p>The list of components to be added to the page.</p> required <code>attributes</code> <code>Dict</code> <p>list of attributes for the page wrapper div</p> <code>None</code> Source code in <code>zenaura\\client\\page.py</code> <pre><code>def __init__(self, children: List[Component], attributes: Dict = None):\n    \"\"\"\n    Initializes a new Page instance.\n\n    Args:\n        children (List[Component]): The list of components to be added to the page.\n        attributes Dict : list of attributes for the page wrapper div\n    \"\"\"\n\n    self.count = next(self._page_count)\n    self.id = UUIDManager.generate_uuid(self.__class__.__name__, self.count)\n    self.children = children\n    self.attributes ={} if not attributes else attributes\n\n    if not isinstance(self.children, list):\n        raise TypeError(\"children must be a list\")\n\n    for child in self.children:\n        if not isinstance(child, Component):\n            raise TypeError(\"page children must be a Component\")\n</code></pre>"},{"location":"api/client/algorithm/operations/","title":"Operations","text":""},{"location":"api/client/algorithm/operations/#zenaura.client.algorithm.operations.ADD_ATTRIBUTE","title":"<code>ADD_ATTRIBUTE = 'ADD_ATTRIBUTE'</code>  <code>module-attribute</code>","text":"<p>{     name : \"ADD_ATTRIBUTE\",     context: {         \"attr_name\" : \"attr-name\",         \"attr_value\" : \"attr-value\",     } }</p>"},{"location":"api/client/algorithm/operations/#zenaura.client.algorithm.operations.ADD_NODE","title":"<code>ADD_NODE = 'ADD_NODE'</code>  <code>module-attribute</code>","text":"<p>{     name : \"ADD_NODE\",     context: {         \"children\" : child-node,     } }</p>"},{"location":"api/client/algorithm/operations/#zenaura.client.algorithm.operations.NODE_INNER_TEXT","title":"<code>NODE_INNER_TEXT = 'NODE_INNER_TEXT'</code>  <code>module-attribute</code>","text":"<p>{     name : \"NODE_INNER_TEXT\",     context: {         \"text\" : \"sanitized-text\",     } }</p>"},{"location":"api/client/algorithm/operations/#zenaura.client.algorithm.operations.REMOVE_ATTRIBUTE","title":"<code>REMOVE_ATTRIBUTE = 'REMOVE_ATTRIBUTE'</code>  <code>module-attribute</code>","text":"<p>{     name : \"REMOVE_ATTRIBUTE\",     context: {         \"attr_name\" : \"attr-name\",     } }</p>"},{"location":"api/client/algorithm/operations/#zenaura.client.algorithm.operations.REMOVE_NODE","title":"<code>REMOVE_NODE = 'REMOVE_NODE'</code>  <code>module-attribute</code>","text":"<p>{     name : \"REMOVE_NODE\",     context: {         \"children\" : child-node,     } }</p>"},{"location":"api/client/algorithm/operations/#zenaura.client.algorithm.operations.REPLACE_ATTRIBUTE","title":"<code>REPLACE_ATTRIBUTE = 'REPLACE_ATTRIBUTE'</code>  <code>module-attribute</code>","text":"<p>{     name : \"REPLACE_ATTRIBUTE\",     context: {         \"attr_name\" : \"attr-name\",         \"attr_value\" : \"attr-value\",     } }</p>"},{"location":"api/client/algorithm/overview/","title":"Overview","text":""},{"location":"api/client/algorithm/overview/#zenaura.client.algorithm.algorithm.DiffingAlgorithm","title":"<code>DiffingAlgorithm</code>","text":"<p>             Bases: <code>Searcher</code>, <code>Updater</code></p> <p>The diffing algorithm in Zenaura virtual DOM.</p> <p>This class is responsible for comparing the old and new virtual DOM trees and generating a list of changes that need to be applied to the real DOM.</p> <p>The diffing algorithm is implemented in two steps:</p> <ol> <li>Search: The <code>Searcher</code> class traverses the old and new virtual DOM trees and identifies the nodes that have changed.</li> <li>Update: The <code>Updater</code> class applies the changes to the real DOM.</li> </ol> <p>The diffing algorithm is designed to be efficient and performant. It uses a number of techniques to minimize the number of changes that need to be applied to the real DOM.</p> <p>Attributes:</p> <ul> <li><code>Searcher</code>: An instance of the <code>Searcher</code> class.</li> <li><code>Updater</code>: An instance of the <code>Updater</code> class.</li> </ul> <p>Methods:</p> <ul> <li><code>diff(old_tree, new_tree)</code>: Compares the old and new virtual DOM trees and generates a list of changes that need to be applied to the real DOM.</li> </ul> <p>Example:</p> <pre><code># Create an instance of the DiffingAlgorithm class.\ndiffing_algorithm = DiffingAlgorithm()\n\n# Compare the old and new virtual DOM trees.\nchanges = diffing_algorithm.diff(old_tree, new_tree)\n\n# Apply the changes to the real DOM.\ndiffing_algorithm.update(changes)\n</code></pre> Source code in <code>zenaura\\client\\algorithm\\algorithm.py</code> <pre><code>class DiffingAlgorithm(\n    Searcher,\n    Updater\n):\n    \"\"\"\n        The diffing algorithm in Zenaura virtual DOM.\n\n        This class is responsible for comparing the old and new virtual DOM trees and generating a list of changes that need to be applied to the real DOM.\n\n        The diffing algorithm is implemented in two steps:\n\n        1. **Search:** The `Searcher` class traverses the old and new virtual DOM trees and identifies the nodes that have changed.\n        2. **Update:** The `Updater` class applies the changes to the real DOM.\n\n        The diffing algorithm is designed to be efficient and performant. It uses a number of techniques to minimize the number of changes that need to be applied to the real DOM.\n\n        **Attributes:**\n\n        * `Searcher`: An instance of the `Searcher` class.\n        * `Updater`: An instance of the `Updater` class.\n\n        **Methods:**\n\n        * `diff(old_tree, new_tree)`: Compares the old and new virtual DOM trees and generates a list of changes that need to be applied to the real DOM.\n\n        **Example:**\n\n        ```python\n        # Create an instance of the DiffingAlgorithm class.\n        diffing_algorithm = DiffingAlgorithm()\n\n        # Compare the old and new virtual DOM trees.\n        changes = diffing_algorithm.diff(old_tree, new_tree)\n\n        # Apply the changes to the real DOM.\n        diffing_algorithm.update(changes)\n        ```\n    \"\"\"\n</code></pre>"},{"location":"api/client/algorithm/searcher/","title":"Searcher","text":""},{"location":"api/client/algorithm/searcher/#zenaura.client.algorithm.searcher.Searcher","title":"<code>Searcher</code>","text":"<p>             Bases: <code>HydratorCompilerAdapter</code></p> <p>This class implements the searching step of the Zenaura virtual DOM algorithm.</p> <p>It takes two virtual DOM trees, the previous and the new one, and identifies the differences between them. These differences are then used to update the real DOM efficiently.</p> Source code in <code>zenaura\\client\\algorithm\\searcher.py</code> <pre><code>class Searcher(\n    HydratorCompilerAdapter\n):\n    \"\"\"\n    This class implements the searching step of the Zenaura virtual DOM algorithm.\n\n    It takes two virtual DOM trees, the previous and the new one, and identifies the differences between them.\n    These differences are then used to update the real DOM efficiently.\n\n    Attributes:\n        None\n    \"\"\"\n\n    def updater_context_builder(self, name: str, context: dict) -&gt; dict:\n        \"\"\"\n        Builds the context for the updater.\n\n        This method takes the name of the operation and its context and returns a dictionary that will be used by the updater.\n\n        Args:\n            name: The name of the operation.\n            context: The context of the operation.\n\n        Returns:\n            A dictionary containing the name and context of the operation.\n        \"\"\"\n\n        return {\n            \"name\": name,\n            \"context\": context\n        }\n\n    def patches_builder(self, prev_child_node, new_child_node, id, child_id):\n        \"\"\"\n        Builds the patches for the updater.\n\n        This method takes the previous and new child nodes, the component ID, and the child ID, and returns a list of patches that will be used by the updater.\n\n        Args:\n            prev_child_node: The previous child node.\n            new_child_node: The new child node.\n            id: The ID of the component.\n            child_id: The ID of the child.\n\n        Returns:\n            A list of patches containing the operation name, the new child node, the child ID, and the context for the updater.\n        \"\"\"\n\n        return [\n            self.hyd_comp_get_keyed_uuid(\n                id=id,\n                child_id=child_id\n            ),\n            new_child_node,\n            child_id,\n            self.updater_context_builder(\n                name=REMOVE_NODE,\n                context={\"children\": prev_child_node}\n            )\n        ]\n\n    def search(self, prevNode: Node, newNode: Node, id: str) -&gt; List[List[any]]:\n        \"\"\"\n        Searches for the differences between the previous and new virtual DOM trees.\n\n        This method takes the previous and new virtual DOM trees and the component ID, and returns a list of lists of differences. Each difference is represented as a list containing the operation name, the new child node, the path of the child, and the context for the updater.\n\n        Args:\n            prevNode: The previous virtual DOM tree.\n            newNode: The new virtual DOM tree.\n            id: The ID of the component.\n\n        Returns:\n            A list of lists of differences.\n        \"\"\"\n\n        # Error handling:\n        if not prevNode and not newNode:\n            return []\n        if not isinstance(prevNode, Node) or not isinstance(newNode, Node):\n            return []\n\n        differences = []\n\n        def helper(prev_child_node: Node, new_child_node: Node, id, prev_child_path: str, new_child_path) -&gt; None:\n            \"\"\"\n            Helper method for the search method.\n\n            This method recursively compares the previous and new child nodes and their attributes and children, and adds the differences to the `differences` list.\n\n            Args:\n                prev_child_node: The previous child node.\n                new_child_node: The new child node.\n                id: The ID of the component.\n                prev_child_path: The path of the previous child node.\n                new_child_path: The path of the new child node.\n            \"\"\"\n\n            nonlocal differences\n\n            # Added node\n            if not prev_child_node and new_child_node:\n                differences.append([\n                    self.hyd_comp_get_keyed_uuid(\n                        id=id,\n                        key=prev_child_path\n                    ),\n                    new_child_node,\n                    prev_child_path,\n                    self.updater_context_builder(\n                        name=ADD_NODE,\n                        context={\"children\": new_child_node}\n                    )\n                ])\n                return\n\n            # Removed node\n            if prev_child_node and not new_child_node:\n                differences.append([\n                    self.hyd_comp_get_keyed_uuid(\n                        id=id,\n                        key=prev_child_path\n                    ),\n                    prev_child_node,\n                    prev_child_path,\n                    self.updater_context_builder(\n                        name=REMOVE_NODE,\n                        context={\"children\": prev_child_node}\n                    )\n                ])\n                return\n\n            # Changed child by name\n            if prev_child_node.name != new_child_node.name:\n                differences.append([\n                    self.hyd_comp_get_keyed_uuid(\n                        id=id,\n                        key=prev_child_path\n                    ),\n                    prev_child_node,\n                    prev_child_path,\n                    self.updater_context_builder(\n                        name=REMOVE_NODE,\n                        context={\"children\": prev_child_node}\n                    )\n                ])\n                differences.append([\n                    self.hyd_comp_get_keyed_uuid(\n                        id=id,\n                        key=new_child_path\n                    ),\n                    new_child_node,\n                    new_child_path,\n                    self.updater_context_builder(\n                        name=ADD_NODE,\n                        context={\"children\": new_child_node}\n                    )\n                ])\n                return\n\n            # Compare attributes\n            for [prev_attr, new_attr] in zip_longest(prev_child_node.attributes, new_child_node.attributes):\n\n                # Removed attribute\n                if prev_attr and not new_attr:\n                    differences.append([\n                        self.hyd_comp_get_keyed_uuid(\n                            id=id,\n                            key=prev_child_path\n                        ),\n                        new_child_node,\n                        prev_child_path,\n                        self.updater_context_builder(\n                            name=REMOVE_ATTRIBUTE,\n                            context={\"attr_name\": prev_attr.key}\n                        )\n                    ])\n                    continue\n\n                # Added attribute\n                if not prev_attr and new_attr:\n                    differences.append([\n                        self.hyd_comp_get_keyed_uuid(\n                            id=id,\n                            key=new_child_path\n                        ),\n                        new_child_node,\n                        new_child_path,\n                        self.updater_context_builder(\n                            name=ADD_ATTRIBUTE,\n                            context={\"attr_name\": new_attr.key, \"attr_value\": new_attr.value}\n                        )\n                    ])\n                    continue\n\n                # Replaced value attribute\n                if prev_attr and new_attr:\n                    if prev_attr.value != new_attr.value:\n                        differences.append([\n                            self.hyd_comp_get_keyed_uuid(\n                                id=id,\n                                key=prev_child_path\n                            ),\n                            new_child_node,\n                            prev_child_path,\n                            self.updater_context_builder(\n                                name=ADD_ATTRIBUTE,\n                                context={\"attr_name\": new_attr.key, \"attr_value\": new_attr.value}\n                            )\n                        ])\n\n            # Compare children\n            for idx, (prev_child, new_child) in enumerate(zip_longest(prev_child_node.children, new_child_node.children)):\n                # Leaf text nodes\n                if prev_child and new_child:\n                    if prev_child.is_text_node and new_child.is_text_node and (prev_child.text != new_child.text):\n                        differences.append([\n                            self.hyd_comp_get_keyed_uuid(\n                                id=id,\n                                key=prev_child_path\n                            ),\n                            new_child_node,\n                            prev_child_path,\n                            self.updater_context_builder(\n                                name=NODE_INNER_TEXT,\n                                context={\"text\": new_child.text}\n                            )\n                        ])\n                        continue\n\n                new_child_path = new_child.path if isinstance(new_child, Node) else \"\"\n                prev_child_path = prev_child.path if isinstance(prev_child, Node) else \"\"\n                helper(prev_child, new_child, id, prev_child_path=prev_child_path, new_child_path=new_child_path)\n\n        helper(prevNode, newNode, id, 0, 0)\n        return differences\n</code></pre>"},{"location":"api/client/algorithm/searcher/#zenaura.client.algorithm.searcher.Searcher.patches_builder","title":"<code>patches_builder(prev_child_node, new_child_node, id, child_id)</code>","text":"<p>Builds the patches for the updater.</p> <p>This method takes the previous and new child nodes, the component ID, and the child ID, and returns a list of patches that will be used by the updater.</p> <p>Parameters:</p> Name Type Description Default <code>prev_child_node</code> <p>The previous child node.</p> required <code>new_child_node</code> <p>The new child node.</p> required <code>id</code> <p>The ID of the component.</p> required <code>child_id</code> <p>The ID of the child.</p> required <p>Returns:</p> Type Description <p>A list of patches containing the operation name, the new child node, the child ID, and the context for the updater.</p> Source code in <code>zenaura\\client\\algorithm\\searcher.py</code> <pre><code>def patches_builder(self, prev_child_node, new_child_node, id, child_id):\n    \"\"\"\n    Builds the patches for the updater.\n\n    This method takes the previous and new child nodes, the component ID, and the child ID, and returns a list of patches that will be used by the updater.\n\n    Args:\n        prev_child_node: The previous child node.\n        new_child_node: The new child node.\n        id: The ID of the component.\n        child_id: The ID of the child.\n\n    Returns:\n        A list of patches containing the operation name, the new child node, the child ID, and the context for the updater.\n    \"\"\"\n\n    return [\n        self.hyd_comp_get_keyed_uuid(\n            id=id,\n            child_id=child_id\n        ),\n        new_child_node,\n        child_id,\n        self.updater_context_builder(\n            name=REMOVE_NODE,\n            context={\"children\": prev_child_node}\n        )\n    ]\n</code></pre>"},{"location":"api/client/algorithm/searcher/#zenaura.client.algorithm.searcher.Searcher.search","title":"<code>search(prevNode, newNode, id)</code>","text":"<p>Searches for the differences between the previous and new virtual DOM trees.</p> <p>This method takes the previous and new virtual DOM trees and the component ID, and returns a list of lists of differences. Each difference is represented as a list containing the operation name, the new child node, the path of the child, and the context for the updater.</p> <p>Parameters:</p> Name Type Description Default <code>prevNode</code> <code>Node</code> <p>The previous virtual DOM tree.</p> required <code>newNode</code> <code>Node</code> <p>The new virtual DOM tree.</p> required <code>id</code> <code>str</code> <p>The ID of the component.</p> required <p>Returns:</p> Type Description <code>List[List[any]]</code> <p>A list of lists of differences.</p> Source code in <code>zenaura\\client\\algorithm\\searcher.py</code> <pre><code>def search(self, prevNode: Node, newNode: Node, id: str) -&gt; List[List[any]]:\n    \"\"\"\n    Searches for the differences between the previous and new virtual DOM trees.\n\n    This method takes the previous and new virtual DOM trees and the component ID, and returns a list of lists of differences. Each difference is represented as a list containing the operation name, the new child node, the path of the child, and the context for the updater.\n\n    Args:\n        prevNode: The previous virtual DOM tree.\n        newNode: The new virtual DOM tree.\n        id: The ID of the component.\n\n    Returns:\n        A list of lists of differences.\n    \"\"\"\n\n    # Error handling:\n    if not prevNode and not newNode:\n        return []\n    if not isinstance(prevNode, Node) or not isinstance(newNode, Node):\n        return []\n\n    differences = []\n\n    def helper(prev_child_node: Node, new_child_node: Node, id, prev_child_path: str, new_child_path) -&gt; None:\n        \"\"\"\n        Helper method for the search method.\n\n        This method recursively compares the previous and new child nodes and their attributes and children, and adds the differences to the `differences` list.\n\n        Args:\n            prev_child_node: The previous child node.\n            new_child_node: The new child node.\n            id: The ID of the component.\n            prev_child_path: The path of the previous child node.\n            new_child_path: The path of the new child node.\n        \"\"\"\n\n        nonlocal differences\n\n        # Added node\n        if not prev_child_node and new_child_node:\n            differences.append([\n                self.hyd_comp_get_keyed_uuid(\n                    id=id,\n                    key=prev_child_path\n                ),\n                new_child_node,\n                prev_child_path,\n                self.updater_context_builder(\n                    name=ADD_NODE,\n                    context={\"children\": new_child_node}\n                )\n            ])\n            return\n\n        # Removed node\n        if prev_child_node and not new_child_node:\n            differences.append([\n                self.hyd_comp_get_keyed_uuid(\n                    id=id,\n                    key=prev_child_path\n                ),\n                prev_child_node,\n                prev_child_path,\n                self.updater_context_builder(\n                    name=REMOVE_NODE,\n                    context={\"children\": prev_child_node}\n                )\n            ])\n            return\n\n        # Changed child by name\n        if prev_child_node.name != new_child_node.name:\n            differences.append([\n                self.hyd_comp_get_keyed_uuid(\n                    id=id,\n                    key=prev_child_path\n                ),\n                prev_child_node,\n                prev_child_path,\n                self.updater_context_builder(\n                    name=REMOVE_NODE,\n                    context={\"children\": prev_child_node}\n                )\n            ])\n            differences.append([\n                self.hyd_comp_get_keyed_uuid(\n                    id=id,\n                    key=new_child_path\n                ),\n                new_child_node,\n                new_child_path,\n                self.updater_context_builder(\n                    name=ADD_NODE,\n                    context={\"children\": new_child_node}\n                )\n            ])\n            return\n\n        # Compare attributes\n        for [prev_attr, new_attr] in zip_longest(prev_child_node.attributes, new_child_node.attributes):\n\n            # Removed attribute\n            if prev_attr and not new_attr:\n                differences.append([\n                    self.hyd_comp_get_keyed_uuid(\n                        id=id,\n                        key=prev_child_path\n                    ),\n                    new_child_node,\n                    prev_child_path,\n                    self.updater_context_builder(\n                        name=REMOVE_ATTRIBUTE,\n                        context={\"attr_name\": prev_attr.key}\n                    )\n                ])\n                continue\n\n            # Added attribute\n            if not prev_attr and new_attr:\n                differences.append([\n                    self.hyd_comp_get_keyed_uuid(\n                        id=id,\n                        key=new_child_path\n                    ),\n                    new_child_node,\n                    new_child_path,\n                    self.updater_context_builder(\n                        name=ADD_ATTRIBUTE,\n                        context={\"attr_name\": new_attr.key, \"attr_value\": new_attr.value}\n                    )\n                ])\n                continue\n\n            # Replaced value attribute\n            if prev_attr and new_attr:\n                if prev_attr.value != new_attr.value:\n                    differences.append([\n                        self.hyd_comp_get_keyed_uuid(\n                            id=id,\n                            key=prev_child_path\n                        ),\n                        new_child_node,\n                        prev_child_path,\n                        self.updater_context_builder(\n                            name=ADD_ATTRIBUTE,\n                            context={\"attr_name\": new_attr.key, \"attr_value\": new_attr.value}\n                        )\n                    ])\n\n        # Compare children\n        for idx, (prev_child, new_child) in enumerate(zip_longest(prev_child_node.children, new_child_node.children)):\n            # Leaf text nodes\n            if prev_child and new_child:\n                if prev_child.is_text_node and new_child.is_text_node and (prev_child.text != new_child.text):\n                    differences.append([\n                        self.hyd_comp_get_keyed_uuid(\n                            id=id,\n                            key=prev_child_path\n                        ),\n                        new_child_node,\n                        prev_child_path,\n                        self.updater_context_builder(\n                            name=NODE_INNER_TEXT,\n                            context={\"text\": new_child.text}\n                        )\n                    ])\n                    continue\n\n            new_child_path = new_child.path if isinstance(new_child, Node) else \"\"\n            prev_child_path = prev_child.path if isinstance(prev_child, Node) else \"\"\n            helper(prev_child, new_child, id, prev_child_path=prev_child_path, new_child_path=new_child_path)\n\n    helper(prevNode, newNode, id, 0, 0)\n    return differences\n</code></pre>"},{"location":"api/client/algorithm/searcher/#zenaura.client.algorithm.searcher.Searcher.updater_context_builder","title":"<code>updater_context_builder(name, context)</code>","text":"<p>Builds the context for the updater.</p> <p>This method takes the name of the operation and its context and returns a dictionary that will be used by the updater.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the operation.</p> required <code>context</code> <code>dict</code> <p>The context of the operation.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the name and context of the operation.</p> Source code in <code>zenaura\\client\\algorithm\\searcher.py</code> <pre><code>def updater_context_builder(self, name: str, context: dict) -&gt; dict:\n    \"\"\"\n    Builds the context for the updater.\n\n    This method takes the name of the operation and its context and returns a dictionary that will be used by the updater.\n\n    Args:\n        name: The name of the operation.\n        context: The context of the operation.\n\n    Returns:\n        A dictionary containing the name and context of the operation.\n    \"\"\"\n\n    return {\n        \"name\": name,\n        \"context\": context\n    }\n</code></pre>"},{"location":"api/client/algorithm/updater/","title":"Updater","text":""},{"location":"api/client/algorithm/updater/#zenaura.client.algorithm.updater.Updater","title":"<code>Updater</code>","text":"<p>             Bases: <code>Hydrator</code></p> <p>This class is responsible for updating the real DOM based on the differences identified by the Searcher.</p> <p>It receives a list of patches from the Searcher and creates corresponding tasks for each patch. These tasks are then enqueued for execution by the Hydrator's tasker.</p> Source code in <code>zenaura\\client\\algorithm\\updater.py</code> <pre><code>class Updater(\n    Hydrator\n    ):\n    \"\"\"\n    This class is responsible for updating the real DOM based on the differences identified by the Searcher.\n\n    It receives a list of patches from the Searcher and creates corresponding tasks for each patch. These tasks are then enqueued for execution by the Hydrator's tasker.\n\n    Attributes:\n        None\n    \"\"\"\n\n    async def update(self, patches: List, id: str) -&gt; None:\n        \"\"\"\n        Updates the real DOM based on the provided patches.\n\n        Args:\n            patches: A list of patches containing the operation name, the new child node, the path of the child, and the context for the updater.\n            id: The ID of the component to be updated.\n        \"\"\"\n\n        while patches:\n            prev_node_id, diffed_node, path, op = patches.pop(0)\n            # print(\"operation\", op, prev_node_id)\n\n            if op[\"name\"] == ADD_NODE:\n                async def task(dn=diffed_node, ci=id):\n                    \"\"\"\n                    Adds a new node to the real DOM.\n\n                    Args:\n                        dn: The new child node to be added.\n                        ci: The ID of the component to which the node should be added.\n                    \"\"\"\n                    compiled_html = self.hyd_comp_compile_children(dn, ci, True)\n                    parent_id = id + dn.path[0:-2]  # last two digit in keyed uid is always level, index, so parent lives at the before\n                    child_id = id + dn.path\n                    self.hyd_rdom_append_child_after(parent_id, child_id, compiled_html)\n                self.hyd_tsk_enqueue_task(id, task)\n\n            if op[\"name\"] == REMOVE_NODE:\n                async def task(d=diffed_node, c=prev_node_id):\n                    \"\"\"\n                    Removes a node from the real DOM.\n\n                    Args:\n                        d: The node to be removed.\n                        c: The ID of the component containing the node.\n                    \"\"\"\n                    compiled_html = self.hyd_comp_compile_children(d, c, True)\n                    # print(\"ADD_NODE compiled html\", compiled_html)\n                    self.hyd_rdom_remove_child(prev_node_id)\n                self.hyd_tsk_enqueue_task(id, task)\n\n            if op[\"name\"] == NODE_INNER_TEXT:\n                # avoid late binding\n                async def task(id=prev_node_id, c=op[\"context\"][\"text\"]):\n                    \"\"\"\n                    Updates the inner text of a node in the real DOM.\n\n                    Args:\n                        id: The ID of the node to be updated.\n                        c: The new inner text.\n                    \"\"\"\n                    self.hyd_rdom_replace_inner_text(id, c)\n                self.hyd_tsk_enqueue_task(id, task)\n\n            if op[\"name\"] == ADD_ATTRIBUTE:\n                async def task(id=prev_node_id, op1=Attribute(op[\"context\"][\"attr_name\"], op[\"context\"][\"attr_value\"])):\n                    \"\"\"\n                    Adds an attribute to a node in the real DOM.\n\n                    Args:\n                        id: The ID of the node to be updated.\n                        op1: The attribute to be added.\n                    \"\"\"\n                    self.hyd_rdom_set_attribute(id, op1)\n                self.hyd_tsk_enqueue_task(id, task)\n\n            if op[\"name\"] == REMOVE_ATTRIBUTE:\n                async def task(id=prev_node_id, op1=op[\"context\"][\"attr_name\"]):\n                    \"\"\"\n                    Removes an attribute from a node in the real DOM.\n\n                    Args:\n                        id: The ID of the node to be updated.\n                        op1: The name of the attribute to be removed.\n                    \"\"\"\n                    self.hyd_rdom_remove_attribute(id, op1)\n                self.hyd_tsk_enqueue_task(id, task)\n\n            if op[\"name\"] == REPLACE_ATTRIBUTE:\n                async def task(id=prev_node_id, op1=op[\"context\"][\"attr_name\"]):\n                    \"\"\"\n                    Replaces an attribute on a node in the real DOM.\n\n                    Args:\n                        id: The ID of the node to be updated.\n                        op1: The name of the attribute to be replaced.\n                    \"\"\"\n                    self.hyd_rdom_remove_attribute(id, op1)\n                self.hyd_tsk_enqueue_task(id, task)\n</code></pre>"},{"location":"api/client/algorithm/updater/#zenaura.client.algorithm.updater.Updater.update","title":"<code>update(patches, id)</code>  <code>async</code>","text":"<p>Updates the real DOM based on the provided patches.</p> <p>Parameters:</p> Name Type Description Default <code>patches</code> <code>List</code> <p>A list of patches containing the operation name, the new child node, the path of the child, and the context for the updater.</p> required <code>id</code> <code>str</code> <p>The ID of the component to be updated.</p> required Source code in <code>zenaura\\client\\algorithm\\updater.py</code> <pre><code>async def update(self, patches: List, id: str) -&gt; None:\n    \"\"\"\n    Updates the real DOM based on the provided patches.\n\n    Args:\n        patches: A list of patches containing the operation name, the new child node, the path of the child, and the context for the updater.\n        id: The ID of the component to be updated.\n    \"\"\"\n\n    while patches:\n        prev_node_id, diffed_node, path, op = patches.pop(0)\n        # print(\"operation\", op, prev_node_id)\n\n        if op[\"name\"] == ADD_NODE:\n            async def task(dn=diffed_node, ci=id):\n                \"\"\"\n                Adds a new node to the real DOM.\n\n                Args:\n                    dn: The new child node to be added.\n                    ci: The ID of the component to which the node should be added.\n                \"\"\"\n                compiled_html = self.hyd_comp_compile_children(dn, ci, True)\n                parent_id = id + dn.path[0:-2]  # last two digit in keyed uid is always level, index, so parent lives at the before\n                child_id = id + dn.path\n                self.hyd_rdom_append_child_after(parent_id, child_id, compiled_html)\n            self.hyd_tsk_enqueue_task(id, task)\n\n        if op[\"name\"] == REMOVE_NODE:\n            async def task(d=diffed_node, c=prev_node_id):\n                \"\"\"\n                Removes a node from the real DOM.\n\n                Args:\n                    d: The node to be removed.\n                    c: The ID of the component containing the node.\n                \"\"\"\n                compiled_html = self.hyd_comp_compile_children(d, c, True)\n                # print(\"ADD_NODE compiled html\", compiled_html)\n                self.hyd_rdom_remove_child(prev_node_id)\n            self.hyd_tsk_enqueue_task(id, task)\n\n        if op[\"name\"] == NODE_INNER_TEXT:\n            # avoid late binding\n            async def task(id=prev_node_id, c=op[\"context\"][\"text\"]):\n                \"\"\"\n                Updates the inner text of a node in the real DOM.\n\n                Args:\n                    id: The ID of the node to be updated.\n                    c: The new inner text.\n                \"\"\"\n                self.hyd_rdom_replace_inner_text(id, c)\n            self.hyd_tsk_enqueue_task(id, task)\n\n        if op[\"name\"] == ADD_ATTRIBUTE:\n            async def task(id=prev_node_id, op1=Attribute(op[\"context\"][\"attr_name\"], op[\"context\"][\"attr_value\"])):\n                \"\"\"\n                Adds an attribute to a node in the real DOM.\n\n                Args:\n                    id: The ID of the node to be updated.\n                    op1: The attribute to be added.\n                \"\"\"\n                self.hyd_rdom_set_attribute(id, op1)\n            self.hyd_tsk_enqueue_task(id, task)\n\n        if op[\"name\"] == REMOVE_ATTRIBUTE:\n            async def task(id=prev_node_id, op1=op[\"context\"][\"attr_name\"]):\n                \"\"\"\n                Removes an attribute from a node in the real DOM.\n\n                Args:\n                    id: The ID of the node to be updated.\n                    op1: The name of the attribute to be removed.\n                \"\"\"\n                self.hyd_rdom_remove_attribute(id, op1)\n            self.hyd_tsk_enqueue_task(id, task)\n\n        if op[\"name\"] == REPLACE_ATTRIBUTE:\n            async def task(id=prev_node_id, op1=op[\"context\"][\"attr_name\"]):\n                \"\"\"\n                Replaces an attribute on a node in the real DOM.\n\n                Args:\n                    id: The ID of the node to be updated.\n                    op1: The name of the attribute to be replaced.\n                \"\"\"\n                self.hyd_rdom_remove_attribute(id, op1)\n            self.hyd_tsk_enqueue_task(id, task)\n</code></pre>"},{"location":"api/client/compiler/attribute/","title":"Attribute","text":""},{"location":"api/client/compiler/attribute/#zenaura.client.compiler.attribute.AttributeProccessor","title":"<code>AttributeProccessor</code>","text":"<p>This class is responsible for processing a list of <code>Attribute</code> objects and converting them into HTML-formatted attributes.</p> Source code in <code>zenaura\\client\\compiler\\attribute.py</code> <pre><code>class AttributeProccessor(\n    ):\n    \"\"\"\n    This class is responsible for processing a list of `Attribute` objects and converting them into HTML-formatted attributes.\n\n    Attributes:\n        None\n    \"\"\"\n    def __init__(self):\n        self.attrKeyWords = {\n            \"styles\": \"class\",\n        }\n    def process_attributes(\n                self, \n                attrs: List[Attribute]\n                ) -&gt; str:\n        \"\"\"\n        Processes a list of `Attribute` objects, converting them to HTML-formatted attributes.\n\n        Args:\n            attrs (List[Attribute]): A list of `Attribute` objects representing the attributes to be processed.\n\n        Returns:\n            str: A string containing the HTML-formatted attributes, ready to be included in a tag.\n\n        Raises:\n            TypeError: If the input `attrs` is not a list.\n            ValueError: If any element in `attrs` is not an `Attribute` object.\n        \"\"\"\n\n        if not isinstance(attrs, list):\n            raise TypeError(\"`attrs` must be a list of Attribute objects.\")\n\n        for attr in attrs:\n            if not isinstance(attr, Attribute):\n                raise ValueError(\"Each element in `attrs` must be an Attribute object.\")\n\n        s = io.StringIO()  # Create a string buffer for building the output\n\n        for i, attr in enumerate(attrs):\n            attrKey = attr.key\n            attrValue = attr.value\n            if attrKey in self.attrKeyWords.keys():\n                attrKey = self.attrKeyWords[attrKey]  # Apply keyword mapping\n\n            # Add space only if it's not the first or last attribute\n            if i == 0 or i == len(attrs) - 1:\n                s.write(f' {attrKey}=\"{sanitizer.sanitize(attrValue)}\"')\n            else:\n                s.write(f'{attrKey}=\"{sanitizer.sanitize(attrValue)}\" ')\n\n        res = s.getvalue()\n        s.close()\n        return res\n</code></pre>"},{"location":"api/client/compiler/attribute/#zenaura.client.compiler.attribute.AttributeProccessor.process_attributes","title":"<code>process_attributes(attrs)</code>","text":"<p>Processes a list of <code>Attribute</code> objects, converting them to HTML-formatted attributes.</p> <p>Parameters:</p> Name Type Description Default <code>attrs</code> <code>List[Attribute]</code> <p>A list of <code>Attribute</code> objects representing the attributes to be processed.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string containing the HTML-formatted attributes, ready to be included in a tag.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the input <code>attrs</code> is not a list.</p> <code>ValueError</code> <p>If any element in <code>attrs</code> is not an <code>Attribute</code> object.</p> Source code in <code>zenaura\\client\\compiler\\attribute.py</code> <pre><code>def process_attributes(\n            self, \n            attrs: List[Attribute]\n            ) -&gt; str:\n    \"\"\"\n    Processes a list of `Attribute` objects, converting them to HTML-formatted attributes.\n\n    Args:\n        attrs (List[Attribute]): A list of `Attribute` objects representing the attributes to be processed.\n\n    Returns:\n        str: A string containing the HTML-formatted attributes, ready to be included in a tag.\n\n    Raises:\n        TypeError: If the input `attrs` is not a list.\n        ValueError: If any element in `attrs` is not an `Attribute` object.\n    \"\"\"\n\n    if not isinstance(attrs, list):\n        raise TypeError(\"`attrs` must be a list of Attribute objects.\")\n\n    for attr in attrs:\n        if not isinstance(attr, Attribute):\n            raise ValueError(\"Each element in `attrs` must be an Attribute object.\")\n\n    s = io.StringIO()  # Create a string buffer for building the output\n\n    for i, attr in enumerate(attrs):\n        attrKey = attr.key\n        attrValue = attr.value\n        if attrKey in self.attrKeyWords.keys():\n            attrKey = self.attrKeyWords[attrKey]  # Apply keyword mapping\n\n        # Add space only if it's not the first or last attribute\n        if i == 0 or i == len(attrs) - 1:\n            s.write(f' {attrKey}=\"{sanitizer.sanitize(attrValue)}\"')\n        else:\n            s.write(f'{attrKey}=\"{sanitizer.sanitize(attrValue)}\" ')\n\n    res = s.getvalue()\n    s.close()\n    return res\n</code></pre>"},{"location":"api/client/compiler/compiler/","title":"Compiler","text":""},{"location":"api/client/compiler/compiler/#zenaura.client.compiler.compiler.Compiler","title":"<code>Compiler</code>","text":"<p>             Bases: <code>CompilerSanitizer</code>, <code>AttributeProccessor</code></p> <p>Compiles Zenui Nodes into their corresponding HTML representation.</p> <p>This class provides methods for:</p> <ul> <li>Generating unique keyed UUIDs for each child within a component tree.</li> <li>Compiling Zenui Nodes into HTML strings.</li> <li>Sanitizing HTML content to prevent XSS vulnerabilities.</li> <li>Processing attributes for HTML elements.</li> </ul> <p>Attributes:</p> Name Type Description <code>attrKeyWords</code> <code>dict</code> <p>A dictionary mapping attribute keywords to their corresponding HTML attribute names.</p> Source code in <code>zenaura\\client\\compiler\\compiler.py</code> <pre><code>class Compiler(\n    CompilerSanitizer,\n    AttributeProccessor,\n):\n    \"\"\"\n    Compiles Zenui Nodes into their corresponding HTML representation.\n\n    This class provides methods for:\n\n    - Generating unique keyed UUIDs for each child within a component tree.\n    - Compiling Zenui Nodes into HTML strings.\n    - Sanitizing HTML content to prevent XSS vulnerabilities.\n    - Processing attributes for HTML elements.\n\n    Attributes:\n        attrKeyWords (dict): A dictionary mapping attribute keywords to their corresponding HTML attribute names.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the Compiler instance with the default attribute keyword mapping.\n\n        The default mapping includes:\n\n        - `styles`: maps to `class` in HTML.\n\n        You can customize this mapping by modifying the `attrKeyWords` attribute.\n        \"\"\"\n        self.attrKeyWords = {\n            \"styles\": \"class\",\n        }\n\n    def getKeyedUID(self, id, withAttribut=False, key=None):\n        \"\"\"\n        Generates a unique keyed UUID for a child element within a component tree.\n\n        This UUID is used to create a unique `ZENAURA_DOM_ATTRIBUTE` attribute for the element.\n\n        Args:\n            id (str): The unique ID of the parent component.\n            withAttribut (bool, optional): Whether to include the `ZENAURA_DOM_ATTRIBUTE` attribute. Defaults to False.\n            key (str or list, optional): The key or path of the child element. Defaults to None.\n\n        Returns:\n            str: The generated keyed UUID.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; compiler = Compiler()\n            &gt;&gt;&gt; compiler.getKeyedUID(\"my-component\", key=\"child1\")\n            'my-componentchild1'\n            &gt;&gt;&gt; compiler.getKeyedUID(\"my-component\", withAttribut=True, key=[0, 1])\n            ' ZENAURA_DOM_ATTRIBUTE=\"my-component01\"'\n            ```\n        \"\"\"\n        if isinstance(key, list):\n            key = \"\".join(str(i) for i in key)  # Convert list to string\n\n        if withAttribut:\n            return f' {ZENAURA_DOM_ATTRIBUTE}=\"{id}{key}\"'\n        return f\"{id}{key}\"\n\n    def compile(self, elm: Node, id=None, zenaura_dom_mode=False):\n        \"\"\"\n        Compiles a Zenui Node into its corresponding HTML representation.\n\n        Args:\n            elm (Node): The Zenui Node object to compile.\n            id (str, optional): The unique ID of the parent component. Used to generate keyed UUIDs.\n            zenaura_dom_mode (bool, optional): Whether to add the `ZENAURA_DOM_ATTRIBUTE` attribute to the compiled HTML. Defaults to False.\n\n        Returns:\n            str: The compiled HTML string.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; compiler = Compiler()\n            &gt;&gt;&gt; node = Node(\"div\", attributes=[Attribute(\"class\", \"my-class\")], children=[Node(\"p\", text=\"Hello, world!\")])\n            &gt;&gt;&gt; compiler.compile(node)\n            '&lt;div class=\"my-class\"&gt;&lt;p&gt;Hello, world!&lt;/p&gt;&lt;/div&gt;'\n            &gt;&gt;&gt; compiler.compile(node, zenaura_dom_mode=True)\n            '&lt;div class=\"my-class\" ZENAURA_DOM_ATTRIBUTE=\"div0\"&gt; &lt;p ZENAURA_DOM_ATTRIBUTE=\"div00\"&gt;Hello, world!&lt;/p&gt;&lt;/div&gt;'\n            ```\n        \"\"\"\n        if elm.is_text_node or isinstance(elm, str):\n            return self.sanitize(elm.text)\n\n        tag = elm.name\n\n        zenui_id = \"\"\n\n        # Assign unique ID for Zenui DOM\n        if isinstance(elm, Node) and zenaura_dom_mode:\n            zenui_id = self.getKeyedUID(id, withAttribut=True, key=elm.path)\n\n        # Get node attributes\n        attributes = self.process_attributes(elm.attributes)\n\n        if tag in self_closing_tags:\n            return f\"&lt;{tag}{zenui_id}{attributes}&gt;\"\n\n        # Start tag\n        html = io.StringIO()\n        html.write(f\"&lt;{tag}{zenui_id}{attributes}&gt;\")\n\n        # Get children\n        for child in elm.children:\n            html.write(self.compile(child, id, zenaura_dom_mode))\n\n        # Finish tag\n        html.write(f\"&lt;/{tag}&gt;\")\n\n        return html.getvalue()\n</code></pre>"},{"location":"api/client/compiler/compiler/#zenaura.client.compiler.compiler.Compiler.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the Compiler instance with the default attribute keyword mapping.</p> <p>The default mapping includes:</p> <ul> <li><code>styles</code>: maps to <code>class</code> in HTML.</li> </ul> <p>You can customize this mapping by modifying the <code>attrKeyWords</code> attribute.</p> Source code in <code>zenaura\\client\\compiler\\compiler.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the Compiler instance with the default attribute keyword mapping.\n\n    The default mapping includes:\n\n    - `styles`: maps to `class` in HTML.\n\n    You can customize this mapping by modifying the `attrKeyWords` attribute.\n    \"\"\"\n    self.attrKeyWords = {\n        \"styles\": \"class\",\n    }\n</code></pre>"},{"location":"api/client/compiler/compiler/#zenaura.client.compiler.compiler.Compiler.compile","title":"<code>compile(elm, id=None, zenaura_dom_mode=False)</code>","text":"<p>Compiles a Zenui Node into its corresponding HTML representation.</p> <p>Parameters:</p> Name Type Description Default <code>elm</code> <code>Node</code> <p>The Zenui Node object to compile.</p> required <code>id</code> <code>str</code> <p>The unique ID of the parent component. Used to generate keyed UUIDs.</p> <code>None</code> <code>zenaura_dom_mode</code> <code>bool</code> <p>Whether to add the <code>ZENAURA_DOM_ATTRIBUTE</code> attribute to the compiled HTML. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <p>The compiled HTML string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; compiler = Compiler()\n&gt;&gt;&gt; node = Node(\"div\", attributes=[Attribute(\"class\", \"my-class\")], children=[Node(\"p\", text=\"Hello, world!\")])\n&gt;&gt;&gt; compiler.compile(node)\n'&lt;div class=\"my-class\"&gt;&lt;p&gt;Hello, world!&lt;/p&gt;&lt;/div&gt;'\n&gt;&gt;&gt; compiler.compile(node, zenaura_dom_mode=True)\n'&lt;div class=\"my-class\" ZENAURA_DOM_ATTRIBUTE=\"div0\"&gt; &lt;p ZENAURA_DOM_ATTRIBUTE=\"div00\"&gt;Hello, world!&lt;/p&gt;&lt;/div&gt;'\n</code></pre> Source code in <code>zenaura\\client\\compiler\\compiler.py</code> <pre><code>def compile(self, elm: Node, id=None, zenaura_dom_mode=False):\n    \"\"\"\n    Compiles a Zenui Node into its corresponding HTML representation.\n\n    Args:\n        elm (Node): The Zenui Node object to compile.\n        id (str, optional): The unique ID of the parent component. Used to generate keyed UUIDs.\n        zenaura_dom_mode (bool, optional): Whether to add the `ZENAURA_DOM_ATTRIBUTE` attribute to the compiled HTML. Defaults to False.\n\n    Returns:\n        str: The compiled HTML string.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; compiler = Compiler()\n        &gt;&gt;&gt; node = Node(\"div\", attributes=[Attribute(\"class\", \"my-class\")], children=[Node(\"p\", text=\"Hello, world!\")])\n        &gt;&gt;&gt; compiler.compile(node)\n        '&lt;div class=\"my-class\"&gt;&lt;p&gt;Hello, world!&lt;/p&gt;&lt;/div&gt;'\n        &gt;&gt;&gt; compiler.compile(node, zenaura_dom_mode=True)\n        '&lt;div class=\"my-class\" ZENAURA_DOM_ATTRIBUTE=\"div0\"&gt; &lt;p ZENAURA_DOM_ATTRIBUTE=\"div00\"&gt;Hello, world!&lt;/p&gt;&lt;/div&gt;'\n        ```\n    \"\"\"\n    if elm.is_text_node or isinstance(elm, str):\n        return self.sanitize(elm.text)\n\n    tag = elm.name\n\n    zenui_id = \"\"\n\n    # Assign unique ID for Zenui DOM\n    if isinstance(elm, Node) and zenaura_dom_mode:\n        zenui_id = self.getKeyedUID(id, withAttribut=True, key=elm.path)\n\n    # Get node attributes\n    attributes = self.process_attributes(elm.attributes)\n\n    if tag in self_closing_tags:\n        return f\"&lt;{tag}{zenui_id}{attributes}&gt;\"\n\n    # Start tag\n    html = io.StringIO()\n    html.write(f\"&lt;{tag}{zenui_id}{attributes}&gt;\")\n\n    # Get children\n    for child in elm.children:\n        html.write(self.compile(child, id, zenaura_dom_mode))\n\n    # Finish tag\n    html.write(f\"&lt;/{tag}&gt;\")\n\n    return html.getvalue()\n</code></pre>"},{"location":"api/client/compiler/compiler/#zenaura.client.compiler.compiler.Compiler.getKeyedUID","title":"<code>getKeyedUID(id, withAttribut=False, key=None)</code>","text":"<p>Generates a unique keyed UUID for a child element within a component tree.</p> <p>This UUID is used to create a unique <code>ZENAURA_DOM_ATTRIBUTE</code> attribute for the element.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The unique ID of the parent component.</p> required <code>withAttribut</code> <code>bool</code> <p>Whether to include the <code>ZENAURA_DOM_ATTRIBUTE</code> attribute. Defaults to False.</p> <code>False</code> <code>key</code> <code>str or list</code> <p>The key or path of the child element. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <p>The generated keyed UUID.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; compiler = Compiler()\n&gt;&gt;&gt; compiler.getKeyedUID(\"my-component\", key=\"child1\")\n'my-componentchild1'\n&gt;&gt;&gt; compiler.getKeyedUID(\"my-component\", withAttribut=True, key=[0, 1])\n' ZENAURA_DOM_ATTRIBUTE=\"my-component01\"'\n</code></pre> Source code in <code>zenaura\\client\\compiler\\compiler.py</code> <pre><code>def getKeyedUID(self, id, withAttribut=False, key=None):\n    \"\"\"\n    Generates a unique keyed UUID for a child element within a component tree.\n\n    This UUID is used to create a unique `ZENAURA_DOM_ATTRIBUTE` attribute for the element.\n\n    Args:\n        id (str): The unique ID of the parent component.\n        withAttribut (bool, optional): Whether to include the `ZENAURA_DOM_ATTRIBUTE` attribute. Defaults to False.\n        key (str or list, optional): The key or path of the child element. Defaults to None.\n\n    Returns:\n        str: The generated keyed UUID.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; compiler = Compiler()\n        &gt;&gt;&gt; compiler.getKeyedUID(\"my-component\", key=\"child1\")\n        'my-componentchild1'\n        &gt;&gt;&gt; compiler.getKeyedUID(\"my-component\", withAttribut=True, key=[0, 1])\n        ' ZENAURA_DOM_ATTRIBUTE=\"my-component01\"'\n        ```\n    \"\"\"\n    if isinstance(key, list):\n        key = \"\".join(str(i) for i in key)  # Convert list to string\n\n    if withAttribut:\n        return f' {ZENAURA_DOM_ATTRIBUTE}=\"{id}{key}\"'\n    return f\"{id}{key}\"\n</code></pre>"},{"location":"api/client/compiler/sanitize/","title":"Sanitize","text":""},{"location":"api/client/compiler/sanitize/#zenaura.client.compiler.sanitize.CompilerSanitizer","title":"<code>CompilerSanitizer</code>","text":"<p>This class provides methods for sanitizing user input to prevent various injection attacks.</p> <p>It uses the <code>bleach</code> library to remove potentially harmful HTML tags and attributes,  and the <code>html</code> library to escape special characters.</p> Source code in <code>zenaura\\client\\compiler\\sanitize.py</code> <pre><code>class CompilerSanitizer:\n    \"\"\"\n    This class provides methods for sanitizing user input to prevent various injection attacks.\n\n    It uses the `bleach` library to remove potentially harmful HTML tags and attributes, \n    and the `html` library to escape special characters.\n\n    Attributes:\n        None\n    \"\"\"\n\n    def sanitize(\n        self, \n        user_input: str, \n        allowed_tags: list = allowed_tags, \n        allowed_attributes: dict = allowed_attributes\n    ) -&gt; str:\n        \"\"\"\n        Sanitizes user input to prevent various injection attacks.\n\n        This method takes the raw user input as a string and returns a sanitized version of the input.\n\n        Args:\n            user_input (str): The raw user input to sanitize.\n            allowed_tags (list, optional): A list of allowed HTML tags (e.g., ['p', 'br', 'strong']). \n                Defaults to `allowed_tags` from the `zenaura.client.config` module.\n            allowed_attributes (dict, optional): A dictionary mapping allowed tags to their allowed \n                attributes (e.g., {'img': ['src', 'alt']}). Defaults to `allowed_attributes` from the \n                `zenaura.client.config` module.\n\n        Returns:\n            str: The sanitized input.\n        \"\"\"\n\n        # Convert user input to string for safety\n        user_input = str(user_input)\n\n        # Escape all HTML special characters initially\n        safe_html = html.escape(user_input)\n\n        # Use bleach to remove potentially harmful HTML tags and attributes\n        safe_html = bleach.clean(\n            safe_html, tags=allowed_tags, attributes=allowed_attributes\n        )\n\n        return safe_html\n</code></pre>"},{"location":"api/client/compiler/sanitize/#zenaura.client.compiler.sanitize.CompilerSanitizer.sanitize","title":"<code>sanitize(user_input, allowed_tags=allowed_tags, allowed_attributes=allowed_attributes)</code>","text":"<p>Sanitizes user input to prevent various injection attacks.</p> <p>This method takes the raw user input as a string and returns a sanitized version of the input.</p> <p>Parameters:</p> Name Type Description Default <code>user_input</code> <code>str</code> <p>The raw user input to sanitize.</p> required <code>allowed_tags</code> <code>list</code> <p>A list of allowed HTML tags (e.g., ['p', 'br', 'strong']).  Defaults to <code>allowed_tags</code> from the <code>zenaura.client.config</code> module.</p> <code>allowed_tags</code> <code>allowed_attributes</code> <code>dict</code> <p>A dictionary mapping allowed tags to their allowed  attributes (e.g., {'img': ['src', 'alt']}). Defaults to <code>allowed_attributes</code> from the  <code>zenaura.client.config</code> module.</p> <code>allowed_attributes</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The sanitized input.</p> Source code in <code>zenaura\\client\\compiler\\sanitize.py</code> <pre><code>def sanitize(\n    self, \n    user_input: str, \n    allowed_tags: list = allowed_tags, \n    allowed_attributes: dict = allowed_attributes\n) -&gt; str:\n    \"\"\"\n    Sanitizes user input to prevent various injection attacks.\n\n    This method takes the raw user input as a string and returns a sanitized version of the input.\n\n    Args:\n        user_input (str): The raw user input to sanitize.\n        allowed_tags (list, optional): A list of allowed HTML tags (e.g., ['p', 'br', 'strong']). \n            Defaults to `allowed_tags` from the `zenaura.client.config` module.\n        allowed_attributes (dict, optional): A dictionary mapping allowed tags to their allowed \n            attributes (e.g., {'img': ['src', 'alt']}). Defaults to `allowed_attributes` from the \n            `zenaura.client.config` module.\n\n    Returns:\n        str: The sanitized input.\n    \"\"\"\n\n    # Convert user input to string for safety\n    user_input = str(user_input)\n\n    # Escape all HTML special characters initially\n    safe_html = html.escape(user_input)\n\n    # Use bleach to remove potentially harmful HTML tags and attributes\n    safe_html = bleach.clean(\n        safe_html, tags=allowed_tags, attributes=allowed_attributes\n    )\n\n    return safe_html\n</code></pre>"},{"location":"api/client/dom/dom/","title":"Dom","text":""},{"location":"api/client/dom/dom/#zenaura.client.dom.dom.Dom","title":"<code>Dom</code>","text":"<p>             Bases: <code>Mount</code>, <code>Render</code></p> <p>Zenaura virtual DOM.</p> <p>This class combines the functionalities of <code>Mount</code> and <code>Render</code> classes to provide a comprehensive virtual DOM implementation.</p> <p>Attributes:</p> <ul> <li>Mount: Inherits all attributes and methods from the <code>Mount</code> class, which handles the mounting lifecycle of components.</li> <li>Render: Inherits all attributes and methods from the <code>Render</code> class, which handles the rendering lifecycle of components.</li> </ul> <p>Methods:</p> <ul> <li>mount(comp, container): Mounts the component to the specified container element in the real DOM.</li> <li>render(comp): Renders the component to a virtual DOM tree.</li> <li>update(prev_comp, new_comp): Updates the real DOM based on the differences between the previous and new virtual DOM trees.</li> </ul> <p>Usage:</p> <pre><code># Create a Dom instance\ndom = Dom()\n\n# Create a component\ncomp = MyComponent()\n\n# Mount the component to a container element\ndom.mount(comp, container)\n\n# Render the component\ndom.render(comp)\n\n# Update the component\ndom.update(prev_comp, new_comp)\n</code></pre> Source code in <code>zenaura\\client\\dom\\dom.py</code> <pre><code>class Dom(\n    Mount,\n    Render\n):\n    \"\"\"\n    Zenaura virtual DOM.\n\n    This class combines the functionalities of `Mount` and `Render` classes to provide a comprehensive virtual DOM implementation.\n\n    **Attributes:**\n\n    * **Mount:** Inherits all attributes and methods from the `Mount` class, which handles the mounting lifecycle of components.\n    * **Render:** Inherits all attributes and methods from the `Render` class, which handles the rendering lifecycle of components.\n\n    **Methods:**\n\n    * **mount(comp, container):** Mounts the component to the specified container element in the real DOM.\n    * **render(comp):** Renders the component to a virtual DOM tree.\n    * **update(prev_comp, new_comp):** Updates the real DOM based on the differences between the previous and new virtual DOM trees.\n\n    **Usage:**\n\n    ```python\n    # Create a Dom instance\n    dom = Dom()\n\n    # Create a component\n    comp = MyComponent()\n\n    # Mount the component to a container element\n    dom.mount(comp, container)\n\n    # Render the component\n    dom.render(comp)\n\n    # Update the component\n    dom.update(prev_comp, new_comp)\n    ```\n    \"\"\"\n</code></pre>"},{"location":"api/client/dom/error/","title":"Error","text":""},{"location":"api/client/dom/error/#zenaura.client.dom.error.DefaultDomErrorComponent","title":"<code>DefaultDomErrorComponent</code>","text":"<p>             Bases: <code>Component</code></p> <p>Displays a default error message component.</p> <p>Attributes:</p> Name Type Description <code>error_message</code> <code>str</code> <p>The error message to display.</p> <p>Methods:</p> Name Description <code>render</code> <p>Returns a Node representing the error message.</p> Source code in <code>zenaura\\client\\dom\\error.py</code> <pre><code>@Reuseable\nclass DefaultDomErrorComponent(Component):\n    \"\"\"\n    Displays a default error message component.\n\n    Attributes:\n        error_message (str): The error message to display.\n\n    Methods:\n        render(): Returns a Node representing the error message.\n    \"\"\"\n\n    def __init__(self, error_message):\n        super().__init__()\n        self.error_message = error_message\n\n    def render(self):\n        return Node(\"div\", children=[Node(text=str(self.error_message))])\n</code></pre>"},{"location":"api/client/dom/error/#zenaura.client.dom.error.GracefulDegenerationLifeCycleWrapper","title":"<code>GracefulDegenerationLifeCycleWrapper</code>","text":"<p>             Bases: <code>Hydrator</code></p> <p>Wraps components to handle errors gracefully.</p> <p>This class provides a <code>on_error</code> method that allows components to handle errors gracefully. If a component throws an error, the <code>on_error</code> method will be called with the error message. The component can then return a new component to display in place of the original component.</p> <p>If the component does not have a <code>on_error</code> method, a default error message component will be displayed.</p> Source code in <code>zenaura\\client\\dom\\error.py</code> <pre><code>class GracefulDegenerationLifeCycleWrapper(\n    Hydrator\n):\n    \"\"\"\n    Wraps components to handle errors gracefully.\n\n    This class provides a `on_error` method that allows components\n    to handle errors gracefully. If a component throws an error, the\n    `on_error` method will be called with the error message. The\n    component can then return a new component to display in place of the original\n    component.\n\n    If the component does not have a `on_error` method, a default\n    error message component will be displayed.\n    \"\"\"\n\n    def on_error(self, comp, error) -&gt; None:\n        \"\"\"\n        Handles errors gracefully.\n\n        This method is called when a component throws an error. It allows the\n        component to handle the error gracefully by returning a new component to\n        display in place of the original component.\n\n        Args:\n            comp (Component): The component that threw the error.\n            error (Exception): The error that was thrown.\n        \"\"\"\n\n        # Cleanup the Zen DOM table.\n        self.zen_dom_table.clear()\n\n        if hasattr(comp, \"on_error\"):\n            # Call the component's `on_error` method.\n            error_comp = comp.on_error(str(error))\n\n            # Compile and render the error component.\n            compiled_comp = self.hyd_comp_compile_render(error_comp)\n\n            # Attach the compiled component to the real DOM.\n            self.hyd_rdom_attach_to_root(compiled_comp)\n\n            # Update the virtual DOM with the new render.\n            self.hyd_vdom_update_with_new_render(comp, error_comp.render())\n\n        else:\n            # Create a default error message component.\n            error_comp = DefaultDomErrorComponent(error_message=str(error))\n\n            # Compile and render the default error component.\n            compiled_comp = self.hyd_comp_compile_render(error_comp)\n\n            # Attach the compiled component to the real DOM.\n            self.hyd_rdom_attach_to_root(compiled_comp)\n\n            # Update the virtual DOM with the new render.\n            self.hyd_vdom_update_with_new_render(comp, error_comp.render())\n</code></pre>"},{"location":"api/client/dom/error/#zenaura.client.dom.error.GracefulDegenerationLifeCycleWrapper.on_error","title":"<code>on_error(comp, error)</code>","text":"<p>Handles errors gracefully.</p> <p>This method is called when a component throws an error. It allows the component to handle the error gracefully by returning a new component to display in place of the original component.</p> <p>Parameters:</p> Name Type Description Default <code>comp</code> <code>Component</code> <p>The component that threw the error.</p> required <code>error</code> <code>Exception</code> <p>The error that was thrown.</p> required Source code in <code>zenaura\\client\\dom\\error.py</code> <pre><code>def on_error(self, comp, error) -&gt; None:\n    \"\"\"\n    Handles errors gracefully.\n\n    This method is called when a component throws an error. It allows the\n    component to handle the error gracefully by returning a new component to\n    display in place of the original component.\n\n    Args:\n        comp (Component): The component that threw the error.\n        error (Exception): The error that was thrown.\n    \"\"\"\n\n    # Cleanup the Zen DOM table.\n    self.zen_dom_table.clear()\n\n    if hasattr(comp, \"on_error\"):\n        # Call the component's `on_error` method.\n        error_comp = comp.on_error(str(error))\n\n        # Compile and render the error component.\n        compiled_comp = self.hyd_comp_compile_render(error_comp)\n\n        # Attach the compiled component to the real DOM.\n        self.hyd_rdom_attach_to_root(compiled_comp)\n\n        # Update the virtual DOM with the new render.\n        self.hyd_vdom_update_with_new_render(comp, error_comp.render())\n\n    else:\n        # Create a default error message component.\n        error_comp = DefaultDomErrorComponent(error_message=str(error))\n\n        # Compile and render the default error component.\n        compiled_comp = self.hyd_comp_compile_render(error_comp)\n\n        # Attach the compiled component to the real DOM.\n        self.hyd_rdom_attach_to_root(compiled_comp)\n\n        # Update the virtual DOM with the new render.\n        self.hyd_vdom_update_with_new_render(comp, error_comp.render())\n</code></pre>"},{"location":"api/client/dom/lifecycles/","title":"Lifecycles","text":""},{"location":"api/client/dom/lifecycles/#zenaura.client.dom.lifecycles.mount.MountLifeCycles","title":"<code>MountLifeCycles</code>","text":"<p>             Bases: <code>HydratorVirtualDomAdapter</code></p> <p>This class provides lifecycle methods for components that are mounted to the DOM.</p> <p>It inherits from the <code>HydratorVirtualDomAdapter</code> class, which provides methods for interacting with the virtual DOM.</p> Source code in <code>zenaura\\client\\dom\\lifecycles\\mount.py</code> <pre><code>class MountLifeCycles(\n    HydratorVirtualDomAdapter\n):\n    \"\"\"\n    This class provides lifecycle methods for components that are mounted to the DOM.\n\n    It inherits from the `HydratorVirtualDomAdapter` class, which provides methods for interacting with the virtual DOM.\n    \"\"\"\n\n    async def attached(self, comp) -&gt; None:\n        \"\"\"\n        This method is called after the component is mounted to the DOM.\n\n        It allows the component to perform any necessary actions after it has been added to the DOM, such as:\n\n        - Initializing state\n        - Setting up event listeners\n        - Making API calls\n        - Performing animations\n\n        Args:\n            comp: An instance of the Component class.\n\n        Returns:\n            None\n        \"\"\"\n\n        if hasattr(comp, 'attached'):\n            await comp.attached()\n</code></pre>"},{"location":"api/client/dom/lifecycles/#zenaura.client.dom.lifecycles.mount.MountLifeCycles.attached","title":"<code>attached(comp)</code>  <code>async</code>","text":"<p>This method is called after the component is mounted to the DOM.</p> <p>It allows the component to perform any necessary actions after it has been added to the DOM, such as:</p> <ul> <li>Initializing state</li> <li>Setting up event listeners</li> <li>Making API calls</li> <li>Performing animations</li> </ul> <p>Parameters:</p> Name Type Description Default <code>comp</code> <p>An instance of the Component class.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>zenaura\\client\\dom\\lifecycles\\mount.py</code> <pre><code>async def attached(self, comp) -&gt; None:\n    \"\"\"\n    This method is called after the component is mounted to the DOM.\n\n    It allows the component to perform any necessary actions after it has been added to the DOM, such as:\n\n    - Initializing state\n    - Setting up event listeners\n    - Making API calls\n    - Performing animations\n\n    Args:\n        comp: An instance of the Component class.\n\n    Returns:\n        None\n    \"\"\"\n\n    if hasattr(comp, 'attached'):\n        await comp.attached()\n</code></pre>"},{"location":"api/client/dom/lifecycles/#zenaura.client.dom.lifecycles.render.RenderLifeCycle","title":"<code>RenderLifeCycle</code>","text":"<p>This class provides lifecycle methods for components that are rendered to the DOM.</p> <p>It allows components to perform actions before and after they are updated and re-rendered in the DOM.</p> Source code in <code>zenaura\\client\\dom\\lifecycles\\render.py</code> <pre><code>class RenderLifeCycle:\n    \"\"\"\n    This class provides lifecycle methods for components that are rendered to the DOM.\n\n    It allows components to perform actions before and after they are updated and re-rendered in the DOM.\n\n    Attributes:\n        None\n    \"\"\"\n\n    async def on_mutation(self, comp) -&gt; None:\n        \"\"\"\n        This method is called after the component is updated in the DOM and re-rendered.\n\n        It allows the component to perform any necessary actions before the update is applied, such as:\n\n        - Updating state based on new props\n        - Setting up event listeners\n        - Making API calls\n        - Performing animations\n\n        Args:\n            comp: An instance of the Component class.\n\n        Returns:\n            None\n        \"\"\"\n\n        # Perform operations before updating\n        if hasattr(comp, 'on_mutation'):\n            await comp.on_mutation()\n\n    async def on_settled(self, comp) -&gt; None:\n        \"\"\"\n        This method is called after the component is updated in the DOM and re-rendered.\n\n        It allows the component to perform any necessary actions after the update is applied, such as:\n\n        - Focusing on an input element\n        - Scrolling to a specific position\n        - Triggering custom events\n\n        Args:\n            comp: An instance of the Component class.\n\n        Returns:\n            None\n        \"\"\"\n\n        # Perform operations after updating\n        if hasattr(comp, 'on_settled'):\n            await comp.on_settled()\n</code></pre>"},{"location":"api/client/dom/lifecycles/#zenaura.client.dom.lifecycles.render.RenderLifeCycle.on_mutation","title":"<code>on_mutation(comp)</code>  <code>async</code>","text":"<p>This method is called after the component is updated in the DOM and re-rendered.</p> <p>It allows the component to perform any necessary actions before the update is applied, such as:</p> <ul> <li>Updating state based on new props</li> <li>Setting up event listeners</li> <li>Making API calls</li> <li>Performing animations</li> </ul> <p>Parameters:</p> Name Type Description Default <code>comp</code> <p>An instance of the Component class.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>zenaura\\client\\dom\\lifecycles\\render.py</code> <pre><code>async def on_mutation(self, comp) -&gt; None:\n    \"\"\"\n    This method is called after the component is updated in the DOM and re-rendered.\n\n    It allows the component to perform any necessary actions before the update is applied, such as:\n\n    - Updating state based on new props\n    - Setting up event listeners\n    - Making API calls\n    - Performing animations\n\n    Args:\n        comp: An instance of the Component class.\n\n    Returns:\n        None\n    \"\"\"\n\n    # Perform operations before updating\n    if hasattr(comp, 'on_mutation'):\n        await comp.on_mutation()\n</code></pre>"},{"location":"api/client/dom/lifecycles/#zenaura.client.dom.lifecycles.render.RenderLifeCycle.on_settled","title":"<code>on_settled(comp)</code>  <code>async</code>","text":"<p>This method is called after the component is updated in the DOM and re-rendered.</p> <p>It allows the component to perform any necessary actions after the update is applied, such as:</p> <ul> <li>Focusing on an input element</li> <li>Scrolling to a specific position</li> <li>Triggering custom events</li> </ul> <p>Parameters:</p> Name Type Description Default <code>comp</code> <p>An instance of the Component class.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>zenaura\\client\\dom\\lifecycles\\render.py</code> <pre><code>async def on_settled(self, comp) -&gt; None:\n    \"\"\"\n    This method is called after the component is updated in the DOM and re-rendered.\n\n    It allows the component to perform any necessary actions after the update is applied, such as:\n\n    - Focusing on an input element\n    - Scrolling to a specific position\n    - Triggering custom events\n\n    Args:\n        comp: An instance of the Component class.\n\n    Returns:\n        None\n    \"\"\"\n\n    # Perform operations after updating\n    if hasattr(comp, 'on_settled'):\n        await comp.on_settled()\n</code></pre>"},{"location":"api/client/dom/mount/","title":"Mount","text":""},{"location":"api/client/dom/mount/#zenaura.client.dom.mount.Mount","title":"<code>Mount</code>","text":"<p>             Bases: <code>GracefulDegenerationLifeCycleWrapper</code>, <code>MountLifeCycles</code></p> <p>Mounts a single <code>Page</code> instance to the DOM.</p> <p>This class handles the mounting of a single <code>Page</code> instance to the DOM. It ensures that only one page is mounted at a time and provides lifecycle methods for handling the mounting process.</p> <p>Lifecycle:</p> <ol> <li>Server-side:<ul> <li>The server hydrates all app pages and overwrites the <code>index.html</code> file.</li> <li>The <code>App</code> class toggles the visibility of the mounted page.</li> </ul> </li> <li>Client-side:<ul> <li>The <code>Mount</code> class triggers the <code>attached</code> lifecycle method for the page components.</li> </ul> </li> </ol> <p>Error Handling:</p> <ul> <li>If an error occurs during mounting, the <code>on_error</code> method is called with the error message.</li> <li>This method allows components to handle errors gracefully by returning a new component to display in place of the original component.</li> <li>If the component does not have a <code>on_error</code> method, a default error message component is displayed.</li> </ul> <p>Parameters:</p> <ul> <li><code>page</code>: An instance of the <code>Page</code> class.</li> </ul> <p>Returns:</p> <p>None</p> Source code in <code>zenaura\\client\\dom\\mount.py</code> <pre><code>class Mount(\n    GracefulDegenerationLifeCycleWrapper,\n    MountLifeCycles,\n    ):\n    \"\"\"\n    Mounts a single `Page` instance to the DOM.\n\n    This class handles the mounting of a single `Page` instance to the DOM. It ensures that only one page is mounted at a time and provides lifecycle methods for handling the mounting process.\n\n    **Lifecycle:**\n\n    1. **Server-side:**\n        - The server hydrates all app pages and overwrites the `index.html` file.\n        - The `App` class toggles the visibility of the mounted page.\n    2. **Client-side:**\n        - The `Mount` class triggers the `attached` lifecycle method for the page components.\n\n    **Error Handling:**\n\n    - If an error occurs during mounting, the `on_error` method is called with the error message.\n    - This method allows components to handle errors gracefully by returning a new component to display in place of the original component.\n    - If the component does not have a `on_error` method, a default error message component is displayed.\n\n    **Parameters:**\n\n    - `page`: An instance of the `Page` class.\n\n    **Returns:**\n\n    None\n    \"\"\"\n\n    async def mount(self, page: Page) -&gt; None:\n        \"\"\"\n        Mounts the given `Page` instance to the DOM.\n\n        This method attempts to mount the provided `Page` instance to the DOM. It iterates through the page's children, updating their state in the virtual DOM and triggering the `attached` lifecycle method for each component.\n\n        **Error Handling:**\n\n        - If an error occurs during mounting, the `on_error` method is called with the error message.\n        - This method allows components to handle errors gracefully by returning a new component to display in place of the original component.\n        - If the component does not have a `on_error` method, a default error message component is displayed.\n\n        **Parameters:**\n\n        - `page`: An instance of the `Page` class.\n\n        **Returns:**\n\n        None\n        \"\"\"\n\n        try:\n            for comp in page.children:\n                # Update state in vdom\n                self.hyd_vdom_update(comp)\n                # Trigger attached for page components\n                await self.attached(comp)\n\n        except Exception as e:\n            self.on_error(page.children[0], traceback.format_exc())\n</code></pre>"},{"location":"api/client/dom/mount/#zenaura.client.dom.mount.Mount.mount","title":"<code>mount(page)</code>  <code>async</code>","text":"<p>Mounts the given <code>Page</code> instance to the DOM.</p> <p>This method attempts to mount the provided <code>Page</code> instance to the DOM. It iterates through the page's children, updating their state in the virtual DOM and triggering the <code>attached</code> lifecycle method for each component.</p> <p>Error Handling:</p> <ul> <li>If an error occurs during mounting, the <code>on_error</code> method is called with the error message.</li> <li>This method allows components to handle errors gracefully by returning a new component to display in place of the original component.</li> <li>If the component does not have a <code>on_error</code> method, a default error message component is displayed.</li> </ul> <p>Parameters:</p> <ul> <li><code>page</code>: An instance of the <code>Page</code> class.</li> </ul> <p>Returns:</p> <p>None</p> Source code in <code>zenaura\\client\\dom\\mount.py</code> <pre><code>async def mount(self, page: Page) -&gt; None:\n    \"\"\"\n    Mounts the given `Page` instance to the DOM.\n\n    This method attempts to mount the provided `Page` instance to the DOM. It iterates through the page's children, updating their state in the virtual DOM and triggering the `attached` lifecycle method for each component.\n\n    **Error Handling:**\n\n    - If an error occurs during mounting, the `on_error` method is called with the error message.\n    - This method allows components to handle errors gracefully by returning a new component to display in place of the original component.\n    - If the component does not have a `on_error` method, a default error message component is displayed.\n\n    **Parameters:**\n\n    - `page`: An instance of the `Page` class.\n\n    **Returns:**\n\n    None\n    \"\"\"\n\n    try:\n        for comp in page.children:\n            # Update state in vdom\n            self.hyd_vdom_update(comp)\n            # Trigger attached for page components\n            await self.attached(comp)\n\n    except Exception as e:\n        self.on_error(page.children[0], traceback.format_exc())\n</code></pre>"},{"location":"api/client/dom/render/","title":"Render","text":""},{"location":"api/client/dom/render/#zenaura.client.dom.render.Render","title":"<code>Render</code>","text":"<p>             Bases: <code>GracefulDegenerationLifeCycleWrapper</code>, <code>RenderLifeCycle</code>, <code>DiffingAlgorithm</code>, <code>HydratorTasker</code></p> <p>Renders components by updating the DOM based on the differences between the previous and new component trees.</p> <p>This class provides methods for:</p> <ul> <li>Lifecycle: Calling lifecycle methods for components during rendering.</li> <li>Diffing: Calculating the differences between the previous and new component trees.</li> <li>Updating: Applying the calculated differences to the DOM.</li> <li>Scheduling: Scheduling updates with the browser.</li> <li>Virtual DOM Update: Updating the virtual DOM with the new component tree.</li> <li>Error Handling: Handling errors gracefully and displaying an error message component.</li> </ul> <p>Attributes:</p> <ul> <li><code>zen_dom_table</code>: A dictionary that stores the virtual DOM for each component.</li> <li><code>hyd_tsk_task_queues</code>: A dictionary that stores task queues for each component.</li> </ul> <p>Methods:</p> <ul> <li><code>render(comp)</code>: Renders the given component by updating the DOM.</li> <li><code>on_mutation(comp)</code>: Calls the <code>on_mutation</code> lifecycle method for the component.</li> <li><code>on_settled(comp)</code>: Calls the <code>on_settled</code> lifecycle method for the component.</li> <li><code>search(prev_tree, new_tree, comp_id)</code>: Calculates the differences between the previous and new component trees.</li> <li><code>update(patches, comp_id)</code>: Applies the calculated differences to the DOM.</li> <li><code>hyd_vdom_update(comp)</code>: Updates the virtual DOM with the new component tree.</li> <li><code>on_error(comp, error)</code>: Handles errors gracefully and displays an error message component.</li> </ul> Source code in <code>zenaura\\client\\dom\\render.py</code> <pre><code>class Render(\n    GracefulDegenerationLifeCycleWrapper,\n    RenderLifeCycle, \n    DiffingAlgorithm,\n    HydratorTasker\n):\n    \"\"\"\n    Renders components by updating the DOM based on the differences between the previous and new component trees.\n\n    This class provides methods for:\n\n    - **Lifecycle:** Calling lifecycle methods for components during rendering.\n    - **Diffing:** Calculating the differences between the previous and new component trees.\n    - **Updating:** Applying the calculated differences to the DOM.\n    - **Scheduling:** Scheduling updates with the browser.\n    - **Virtual DOM Update:** Updating the virtual DOM with the new component tree.\n    - **Error Handling:** Handling errors gracefully and displaying an error message component.\n\n    **Attributes:**\n\n    - `zen_dom_table`: A dictionary that stores the virtual DOM for each component.\n    - `hyd_tsk_task_queues`: A dictionary that stores task queues for each component.\n\n    **Methods:**\n\n    - `render(comp)`: Renders the given component by updating the DOM.\n    - `on_mutation(comp)`: Calls the `on_mutation` lifecycle method for the component.\n    - `on_settled(comp)`: Calls the `on_settled` lifecycle method for the component.\n    - `search(prev_tree, new_tree, comp_id)`: Calculates the differences between the previous and new component trees.\n    - `update(patches, comp_id)`: Applies the calculated differences to the DOM.\n    - `hyd_vdom_update(comp)`: Updates the virtual DOM with the new component tree.\n    - `on_error(comp, error)`: Handles errors gracefully and displays an error message component.\n    \"\"\"\n    async def render(self, comp ) -&gt; None:\n        \"\"\"\n        Renders the component by updating the DOM based on the differences between the previous and new component trees.\n\n        This method performs the following steps:\n\n        1. **Lifecycle:** Calls the `on_mutation` lifecycle method for the component.\n        2. **Diffing:** Calculates the differences between the previous and new component trees using the `search` method.\n        3. **Update:** Applies the calculated differences to the DOM using the `update` method.\n        4. **Scheduling:** Schedules the updates with the browser using the `hyd_rdom_is_complete` and `hyd_tsk_dequeue_task` methods.\n        5. **Virtual DOM Update:** Updates the virtual DOM with the new component tree using the `hyd_vdom_update` method.\n        6. **Lifecycle:** Calls the `on_settled` lifecycle method for the component.\n\n        **Error Handling:**\n\n        - If an error occurs during rendering, the `on_error` method is called with the error message.\n        - This method allows components to handle errors gracefully by returning a new component to display in place of the original component.\n        - If the component does not have a `on_error` method, a default error message component is displayed.\n\n        **Parameters:**\n\n        - `comp`: An instance of the `Component` class.\n\n        **Returns:**\n\n        None\n        \"\"\"\n        try:\n\n            # update steps 1-3: on_mutation -&gt; update -&gt; on_settled\n            # update 1: lifecycle method to be called before updating\n            await self.on_mutation(comp)\n            comp_id = comp.id            \n            prev_tree = self.zen_dom_table[comp_id]\n            new_tree = comp.render()\n\n            # create task queue for component\n            task_que = self.hyd_tsk_get_or_create_task_queue(comp_id)\n\n            # run diffing algorithm\n            patches = self.search(prev_tree, new_tree, comp_id)\n            await self.update(patches, comp_id)\n\n            # schedule update with the browser\n            while not task_que.empty():\n                task = self.hyd_tsk_dequeue_task(comp_id)\n                await task()\n\n\n            self.hyd_vdom_update(comp)\n\n            # update 3  : on_settled method to be called after updating\n            await self.on_settled(comp)\n\n        except Exception as e:\n            self.on_error(comp, traceback.format_exc())\n</code></pre>"},{"location":"api/client/dom/render/#zenaura.client.dom.render.Render.render","title":"<code>render(comp)</code>  <code>async</code>","text":"<p>Renders the component by updating the DOM based on the differences between the previous and new component trees.</p> <p>This method performs the following steps:</p> <ol> <li>Lifecycle: Calls the <code>on_mutation</code> lifecycle method for the component.</li> <li>Diffing: Calculates the differences between the previous and new component trees using the <code>search</code> method.</li> <li>Update: Applies the calculated differences to the DOM using the <code>update</code> method.</li> <li>Scheduling: Schedules the updates with the browser using the <code>hyd_rdom_is_complete</code> and <code>hyd_tsk_dequeue_task</code> methods.</li> <li>Virtual DOM Update: Updates the virtual DOM with the new component tree using the <code>hyd_vdom_update</code> method.</li> <li>Lifecycle: Calls the <code>on_settled</code> lifecycle method for the component.</li> </ol> <p>Error Handling:</p> <ul> <li>If an error occurs during rendering, the <code>on_error</code> method is called with the error message.</li> <li>This method allows components to handle errors gracefully by returning a new component to display in place of the original component.</li> <li>If the component does not have a <code>on_error</code> method, a default error message component is displayed.</li> </ul> <p>Parameters:</p> <ul> <li><code>comp</code>: An instance of the <code>Component</code> class.</li> </ul> <p>Returns:</p> <p>None</p> Source code in <code>zenaura\\client\\dom\\render.py</code> <pre><code>async def render(self, comp ) -&gt; None:\n    \"\"\"\n    Renders the component by updating the DOM based on the differences between the previous and new component trees.\n\n    This method performs the following steps:\n\n    1. **Lifecycle:** Calls the `on_mutation` lifecycle method for the component.\n    2. **Diffing:** Calculates the differences between the previous and new component trees using the `search` method.\n    3. **Update:** Applies the calculated differences to the DOM using the `update` method.\n    4. **Scheduling:** Schedules the updates with the browser using the `hyd_rdom_is_complete` and `hyd_tsk_dequeue_task` methods.\n    5. **Virtual DOM Update:** Updates the virtual DOM with the new component tree using the `hyd_vdom_update` method.\n    6. **Lifecycle:** Calls the `on_settled` lifecycle method for the component.\n\n    **Error Handling:**\n\n    - If an error occurs during rendering, the `on_error` method is called with the error message.\n    - This method allows components to handle errors gracefully by returning a new component to display in place of the original component.\n    - If the component does not have a `on_error` method, a default error message component is displayed.\n\n    **Parameters:**\n\n    - `comp`: An instance of the `Component` class.\n\n    **Returns:**\n\n    None\n    \"\"\"\n    try:\n\n        # update steps 1-3: on_mutation -&gt; update -&gt; on_settled\n        # update 1: lifecycle method to be called before updating\n        await self.on_mutation(comp)\n        comp_id = comp.id            \n        prev_tree = self.zen_dom_table[comp_id]\n        new_tree = comp.render()\n\n        # create task queue for component\n        task_que = self.hyd_tsk_get_or_create_task_queue(comp_id)\n\n        # run diffing algorithm\n        patches = self.search(prev_tree, new_tree, comp_id)\n        await self.update(patches, comp_id)\n\n        # schedule update with the browser\n        while not task_que.empty():\n            task = self.hyd_tsk_dequeue_task(comp_id)\n            await task()\n\n\n        self.hyd_vdom_update(comp)\n\n        # update 3  : on_settled method to be called after updating\n        await self.on_settled(comp)\n\n    except Exception as e:\n        self.on_error(comp, traceback.format_exc())\n</code></pre>"},{"location":"api/client/hydrator/hy_comp/","title":"Compiler Adapter","text":""},{"location":"api/client/hydrator/hy_comp/#zenaura.client.hydrator.compiler_adapter.HydratorCompilerAdapter","title":"<code>HydratorCompilerAdapter</code>","text":"<p>hyderator adapter for all real dom operations methods should start with: hyd_comp_</p> Source code in <code>zenaura\\client\\hydrator\\compiler_adapter.py</code> <pre><code>class HydratorCompilerAdapter:\n    \"\"\"\n        hyderator adapter for all real dom operations\n        methods should start with:\n        hyd_comp_\n    \"\"\"        \n    def hyd_comp_get_keyed_uuid(\n        self,\n        id : str, \n        key : str\n    ):\n        \"\"\"\n            compiler operation : wraps compiler.getKeyedUID \n        \"\"\"\n        return compiler.getKeyedUID(\n            id=id, \n            key=key,\n        )\n\n    def hyd_comp_compile_render(\n        self,\n        comp: Component,\n    ):\n        \"\"\"\n            compiler operation : wraps compiler compile, returns str \"HTMLElement\"\n            compile node\n        \"\"\"\n        return compiler.compile(\n                comp.render(), \n                id=comp.id,\n                zenaura_dom_mode=True\n            )\n\n    def hyd_comp_compile_children(\n        self,\n        children: List[Node],\n        id: str,\n        zenaura_dom_mode: bool,\n        key: str=\"\"\n    ):\n        \"\"\"\n            compiler operation : wraps compiler compile, returns str \"HTMLElement\"\n            compiles node children\n        \"\"\"\n        return compiler.compile(\n            children, \n            id=id,\n            zenaura_dom_mode=True,\n        )\n\n    def hyd_comp_compile_page(self, page: Page) -&gt; str:\n        \"\"\"\n            compiler operation : wraps compiler compile, returns str \"HTMLElement\"\n            compiles page children\n        \"\"\"\n        html = io.StringIO()\n        for comp in page.children:\n            html.write(\n                compiler.compile(\n                    comp.render(), \n                    comp.id,\n                    zenaura_dom_mode=True,\n                )\n            )\n        return html.getvalue()\n</code></pre>"},{"location":"api/client/hydrator/hy_comp/#zenaura.client.hydrator.compiler_adapter.HydratorCompilerAdapter.hyd_comp_compile_children","title":"<code>hyd_comp_compile_children(children, id, zenaura_dom_mode, key='')</code>","text":"<p>compiler operation : wraps compiler compile, returns str \"HTMLElement\" compiles node children</p> Source code in <code>zenaura\\client\\hydrator\\compiler_adapter.py</code> <pre><code>def hyd_comp_compile_children(\n    self,\n    children: List[Node],\n    id: str,\n    zenaura_dom_mode: bool,\n    key: str=\"\"\n):\n    \"\"\"\n        compiler operation : wraps compiler compile, returns str \"HTMLElement\"\n        compiles node children\n    \"\"\"\n    return compiler.compile(\n        children, \n        id=id,\n        zenaura_dom_mode=True,\n    )\n</code></pre>"},{"location":"api/client/hydrator/hy_comp/#zenaura.client.hydrator.compiler_adapter.HydratorCompilerAdapter.hyd_comp_compile_page","title":"<code>hyd_comp_compile_page(page)</code>","text":"<p>compiler operation : wraps compiler compile, returns str \"HTMLElement\" compiles page children</p> Source code in <code>zenaura\\client\\hydrator\\compiler_adapter.py</code> <pre><code>def hyd_comp_compile_page(self, page: Page) -&gt; str:\n    \"\"\"\n        compiler operation : wraps compiler compile, returns str \"HTMLElement\"\n        compiles page children\n    \"\"\"\n    html = io.StringIO()\n    for comp in page.children:\n        html.write(\n            compiler.compile(\n                comp.render(), \n                comp.id,\n                zenaura_dom_mode=True,\n            )\n        )\n    return html.getvalue()\n</code></pre>"},{"location":"api/client/hydrator/hy_comp/#zenaura.client.hydrator.compiler_adapter.HydratorCompilerAdapter.hyd_comp_compile_render","title":"<code>hyd_comp_compile_render(comp)</code>","text":"<p>compiler operation : wraps compiler compile, returns str \"HTMLElement\" compile node</p> Source code in <code>zenaura\\client\\hydrator\\compiler_adapter.py</code> <pre><code>def hyd_comp_compile_render(\n    self,\n    comp: Component,\n):\n    \"\"\"\n        compiler operation : wraps compiler compile, returns str \"HTMLElement\"\n        compile node\n    \"\"\"\n    return compiler.compile(\n            comp.render(), \n            id=comp.id,\n            zenaura_dom_mode=True\n        )\n</code></pre>"},{"location":"api/client/hydrator/hy_comp/#zenaura.client.hydrator.compiler_adapter.HydratorCompilerAdapter.hyd_comp_get_keyed_uuid","title":"<code>hyd_comp_get_keyed_uuid(id, key)</code>","text":"<p>compiler operation : wraps compiler.getKeyedUID</p> Source code in <code>zenaura\\client\\hydrator\\compiler_adapter.py</code> <pre><code>def hyd_comp_get_keyed_uuid(\n    self,\n    id : str, \n    key : str\n):\n    \"\"\"\n        compiler operation : wraps compiler.getKeyedUID \n    \"\"\"\n    return compiler.getKeyedUID(\n        id=id, \n        key=key,\n    )\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/","title":"Real DOM Adapter","text":""},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter","title":"<code>HydratorRealDomAdapter</code>","text":"<p>hyderator adapter for all real dom operations methods should start with: hyd_romp_</p> Source code in <code>zenaura\\client\\hydrator\\real_dom_adapter.py</code> <pre><code>class HydratorRealDomAdapter:\n    # for testing \n    \"\"\"\n        hyderator adapter for all real dom operations\n        methods should start with:\n        hyd_romp_\n    \"\"\"\n\n\n    def hyd_rdom_create_element(self, virtual_node: Node) -&gt; HTMLElement:\n        \"\"\"\n        DOM operation: creates html element and returns it as HTMLElement\n\n        Args:\n            virtual_node: Node - the virtual node representing the element to be created\n\n        Returns:\n            HTMLElement - the created HTML element\n        \"\"\"\n        element = document.createElement(virtual_node.name)\n\n        return element\n\n    def hyd_rdom_attach_to_root(self, html : str) -&gt; None:\n        \"\"\"\n        DOM operation: attaches compiled_comp to mounted_comp_id\n\n        Args:\n            html: str - the HTML string to be attached to the root element\n        \"\"\"\n        document.getElementById(\"root\").innerHTML = html\n\n    def hyd_rdom_attach_to_mounted_comp(\n            self,\n            mounted_comp_id: str,\n            html: str\n    ):\n        \"\"\"\n        DOM operation: attaches compiled_comp to mounted_comp_id\n\n        Args:\n            mounted_comp_id: str - the ID of the previously mounted component\n            html: str - the HTML string to be attached to the mounted component\n        \"\"\"\n        foundNode = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{mounted_comp_id}\"]')\n        if foundNode:\n            foundNode.outerHTML = html\n\n    def hyd_rdom_set_attribute(self, mounted_comp_id: str, attribute: Attribute) -&gt; None:\n        \"\"\"\n        DOM operation: Sets attributes on an HTML element.\n\n        Args:\n            mounted_comp_id: The ID of the element to modify.\n            attributes: A dictionary of attribute names and their values.\n        \"\"\"\n        element = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{mounted_comp_id}\"]')\n        if element:\n            element.setAttribute(attribute.key, attribute.value)\n\n\n    def hyd_rdom_remove_attribute(self, mounted_comp_id: str, attribute_name: str) -&gt; None:\n        \"\"\"\n        DOM operation: Removes an attribute from an HTML element.\n\n        Args:\n            mounted_comp_id: The ID of the element.\n            attribute_name: The name of the attribute to remove.\n        \"\"\"\n        element = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{mounted_comp_id}\"]')\n        if element:\n            element.removeAttribute(attribute_name)\n\n    def hyd_rdom_remove_element(self, mounted_comp_id: str) -&gt; None:\n        \"\"\"\n        DOM operation: removes an element from the DOM\n\n        Args:\n            mounted_comp_id: str - the ID of the element to be removed\n        \"\"\"\n        element = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{mounted_comp_id}\"]')\n        if element:\n            element.parentNode.removeChild(element)\n\n\n    def hyd_rdom_append_child(self, mounted_comp_id:str, child_html:str) -&gt; None:\n        \"\"\"\n        DOM operation: appends a child to an element\n\n        Args:\n            mounted_comp_id: str - the ID of the parent element\n            child_html: str - the HTML string of the child element to be appended\n        \"\"\"\n        element = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{mounted_comp_id}\"]')\n        if element:\n            child_node = document.createElement(\"template\")\n            child_node.innerHTML = child_html\n            element.appendChild(child_node.content.firstChild)\n\n    def hyd_rdom_append_child_after(self, parent_node_id, child_node_id, child_html) -&gt; None:\n        \"\"\"\n        DOM operation: appends a child to an element after a specific child\n\n        Args:\n            parent_node_id: str - the ID of the parent element\n            child_node_id: str - the ID of the child element to insert after\n            child_html: str - the HTML string of the child element to be appended\n        \"\"\"\n        element = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{parent_node_id}\"]')\n        if element : # if parent exists\n            child_node = document.createElement(\"template\")\n            child_node.innerHTML = child_html\n            curr_node = child_node.content.firstChild\n            child_index = int( child_node_id[-1])\n            prev_child = child_index - 1 # child on the dom to insert the new child after it\n            prev_child_id = child_node_id[:-1] + str(prev_child) # parent-childIndex\n            prev_child = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{prev_child_id}\"]')\n            if prev_child: # insert after the current child:\n                element.insertBefore(curr_node, prev_child.nextSibling)\n            else: # parent is a leaf no children\n                element.append(curr_node)\n            pass\n\n    def hyd_rdom_remove_child(self, child_id:str) -&gt; None:\n        \"\"\"\n        DOM operation: removes a child of an element\n\n        Args:\n            child_id: str - the ID of the child element to be removed\n        \"\"\"\n        child_node = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{child_id}\"]')\n        if child_node:\n            child_node.outerHTML = \"\"\n\n\n    def hyd_rdom_add_text_render(self, mounted_comp_id: str, text_content: str) -&gt; None:\n        \"\"\"\n        DOM operation: Adds a text node to an element.\n\n        Args:\n            mounted_comp_id: str - the ID of the element to add the text node to\n            text_content: str - the text content of the text node\n        \"\"\"\n        element = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{mounted_comp_id}\"]')\n        if element:\n            text_node = document.createTextNode(text_content)\n            element.appendChild(text_node)\n\n\n    def hyd_rdom_replace_inner_text(self, mounted_comp_id: str, new_text: str) -&gt; None:\n        \"\"\"\n        DOM operation: Replaces the inner text content of an element.\n\n        Args:\n            mounted_comp_id: str - the ID of the element to replace the text content of\n            new_text: str - the new text content\n        \"\"\"\n        element = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{mounted_comp_id}\"]')\n        if element:\n            element.textContent = new_text\n\n    def hyd_rdom_is_interactive(self) -&gt; bool:\n        \"\"\"\n        DOM operation: checks if real dom  is interactive\n\n        Returns:\n            bool - True if the DOM is interactive, False otherwise\n        \"\"\"\n        return document.readyState == \"interactive\"\n\n    def hyd_rdom_is_complete(self) -&gt; bool:\n        \"\"\"\n        DOM operation: checks if real dom  is complete\n\n        Returns:\n            bool - True if the DOM is complete, False otherwise\n        \"\"\"\n        return document.readyState == \"complete\"\n\n    def hyd_rdom_is_loading(self) -&gt; bool:\n        \"\"\"\n        DOM operation: checks if real dom  is complete\n\n        Returns:\n            bool - True if the DOM is complete, False otherwise\n        \"\"\"\n        return document.readyState == \"load\"\n\n    def hyd_rdom_is_content_loaded(self) -&gt; bool:\n        \"\"\"\n        DOM operation: checks if real dom  is content loaded\n\n        Returns:\n            bool - True if the DOM is content loaded, False otherwise\n        \"\"\"\n        return document.readyState == \"DOMContentLoaded\"\n\n    async def hyd_rdom_wait_for_dom_content_loaded(self):\n        \"\"\"\n        Waits for the DOM to be content loaded.\n        \"\"\"\n        if not in_browser:\n            return \n        while True:\n            await asyncio.sleep(0.001)\n            if document.readyState==\"complete\":\n                break\n\n\n    def hyd_rdom_toggle_pages_visibilty(self, previous_page : Page, current_page : Page ):\n        \"\"\"\n        Toggles the visibility of the previous and current pages.\n\n        Args:\n            previous_page: Page - the previously mounted page\n            current_page: Page - the currently mounted page\n        \"\"\"\n        p_page = document.querySelector(f'[data-zenaura=\"{previous_page.id}\"]')\n        if p_page:\n            p_page.hidden = True\n        curr_page = document.querySelector(f'[data-zenaura=\"{current_page.id}\"]')\n        if curr_page:\n            curr_page.hidden = False # Update the title\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_add_text_render","title":"<code>hyd_rdom_add_text_render(mounted_comp_id, text_content)</code>","text":"<p>DOM operation: Adds a text node to an element.</p> <p>Parameters:</p> Name Type Description Default <code>mounted_comp_id</code> <code>str</code> <p>str - the ID of the element to add the text node to</p> required <code>text_content</code> <code>str</code> <p>str - the text content of the text node</p> required Source code in <code>zenaura\\client\\hydrator\\real_dom_adapter.py</code> <pre><code>def hyd_rdom_add_text_render(self, mounted_comp_id: str, text_content: str) -&gt; None:\n    \"\"\"\n    DOM operation: Adds a text node to an element.\n\n    Args:\n        mounted_comp_id: str - the ID of the element to add the text node to\n        text_content: str - the text content of the text node\n    \"\"\"\n    element = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{mounted_comp_id}\"]')\n    if element:\n        text_node = document.createTextNode(text_content)\n        element.appendChild(text_node)\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_append_child","title":"<code>hyd_rdom_append_child(mounted_comp_id, child_html)</code>","text":"<p>DOM operation: appends a child to an element</p> <p>Parameters:</p> Name Type Description Default <code>mounted_comp_id</code> <code>str</code> <p>str - the ID of the parent element</p> required <code>child_html</code> <code>str</code> <p>str - the HTML string of the child element to be appended</p> required Source code in <code>zenaura\\client\\hydrator\\real_dom_adapter.py</code> <pre><code>def hyd_rdom_append_child(self, mounted_comp_id:str, child_html:str) -&gt; None:\n    \"\"\"\n    DOM operation: appends a child to an element\n\n    Args:\n        mounted_comp_id: str - the ID of the parent element\n        child_html: str - the HTML string of the child element to be appended\n    \"\"\"\n    element = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{mounted_comp_id}\"]')\n    if element:\n        child_node = document.createElement(\"template\")\n        child_node.innerHTML = child_html\n        element.appendChild(child_node.content.firstChild)\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_append_child_after","title":"<code>hyd_rdom_append_child_after(parent_node_id, child_node_id, child_html)</code>","text":"<p>DOM operation: appends a child to an element after a specific child</p> <p>Parameters:</p> Name Type Description Default <code>parent_node_id</code> <p>str - the ID of the parent element</p> required <code>child_node_id</code> <p>str - the ID of the child element to insert after</p> required <code>child_html</code> <p>str - the HTML string of the child element to be appended</p> required Source code in <code>zenaura\\client\\hydrator\\real_dom_adapter.py</code> <pre><code>def hyd_rdom_append_child_after(self, parent_node_id, child_node_id, child_html) -&gt; None:\n    \"\"\"\n    DOM operation: appends a child to an element after a specific child\n\n    Args:\n        parent_node_id: str - the ID of the parent element\n        child_node_id: str - the ID of the child element to insert after\n        child_html: str - the HTML string of the child element to be appended\n    \"\"\"\n    element = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{parent_node_id}\"]')\n    if element : # if parent exists\n        child_node = document.createElement(\"template\")\n        child_node.innerHTML = child_html\n        curr_node = child_node.content.firstChild\n        child_index = int( child_node_id[-1])\n        prev_child = child_index - 1 # child on the dom to insert the new child after it\n        prev_child_id = child_node_id[:-1] + str(prev_child) # parent-childIndex\n        prev_child = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{prev_child_id}\"]')\n        if prev_child: # insert after the current child:\n            element.insertBefore(curr_node, prev_child.nextSibling)\n        else: # parent is a leaf no children\n            element.append(curr_node)\n        pass\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_attach_to_mounted_comp","title":"<code>hyd_rdom_attach_to_mounted_comp(mounted_comp_id, html)</code>","text":"<p>DOM operation: attaches compiled_comp to mounted_comp_id</p> <p>Parameters:</p> Name Type Description Default <code>mounted_comp_id</code> <code>str</code> <p>str - the ID of the previously mounted component</p> required <code>html</code> <code>str</code> <p>str - the HTML string to be attached to the mounted component</p> required Source code in <code>zenaura\\client\\hydrator\\real_dom_adapter.py</code> <pre><code>def hyd_rdom_attach_to_mounted_comp(\n        self,\n        mounted_comp_id: str,\n        html: str\n):\n    \"\"\"\n    DOM operation: attaches compiled_comp to mounted_comp_id\n\n    Args:\n        mounted_comp_id: str - the ID of the previously mounted component\n        html: str - the HTML string to be attached to the mounted component\n    \"\"\"\n    foundNode = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{mounted_comp_id}\"]')\n    if foundNode:\n        foundNode.outerHTML = html\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_attach_to_root","title":"<code>hyd_rdom_attach_to_root(html)</code>","text":"<p>DOM operation: attaches compiled_comp to mounted_comp_id</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>str - the HTML string to be attached to the root element</p> required Source code in <code>zenaura\\client\\hydrator\\real_dom_adapter.py</code> <pre><code>def hyd_rdom_attach_to_root(self, html : str) -&gt; None:\n    \"\"\"\n    DOM operation: attaches compiled_comp to mounted_comp_id\n\n    Args:\n        html: str - the HTML string to be attached to the root element\n    \"\"\"\n    document.getElementById(\"root\").innerHTML = html\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_create_element","title":"<code>hyd_rdom_create_element(virtual_node)</code>","text":"<p>DOM operation: creates html element and returns it as HTMLElement</p> <p>Parameters:</p> Name Type Description Default <code>virtual_node</code> <code>Node</code> <p>Node - the virtual node representing the element to be created</p> required <p>Returns:</p> Type Description <code>HTMLElement</code> <p>HTMLElement - the created HTML element</p> Source code in <code>zenaura\\client\\hydrator\\real_dom_adapter.py</code> <pre><code>def hyd_rdom_create_element(self, virtual_node: Node) -&gt; HTMLElement:\n    \"\"\"\n    DOM operation: creates html element and returns it as HTMLElement\n\n    Args:\n        virtual_node: Node - the virtual node representing the element to be created\n\n    Returns:\n        HTMLElement - the created HTML element\n    \"\"\"\n    element = document.createElement(virtual_node.name)\n\n    return element\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_is_complete","title":"<code>hyd_rdom_is_complete()</code>","text":"<p>DOM operation: checks if real dom  is complete</p> <p>Returns:</p> Type Description <code>bool</code> <p>bool - True if the DOM is complete, False otherwise</p> Source code in <code>zenaura\\client\\hydrator\\real_dom_adapter.py</code> <pre><code>def hyd_rdom_is_complete(self) -&gt; bool:\n    \"\"\"\n    DOM operation: checks if real dom  is complete\n\n    Returns:\n        bool - True if the DOM is complete, False otherwise\n    \"\"\"\n    return document.readyState == \"complete\"\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_is_content_loaded","title":"<code>hyd_rdom_is_content_loaded()</code>","text":"<p>DOM operation: checks if real dom  is content loaded</p> <p>Returns:</p> Type Description <code>bool</code> <p>bool - True if the DOM is content loaded, False otherwise</p> Source code in <code>zenaura\\client\\hydrator\\real_dom_adapter.py</code> <pre><code>def hyd_rdom_is_content_loaded(self) -&gt; bool:\n    \"\"\"\n    DOM operation: checks if real dom  is content loaded\n\n    Returns:\n        bool - True if the DOM is content loaded, False otherwise\n    \"\"\"\n    return document.readyState == \"DOMContentLoaded\"\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_is_interactive","title":"<code>hyd_rdom_is_interactive()</code>","text":"<p>DOM operation: checks if real dom  is interactive</p> <p>Returns:</p> Type Description <code>bool</code> <p>bool - True if the DOM is interactive, False otherwise</p> Source code in <code>zenaura\\client\\hydrator\\real_dom_adapter.py</code> <pre><code>def hyd_rdom_is_interactive(self) -&gt; bool:\n    \"\"\"\n    DOM operation: checks if real dom  is interactive\n\n    Returns:\n        bool - True if the DOM is interactive, False otherwise\n    \"\"\"\n    return document.readyState == \"interactive\"\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_is_loading","title":"<code>hyd_rdom_is_loading()</code>","text":"<p>DOM operation: checks if real dom  is complete</p> <p>Returns:</p> Type Description <code>bool</code> <p>bool - True if the DOM is complete, False otherwise</p> Source code in <code>zenaura\\client\\hydrator\\real_dom_adapter.py</code> <pre><code>def hyd_rdom_is_loading(self) -&gt; bool:\n    \"\"\"\n    DOM operation: checks if real dom  is complete\n\n    Returns:\n        bool - True if the DOM is complete, False otherwise\n    \"\"\"\n    return document.readyState == \"load\"\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_remove_attribute","title":"<code>hyd_rdom_remove_attribute(mounted_comp_id, attribute_name)</code>","text":"<p>DOM operation: Removes an attribute from an HTML element.</p> <p>Parameters:</p> Name Type Description Default <code>mounted_comp_id</code> <code>str</code> <p>The ID of the element.</p> required <code>attribute_name</code> <code>str</code> <p>The name of the attribute to remove.</p> required Source code in <code>zenaura\\client\\hydrator\\real_dom_adapter.py</code> <pre><code>def hyd_rdom_remove_attribute(self, mounted_comp_id: str, attribute_name: str) -&gt; None:\n    \"\"\"\n    DOM operation: Removes an attribute from an HTML element.\n\n    Args:\n        mounted_comp_id: The ID of the element.\n        attribute_name: The name of the attribute to remove.\n    \"\"\"\n    element = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{mounted_comp_id}\"]')\n    if element:\n        element.removeAttribute(attribute_name)\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_remove_child","title":"<code>hyd_rdom_remove_child(child_id)</code>","text":"<p>DOM operation: removes a child of an element</p> <p>Parameters:</p> Name Type Description Default <code>child_id</code> <code>str</code> <p>str - the ID of the child element to be removed</p> required Source code in <code>zenaura\\client\\hydrator\\real_dom_adapter.py</code> <pre><code>def hyd_rdom_remove_child(self, child_id:str) -&gt; None:\n    \"\"\"\n    DOM operation: removes a child of an element\n\n    Args:\n        child_id: str - the ID of the child element to be removed\n    \"\"\"\n    child_node = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{child_id}\"]')\n    if child_node:\n        child_node.outerHTML = \"\"\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_remove_element","title":"<code>hyd_rdom_remove_element(mounted_comp_id)</code>","text":"<p>DOM operation: removes an element from the DOM</p> <p>Parameters:</p> Name Type Description Default <code>mounted_comp_id</code> <code>str</code> <p>str - the ID of the element to be removed</p> required Source code in <code>zenaura\\client\\hydrator\\real_dom_adapter.py</code> <pre><code>def hyd_rdom_remove_element(self, mounted_comp_id: str) -&gt; None:\n    \"\"\"\n    DOM operation: removes an element from the DOM\n\n    Args:\n        mounted_comp_id: str - the ID of the element to be removed\n    \"\"\"\n    element = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{mounted_comp_id}\"]')\n    if element:\n        element.parentNode.removeChild(element)\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_replace_inner_text","title":"<code>hyd_rdom_replace_inner_text(mounted_comp_id, new_text)</code>","text":"<p>DOM operation: Replaces the inner text content of an element.</p> <p>Parameters:</p> Name Type Description Default <code>mounted_comp_id</code> <code>str</code> <p>str - the ID of the element to replace the text content of</p> required <code>new_text</code> <code>str</code> <p>str - the new text content</p> required Source code in <code>zenaura\\client\\hydrator\\real_dom_adapter.py</code> <pre><code>def hyd_rdom_replace_inner_text(self, mounted_comp_id: str, new_text: str) -&gt; None:\n    \"\"\"\n    DOM operation: Replaces the inner text content of an element.\n\n    Args:\n        mounted_comp_id: str - the ID of the element to replace the text content of\n        new_text: str - the new text content\n    \"\"\"\n    element = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{mounted_comp_id}\"]')\n    if element:\n        element.textContent = new_text\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_set_attribute","title":"<code>hyd_rdom_set_attribute(mounted_comp_id, attribute)</code>","text":"<p>DOM operation: Sets attributes on an HTML element.</p> <p>Parameters:</p> Name Type Description Default <code>mounted_comp_id</code> <code>str</code> <p>The ID of the element to modify.</p> required <code>attributes</code> <p>A dictionary of attribute names and their values.</p> required Source code in <code>zenaura\\client\\hydrator\\real_dom_adapter.py</code> <pre><code>def hyd_rdom_set_attribute(self, mounted_comp_id: str, attribute: Attribute) -&gt; None:\n    \"\"\"\n    DOM operation: Sets attributes on an HTML element.\n\n    Args:\n        mounted_comp_id: The ID of the element to modify.\n        attributes: A dictionary of attribute names and their values.\n    \"\"\"\n    element = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{mounted_comp_id}\"]')\n    if element:\n        element.setAttribute(attribute.key, attribute.value)\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_toggle_pages_visibilty","title":"<code>hyd_rdom_toggle_pages_visibilty(previous_page, current_page)</code>","text":"<p>Toggles the visibility of the previous and current pages.</p> <p>Parameters:</p> Name Type Description Default <code>previous_page</code> <code>Page</code> <p>Page - the previously mounted page</p> required <code>current_page</code> <code>Page</code> <p>Page - the currently mounted page</p> required Source code in <code>zenaura\\client\\hydrator\\real_dom_adapter.py</code> <pre><code>def hyd_rdom_toggle_pages_visibilty(self, previous_page : Page, current_page : Page ):\n    \"\"\"\n    Toggles the visibility of the previous and current pages.\n\n    Args:\n        previous_page: Page - the previously mounted page\n        current_page: Page - the currently mounted page\n    \"\"\"\n    p_page = document.querySelector(f'[data-zenaura=\"{previous_page.id}\"]')\n    if p_page:\n        p_page.hidden = True\n    curr_page = document.querySelector(f'[data-zenaura=\"{current_page.id}\"]')\n    if curr_page:\n        curr_page.hidden = False # Update the title\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_wait_for_dom_content_loaded","title":"<code>hyd_rdom_wait_for_dom_content_loaded()</code>  <code>async</code>","text":"<p>Waits for the DOM to be content loaded.</p> Source code in <code>zenaura\\client\\hydrator\\real_dom_adapter.py</code> <pre><code>async def hyd_rdom_wait_for_dom_content_loaded(self):\n    \"\"\"\n    Waits for the DOM to be content loaded.\n    \"\"\"\n    if not in_browser:\n        return \n    while True:\n        await asyncio.sleep(0.001)\n        if document.readyState==\"complete\":\n            break\n</code></pre>"},{"location":"api/client/hydrator/hy_tasker/","title":"Tasker Adapter","text":""},{"location":"api/client/hydrator/hy_tasker/#zenaura.client.hydrator.tasker.HydratorTasker","title":"<code>HydratorTasker</code>","text":"<p>Manages tasks generated by the Zenaura diffing algorithm for updating both the real DOM and the virtual DOM.</p> <p>This class provides methods for:</p> <ul> <li>Creating and retrieving task queues for specific component IDs.</li> <li>Enqueuing tasks for components.</li> <li>Dequeuing tasks for components.</li> </ul> <p>Key Features:</p> <ul> <li>Efficient task management for real and virtual DOM updates.</li> <li>Thread-safe task queue operations.</li> <li>Automatic cleanup of empty task queues.</li> </ul> <p>Usage:</p> <ol> <li>Use <code>hyd_tsk_get_or_create_task_queue</code> to get or create a task queue for a specific component ID.</li> <li>Use <code>hyd_tsk_enqueue_task</code> to enqueue a task for a component.</li> <li>Use <code>hyd_tsk_dequeue_task</code> to dequeue a task for a component.</li> </ol> <p>Example:</p> <pre><code>tasker = HydratorTasker()\n\n# Get or create a task queue for component ID \"my-component\"\ntask_queue = tasker.hyd_tsk_get_or_create_task_queue(\"my-component\")\n\n# Enqueue a task for the component\ntask_queue.put_nowait(my_task)\n\n# Dequeue a task for the component\ntask = task_queue.get_nowait()\n\n# Execute the task\ntask()\n</code></pre> Source code in <code>zenaura\\client\\hydrator\\tasker.py</code> <pre><code>class HydratorTasker:\n    \"\"\"\n    Manages tasks generated by the Zenaura diffing algorithm for updating both the real DOM and the virtual DOM.\n\n    This class provides methods for:\n\n    - Creating and retrieving task queues for specific component IDs.\n    - Enqueuing tasks for components.\n    - Dequeuing tasks for components.\n\n    **Key Features:**\n\n    - Efficient task management for real and virtual DOM updates.\n    - Thread-safe task queue operations.\n    - Automatic cleanup of empty task queues.\n\n    **Usage:**\n\n    1. Use `hyd_tsk_get_or_create_task_queue` to get or create a task queue for a specific component ID.\n    2. Use `hyd_tsk_enqueue_task` to enqueue a task for a component.\n    3. Use `hyd_tsk_dequeue_task` to dequeue a task for a component.\n\n    **Example:**\n\n    ```python\n    tasker = HydratorTasker()\n\n    # Get or create a task queue for component ID \"my-component\"\n    task_queue = tasker.hyd_tsk_get_or_create_task_queue(\"my-component\")\n\n    # Enqueue a task for the component\n    task_queue.put_nowait(my_task)\n\n    # Dequeue a task for the component\n    task = task_queue.get_nowait()\n\n    # Execute the task\n    task()\n    ```\n    \"\"\"\n\n    queue_lookup = defaultdict(lambda: None)\n\n    def __init__(self):\n        \"\"\"\n        Initializes the HydratorTasker instance.\n        \"\"\"\n        pass\n\n    def hyd_tsk_get_or_create_task_queue(self, component_id) -&gt; asyncio.Queue:\n        \"\"\"\n        Gets or creates a task queue for the specified component ID.\n\n        Args:\n            component_id (str): The ID of the component.\n\n        Returns:\n            asyncio.Queue: The task queue for the component.\n        \"\"\"\n        try:\n            if component_id not in self.queue_lookup:\n                self.queue_lookup[component_id] = asyncio.Queue()\n                return self.queue_lookup[component_id]\n            else:\n                return self.queue_lookup[component_id]\n        except KeyError:\n            return False\n\n    def hyd_tsk_enqueue_task(self, component_id, task):\n        \"\"\"\n        Enqueues a task for the specified component ID.\n\n        Args:\n            component_id (str): The ID of the component.\n            task (callable): The task to be enqueued.\n\n        Returns:\n            bool: True if the task was successfully enqueued, False otherwise.\n        \"\"\"\n        comp_queue = self.queue_lookup[component_id]\n        if not comp_queue:\n            return False \n        try:\n            comp_queue.put_nowait(task)\n            return True\n        except asyncio.QueueFull:\n            return False\n\n    async def hyd_tsk_do_nothing(self):\n        \"\"\"\n        A placeholder function used when a task queue is empty.\n        \"\"\"\n        return asyncio.Queue()\n\n    def hyd_tsk_dequeue_task(self, component_id):\n        \"\"\"\n        Dequeues a task for the specified component ID.\n\n        Args:\n            component_id (str): The ID of the component.\n\n        Returns:\n            callable: The dequeued task, or `hyd_tsk_do_nothing` if the queue is empty.\n        \"\"\"\n\n        comp_queue = self.queue_lookup[component_id]\n        if not comp_queue:\n            return self.hyd_tsk_do_nothing\n        try:\n            task = comp_queue.get_nowait()\n            return task\n        except asyncio.QueueEmpty:\n            # Clean up and return the placeholder function\n            self.queue_lookup[component_id] = asyncio.Queue()\n            return self.hyd_tsk_do_nothing\n</code></pre>"},{"location":"api/client/hydrator/hy_tasker/#zenaura.client.hydrator.tasker.HydratorTasker.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the HydratorTasker instance.</p> Source code in <code>zenaura\\client\\hydrator\\tasker.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the HydratorTasker instance.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/client/hydrator/hy_tasker/#zenaura.client.hydrator.tasker.HydratorTasker.hyd_tsk_dequeue_task","title":"<code>hyd_tsk_dequeue_task(component_id)</code>","text":"<p>Dequeues a task for the specified component ID.</p> <p>Parameters:</p> Name Type Description Default <code>component_id</code> <code>str</code> <p>The ID of the component.</p> required <p>Returns:</p> Name Type Description <code>callable</code> <p>The dequeued task, or <code>hyd_tsk_do_nothing</code> if the queue is empty.</p> Source code in <code>zenaura\\client\\hydrator\\tasker.py</code> <pre><code>def hyd_tsk_dequeue_task(self, component_id):\n    \"\"\"\n    Dequeues a task for the specified component ID.\n\n    Args:\n        component_id (str): The ID of the component.\n\n    Returns:\n        callable: The dequeued task, or `hyd_tsk_do_nothing` if the queue is empty.\n    \"\"\"\n\n    comp_queue = self.queue_lookup[component_id]\n    if not comp_queue:\n        return self.hyd_tsk_do_nothing\n    try:\n        task = comp_queue.get_nowait()\n        return task\n    except asyncio.QueueEmpty:\n        # Clean up and return the placeholder function\n        self.queue_lookup[component_id] = asyncio.Queue()\n        return self.hyd_tsk_do_nothing\n</code></pre>"},{"location":"api/client/hydrator/hy_tasker/#zenaura.client.hydrator.tasker.HydratorTasker.hyd_tsk_do_nothing","title":"<code>hyd_tsk_do_nothing()</code>  <code>async</code>","text":"<p>A placeholder function used when a task queue is empty.</p> Source code in <code>zenaura\\client\\hydrator\\tasker.py</code> <pre><code>async def hyd_tsk_do_nothing(self):\n    \"\"\"\n    A placeholder function used when a task queue is empty.\n    \"\"\"\n    return asyncio.Queue()\n</code></pre>"},{"location":"api/client/hydrator/hy_tasker/#zenaura.client.hydrator.tasker.HydratorTasker.hyd_tsk_enqueue_task","title":"<code>hyd_tsk_enqueue_task(component_id, task)</code>","text":"<p>Enqueues a task for the specified component ID.</p> <p>Parameters:</p> Name Type Description Default <code>component_id</code> <code>str</code> <p>The ID of the component.</p> required <code>task</code> <code>callable</code> <p>The task to be enqueued.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the task was successfully enqueued, False otherwise.</p> Source code in <code>zenaura\\client\\hydrator\\tasker.py</code> <pre><code>def hyd_tsk_enqueue_task(self, component_id, task):\n    \"\"\"\n    Enqueues a task for the specified component ID.\n\n    Args:\n        component_id (str): The ID of the component.\n        task (callable): The task to be enqueued.\n\n    Returns:\n        bool: True if the task was successfully enqueued, False otherwise.\n    \"\"\"\n    comp_queue = self.queue_lookup[component_id]\n    if not comp_queue:\n        return False \n    try:\n        comp_queue.put_nowait(task)\n        return True\n    except asyncio.QueueFull:\n        return False\n</code></pre>"},{"location":"api/client/hydrator/hy_tasker/#zenaura.client.hydrator.tasker.HydratorTasker.hyd_tsk_get_or_create_task_queue","title":"<code>hyd_tsk_get_or_create_task_queue(component_id)</code>","text":"<p>Gets or creates a task queue for the specified component ID.</p> <p>Parameters:</p> Name Type Description Default <code>component_id</code> <code>str</code> <p>The ID of the component.</p> required <p>Returns:</p> Type Description <code>Queue</code> <p>asyncio.Queue: The task queue for the component.</p> Source code in <code>zenaura\\client\\hydrator\\tasker.py</code> <pre><code>def hyd_tsk_get_or_create_task_queue(self, component_id) -&gt; asyncio.Queue:\n    \"\"\"\n    Gets or creates a task queue for the specified component ID.\n\n    Args:\n        component_id (str): The ID of the component.\n\n    Returns:\n        asyncio.Queue: The task queue for the component.\n    \"\"\"\n    try:\n        if component_id not in self.queue_lookup:\n            self.queue_lookup[component_id] = asyncio.Queue()\n            return self.queue_lookup[component_id]\n        else:\n            return self.queue_lookup[component_id]\n    except KeyError:\n        return False\n</code></pre>"},{"location":"api/client/hydrator/hy_vdom/","title":"Virtual DOM Adapter","text":""},{"location":"api/client/hydrator/hy_vdom/#zenaura.client.hydrator.virtual_dom_adapter.HydratorVirtualDomAdapter","title":"<code>HydratorVirtualDomAdapter</code>","text":"<p>             Bases: <code>VDomLookupTable</code></p> <p>hyderator adapter for all virtual dom operations methods should start with: hyd_vdom_</p> Source code in <code>zenaura\\client\\hydrator\\virtual_dom_adapter.py</code> <pre><code>class HydratorVirtualDomAdapter(\n    VDomLookupTable\n):\n    \"\"\"\n        hyderator adapter for all virtual dom operations\n        methods should start with:\n        hyd_vdom_\n    \"\"\"\n\n    def hyd_vdom_update(self, comp: Component) -&gt; None:\n        \"\"\"\n            virtual dom operation : updates virtual dom of component\n            args:\n                comp: Component\n        \"\"\"\n        self.zen_dom_table[comp.id] = comp.render()\n\n    def hyd_vdom_delete(self, comp: Component) -&gt; None:\n        \"\"\"\n            virtual dom operation : deletes virtual dom of component\n            args:\n                comp: Component\n        \"\"\"\n        del self.zen_dom_table[comp.id]\n\n    def hyd_vdom_update_with_new_render(self, comp: Component, new_node):\n        \"\"\"\n            update component with new node\n            args:\n                comp: Component\n                new_node: Node\n        \"\"\"\n        self.zen_dom_table[comp.id] = new_node\n</code></pre>"},{"location":"api/client/hydrator/hy_vdom/#zenaura.client.hydrator.virtual_dom_adapter.HydratorVirtualDomAdapter.hyd_vdom_delete","title":"<code>hyd_vdom_delete(comp)</code>","text":"<p>virtual dom operation : deletes virtual dom of component args:     comp: Component</p> Source code in <code>zenaura\\client\\hydrator\\virtual_dom_adapter.py</code> <pre><code>def hyd_vdom_delete(self, comp: Component) -&gt; None:\n    \"\"\"\n        virtual dom operation : deletes virtual dom of component\n        args:\n            comp: Component\n    \"\"\"\n    del self.zen_dom_table[comp.id]\n</code></pre>"},{"location":"api/client/hydrator/hy_vdom/#zenaura.client.hydrator.virtual_dom_adapter.HydratorVirtualDomAdapter.hyd_vdom_update","title":"<code>hyd_vdom_update(comp)</code>","text":"<p>virtual dom operation : updates virtual dom of component args:     comp: Component</p> Source code in <code>zenaura\\client\\hydrator\\virtual_dom_adapter.py</code> <pre><code>def hyd_vdom_update(self, comp: Component) -&gt; None:\n    \"\"\"\n        virtual dom operation : updates virtual dom of component\n        args:\n            comp: Component\n    \"\"\"\n    self.zen_dom_table[comp.id] = comp.render()\n</code></pre>"},{"location":"api/client/hydrator/hy_vdom/#zenaura.client.hydrator.virtual_dom_adapter.HydratorVirtualDomAdapter.hyd_vdom_update_with_new_render","title":"<code>hyd_vdom_update_with_new_render(comp, new_node)</code>","text":"<p>update component with new node args:     comp: Component     new_node: Node</p> Source code in <code>zenaura\\client\\hydrator\\virtual_dom_adapter.py</code> <pre><code>def hyd_vdom_update_with_new_render(self, comp: Component, new_node):\n    \"\"\"\n        update component with new node\n        args:\n            comp: Component\n            new_node: Node\n    \"\"\"\n    self.zen_dom_table[comp.id] = new_node\n</code></pre>"},{"location":"api/client/hydrator/hydrator/","title":"Overview","text":""},{"location":"api/client/hydrator/hydrator/#zenaura.client.hydrator.hydrator.Hydrator","title":"<code>Hydrator</code>","text":"<p>             Bases: <code>HydratorVirtualDomAdapter</code>, <code>HydratorCompilerAdapter</code>, <code>HydratorRealDomAdapter</code>, <code>HydratorTasker</code></p> <p>Hydrator acts as the central communication hub between:</p> <ol> <li>Virtual DOM and Compiler:<ul> <li>Methods interacting with the compiler start with <code>hyd_comp_</code>, e.g., <code>hyd_comp_get_keyed_uuid</code>, <code>hyd_comp_compile_node</code>.</li> </ul> </li> <li>Virtual DOM:<ul> <li>Methods interacting with Zenaura's virtual DOM start with <code>hyd_vdom_</code>, e.g., <code>hyd_vdom_update</code>, <code>hyd_vdom_delete</code>.</li> </ul> </li> <li>DOM:<ul> <li>Methods interacting with the DOM start with <code>hyd_dom_</code>, e.g., <code>hyd_rdom_attach_to_root</code>.</li> </ul> </li> <li>Tasker:<ul> <li>Tasks for updating the DOM are created in the updater and dequeued during the render lifecycle, enabling asynchronous DOM updates.</li> </ul> </li> </ol> <p>Essentially, Hydrator bridges the gap between various components within the Zenaura framework, facilitating seamless communication and efficient DOM manipulation.</p> Source code in <code>zenaura\\client\\hydrator\\hydrator.py</code> <pre><code>class Hydrator(\n    HydratorVirtualDomAdapter,\n    HydratorCompilerAdapter,\n    HydratorRealDomAdapter,\n    HydratorTasker\n):\n    \"\"\"\n    Hydrator acts as the central communication hub between:\n\n    1. **Virtual DOM and Compiler:**\n        - Methods interacting with the compiler start with `hyd_comp_`, e.g., `hyd_comp_get_keyed_uuid`, `hyd_comp_compile_node`.\n    2. **Virtual DOM:**\n        - Methods interacting with Zenaura's virtual DOM start with `hyd_vdom_`, e.g., `hyd_vdom_update`, `hyd_vdom_delete`.\n    3. **DOM:**\n        - Methods interacting with the DOM start with `hyd_dom_`, e.g., `hyd_rdom_attach_to_root`.\n    4. **Tasker:**\n        - Tasks for updating the DOM are created in the updater and dequeued during the render lifecycle, enabling asynchronous DOM updates.\n\n    Essentially, Hydrator bridges the gap between various components within the Zenaura framework, facilitating seamless communication and efficient DOM manipulation.\n    \"\"\"\n</code></pre>"},{"location":"api/client/hydrator/lookup/","title":"Lookup Table","text":""},{"location":"api/client/hydrator/lookup/#zenaura.client.hydrator.lookup.VDomLookupTable","title":"<code>VDomLookupTable</code>","text":"<p>VDomLookupTable:</p> <p>This class manages two lookup tables:</p> <ol> <li> <p>zen_dom_table:</p> <ul> <li>Optimizes general tree structure by storing each component's unique ID and its children with the <code>ZENAURA_DOM_ATTRIBUTE</code>.</li> <li>Provides efficient operations:<ul> <li>Searching for mounted component's previous state: O(1)</li> <li>Deleting unmounted components: O(1)</li> <li>Inserting mounted components: O(1)</li> </ul> </li> <li>Applies the same time complexity to tree structure operations:<ul> <li>Search: O(n)</li> <li>Insert: O(n)</li> <li>Delete: O(n)</li> <li>Update: O(n)</li> </ul> </li> <li>Enables efficient memory management by deleting all components when a page is unmounted.</li> </ul> </li> <li> <p>zenaura_prev_page_instance:</p> <ul> <li>Stores the previously mounted page instance.</li> <li>Leverages Zenaura's single-page mounting (per route path) for efficient memory management.</li> <li>When a new page is mounted:<ul> <li>Retrieves the previous page instance.</li> <li>Iterates over its components and deletes them from <code>zen_dom_table</code>.</li> </ul> </li> </ul> </li> </ol> Source code in <code>zenaura\\client\\hydrator\\lookup.py</code> <pre><code>class VDomLookupTable:\n    \"\"\"\n        VDomLookupTable:\n\n        This class manages two lookup tables:\n\n        1. **zen_dom_table**:\n            - Optimizes general tree structure by storing each component's unique ID and its children with the `ZENAURA_DOM_ATTRIBUTE`.\n            - Provides efficient operations:\n                - Searching for mounted component's previous state: O(1)\n                - Deleting unmounted components: O(1)\n                - Inserting mounted components: O(1)\n            - Applies the same time complexity to tree structure operations:\n                - Search: O(n)\n                - Insert: O(n)\n                - Delete: O(n)\n                - Update: O(n)\n            - Enables efficient memory management by deleting all components when a page is unmounted.\n\n        2. **zenaura_prev_page_instance**:\n            - Stores the previously mounted page instance.\n            - Leverages Zenaura's single-page mounting (per route path) for efficient memory management.\n            - When a new page is mounted:\n                - Retrieves the previous page instance.\n                - Iterates over its components and deletes them from `zen_dom_table`.\n\n    \"\"\"\n    zen_dom_table = defaultdict(str)\n    prev_page_instance = None\n    zen_pre_compiled = defaultdict(str)\n</code></pre>"},{"location":"api/client/observer/observer/","title":"Observer","text":""},{"location":"api/client/observer/observer/#zenaura.client.observer.observer.Observer","title":"<code>Observer</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Abstract base class for observers that listen to changes in subjects.</p> <p>Observers are notified when a subject's state changes, allowing them to react accordingly. This pattern promotes loose coupling between subjects and observers, making the system more flexible and maintainable.</p> <p>Key Features:</p> <ul> <li>Loose Coupling: Observers are not directly dependent on the subject's implementation,    allowing for easier modifications and additions.</li> <li>Flexibility: Observers can be easily added or removed without affecting the subject.</li> <li>Maintainability: The separation of concerns makes the code easier to understand and maintain.</li> </ul> <p>Usage:</p> <ol> <li>Define concrete observer classes that inherit from <code>Observer</code>.</li> <li>Implement the <code>update</code> method in each concrete observer to specify the desired behavior when notified.</li> <li>Attach the observers to the subject using the subject's <code>attach</code> method.</li> <li>When the subject's state changes, it will call the <code>update</code> method of all attached observers.</li> </ol> <p>Example:</p> <pre><code>class Subject:\n    def __init__(self):\n        self._observers = []\n\n    def attach(self, observer):\n        self._observers.append(observer)\n\n    def notify(self, value):\n        for observer in self._observers:\n            observer.update(value)\n\nclass ConcreteObserver(Observer):\n    def update(self, value):\n        print(f\"Observer received value: {value}\")\n\n# Create a subject and an observer\nsubject = Subject()\nobserver = ConcreteObserver()\n\n# Attach the observer to the subject\nsubject.attach(observer)\n\n# Notify the observer with a value\nsubject.notify(\"Hello, world!\")\n</code></pre> <p>Additional Notes:</p> <ul> <li>The <code>update</code> method can receive any type of data, depending on the subject's implementation.</li> <li>Observers can choose to ignore notifications if they are not interested in the updated value.</li> <li>The subject can manage multiple observers and notify them individually or in groups.</li> </ul> Source code in <code>zenaura\\client\\observer\\observer.py</code> <pre><code>class Observer(ABC):\n    \"\"\"\n    Abstract base class for observers that listen to changes in subjects.\n\n    Observers are notified when a subject's state changes, allowing them to react accordingly.\n    This pattern promotes loose coupling between subjects and observers, making the system more flexible and maintainable.\n\n    **Key Features:**\n\n    - **Loose Coupling:** Observers are not directly dependent on the subject's implementation, \n      allowing for easier modifications and additions.\n    - **Flexibility:** Observers can be easily added or removed without affecting the subject.\n    - **Maintainability:** The separation of concerns makes the code easier to understand and maintain.\n\n    **Usage:**\n\n    1. Define concrete observer classes that inherit from `Observer`.\n    2. Implement the `update` method in each concrete observer to specify the desired behavior when notified.\n    3. Attach the observers to the subject using the subject's `attach` method.\n    4. When the subject's state changes, it will call the `update` method of all attached observers.\n\n    **Example:**\n\n    ```python\n    class Subject:\n        def __init__(self):\n            self._observers = []\n\n        def attach(self, observer):\n            self._observers.append(observer)\n\n        def notify(self, value):\n            for observer in self._observers:\n                observer.update(value)\n\n    class ConcreteObserver(Observer):\n        def update(self, value):\n            print(f\"Observer received value: {value}\")\n\n    # Create a subject and an observer\n    subject = Subject()\n    observer = ConcreteObserver()\n\n    # Attach the observer to the subject\n    subject.attach(observer)\n\n    # Notify the observer with a value\n    subject.notify(\"Hello, world!\")\n    ```\n\n    **Additional Notes:**\n\n    - The `update` method can receive any type of data, depending on the subject's implementation.\n    - Observers can choose to ignore notifications if they are not interested in the updated value.\n    - The subject can manage multiple observers and notify them individually or in groups.\n    \"\"\"\n\n    @abstractmethod\n    def update(self, value):\n        \"\"\"\n        Update method to be implemented by concrete observers.\n\n        This method is called by the subject when its state changes. The observer can use the provided value\n        to perform any necessary actions, such as updating its own state or triggering other events.\n\n        Parameters:\n        value (dict): The updated value from the subject.\n\n        Returns:\n        None\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/client/observer/observer/#zenaura.client.observer.observer.Observer.update","title":"<code>update(value)</code>  <code>abstractmethod</code>","text":"<p>Update method to be implemented by concrete observers.</p> <p>This method is called by the subject when its state changes. The observer can use the provided value to perform any necessary actions, such as updating its own state or triggering other events.</p> <p>Parameters: value (dict): The updated value from the subject.</p> <p>Returns: None</p> Source code in <code>zenaura\\client\\observer\\observer.py</code> <pre><code>@abstractmethod\ndef update(self, value):\n    \"\"\"\n    Update method to be implemented by concrete observers.\n\n    This method is called by the subject when its state changes. The observer can use the provided value\n    to perform any necessary actions, such as updating its own state or triggering other events.\n\n    Parameters:\n    value (dict): The updated value from the subject.\n\n    Returns:\n    None\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/client/observer/subject/","title":"Subject","text":""},{"location":"api/client/observer/subject/#zenaura.client.observer.subject.Subject","title":"<code>Subject</code>","text":"<p>Create subjects for components to communicate on.</p> <p>A subject is an entity that maintains a state and notifies its observers when the state changes. Observers can be any object that implements the <code>Observer</code> interface.</p> <p>Key Features:</p> <ul> <li>State Management: Subjects maintain their own state and provide access to it through the <code>state</code> property.</li> <li>Observer Management: Subjects manage a list of attached observers and notify them when the state changes.</li> <li>Loose Coupling: Subjects are not directly dependent on the implementation of their observers,    promoting flexibility and maintainability.</li> </ul> <p>Usage:</p> <ol> <li>Create a subject instance.</li> <li>Attach observers to the subject using the <code>attach</code> method.</li> <li>Modify the subject's state using the <code>state</code> property.</li> <li>The subject will automatically notify all attached observers when the state changes.</li> </ol> <p>Example:</p> <pre><code>class ConcreteSubject(Subject):\n    def __init__(self, initial_state):\n        super().__init__()\n        self._state = initial_state\n\n    def do_something(self):\n        # Modify the subject's state\n        self.state = {\"key\": \"value\"}\n\n# Create a subject and an observer\nsubject = ConcreteSubject({\"initial\": \"value\"})\nobserver = Observer()\n\n# Attach the observer to the subject\nsubject.attach(observer)\n\n# Modify the subject's state\nsubject.do_something()\n</code></pre> <p>Additional Notes:</p> <ul> <li>The <code>state</code> property can be any type of data, depending on the subject's implementation.</li> <li>Observers can choose to ignore notifications if they are not interested in the updated state.</li> <li>The subject can manage multiple observers and notify them individually or in groups.</li> </ul> Source code in <code>zenaura\\client\\observer\\subject.py</code> <pre><code>class Subject:\n    \"\"\"\n    Create subjects for components to communicate on.\n\n    A subject is an entity that maintains a state and notifies its observers when the state changes.\n    Observers can be any object that implements the `Observer` interface.\n\n    **Key Features:**\n\n    - **State Management:** Subjects maintain their own state and provide access to it through the `state` property.\n    - **Observer Management:** Subjects manage a list of attached observers and notify them when the state changes.\n    - **Loose Coupling:** Subjects are not directly dependent on the implementation of their observers, \n      promoting flexibility and maintainability.\n\n    **Usage:**\n\n    1. Create a subject instance.\n    2. Attach observers to the subject using the `attach` method.\n    3. Modify the subject's state using the `state` property.\n    4. The subject will automatically notify all attached observers when the state changes.\n\n    **Example:**\n\n    ```python\n    class ConcreteSubject(Subject):\n        def __init__(self, initial_state):\n            super().__init__()\n            self._state = initial_state\n\n        def do_something(self):\n            # Modify the subject's state\n            self.state = {\"key\": \"value\"}\n\n    # Create a subject and an observer\n    subject = ConcreteSubject({\"initial\": \"value\"})\n    observer = Observer()\n\n    # Attach the observer to the subject\n    subject.attach(observer)\n\n    # Modify the subject's state\n    subject.do_something()\n    ```\n\n    **Additional Notes:**\n\n    - The `state` property can be any type of data, depending on the subject's implementation.\n    - Observers can choose to ignore notifications if they are not interested in the updated state.\n    - The subject can manage multiple observers and notify them individually or in groups.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize a new Subject.\n\n        Parameters:\n        None\n\n        Returns:\n        None\n        \"\"\"\n        self._observers = set()\n        self._state = {}\n\n    def attach(self, observer):\n        \"\"\"\n        Attach an observer to the subject.\n\n        Parameters:\n        observer (Observer): The observer to attach.\n\n        Returns:\n        None\n        \"\"\"\n        self._observers.add(observer)\n\n    def detach(self, observer):\n        \"\"\"\n        Detach an observer from the subject.\n\n        Parameters:\n        observer (Observer): The observer to detach.\n\n        Returns:\n        None\n        \"\"\"\n        self._observers.discard(observer)\n\n    def notify(self):\n        \"\"\"\n        Notify all attached observers.\n\n        Parameters:\n        None\n\n        Returns:\n        None\n        \"\"\"\n        for observer in self._observers:\n            observer.update(self._state)\n\n    @property\n    def state(self):\n        \"\"\"\n        Get the state of the subject.\n\n        Parameters:\n        None\n\n        Returns:\n        dict: The state of the subject.\n        \"\"\"\n        return self._state\n\n    @state.setter\n    def state(self, new_value):\n        \"\"\"\n        Set the state of the subject and notify observers.\n\n        Parameters:\n        new_value (dict): The new state of the subject.\n\n        Returns:\n        None\n        \"\"\"\n        self._state = new_value\n        self.notify()\n</code></pre>"},{"location":"api/client/observer/subject/#zenaura.client.observer.subject.Subject.state","title":"<code>state</code>  <code>property</code> <code>writable</code>","text":"<p>Get the state of the subject.</p> <p>Parameters: None</p> <p>Returns: dict: The state of the subject.</p>"},{"location":"api/client/observer/subject/#zenaura.client.observer.subject.Subject.__init__","title":"<code>__init__()</code>","text":"<p>Initialize a new Subject.</p> <p>Parameters: None</p> <p>Returns: None</p> Source code in <code>zenaura\\client\\observer\\subject.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initialize a new Subject.\n\n    Parameters:\n    None\n\n    Returns:\n    None\n    \"\"\"\n    self._observers = set()\n    self._state = {}\n</code></pre>"},{"location":"api/client/observer/subject/#zenaura.client.observer.subject.Subject.attach","title":"<code>attach(observer)</code>","text":"<p>Attach an observer to the subject.</p> <p>Parameters: observer (Observer): The observer to attach.</p> <p>Returns: None</p> Source code in <code>zenaura\\client\\observer\\subject.py</code> <pre><code>def attach(self, observer):\n    \"\"\"\n    Attach an observer to the subject.\n\n    Parameters:\n    observer (Observer): The observer to attach.\n\n    Returns:\n    None\n    \"\"\"\n    self._observers.add(observer)\n</code></pre>"},{"location":"api/client/observer/subject/#zenaura.client.observer.subject.Subject.detach","title":"<code>detach(observer)</code>","text":"<p>Detach an observer from the subject.</p> <p>Parameters: observer (Observer): The observer to detach.</p> <p>Returns: None</p> Source code in <code>zenaura\\client\\observer\\subject.py</code> <pre><code>def detach(self, observer):\n    \"\"\"\n    Detach an observer from the subject.\n\n    Parameters:\n    observer (Observer): The observer to detach.\n\n    Returns:\n    None\n    \"\"\"\n    self._observers.discard(observer)\n</code></pre>"},{"location":"api/client/observer/subject/#zenaura.client.observer.subject.Subject.notify","title":"<code>notify()</code>","text":"<p>Notify all attached observers.</p> <p>Parameters: None</p> <p>Returns: None</p> Source code in <code>zenaura\\client\\observer\\subject.py</code> <pre><code>def notify(self):\n    \"\"\"\n    Notify all attached observers.\n\n    Parameters:\n    None\n\n    Returns:\n    None\n    \"\"\"\n    for observer in self._observers:\n        observer.update(self._state)\n</code></pre>"},{"location":"api/client/tags/attribute/","title":"Attribute","text":""},{"location":"api/client/tags/attribute/#zenaura.client.tags.attribute.Attribute","title":"<code>Attribute</code>","text":"<p>Represents a key-value pair used for tagging entities.</p> <p>Attributes:</p> Name Type Description <code>key</code> <code>str</code> <p>The key of the attribute.</p> <code>value</code> <code>str</code> <p>The value of the attribute.</p> <p>Methods:</p> Name Description <code>to_dict</code> <p>Converts the attribute to a dictionary representation.</p> Source code in <code>zenaura\\client\\tags\\attribute.py</code> <pre><code>class Attribute:\n    \"\"\"\n    Represents a key-value pair used for tagging entities.\n\n    Attributes:\n        key (str): The key of the attribute.\n        value (str): The value of the attribute.\n\n    Methods:\n        to_dict(): Converts the attribute to a dictionary representation.\n    \"\"\"\n\n    def __init__(self, key, value):\n        \"\"\"\n        Initializes an Attribute object with the given key and value.\n\n        Args:\n            key (str): The key of the attribute.\n            value (str): The value of the attribute.\n        \"\"\"\n        self.key = key\n        self.value = value\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Returns a dictionary representation of the attribute.\n\n        Returns:\n            dict: A dictionary containing the key and value of the attribute.\n        \"\"\"\n        return {\n            \"key\": self.key,\n            \"value\": self.value\n        }\n</code></pre>"},{"location":"api/client/tags/attribute/#zenaura.client.tags.attribute.Attribute.__init__","title":"<code>__init__(key, value)</code>","text":"<p>Initializes an Attribute object with the given key and value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the attribute.</p> required <code>value</code> <code>str</code> <p>The value of the attribute.</p> required Source code in <code>zenaura\\client\\tags\\attribute.py</code> <pre><code>def __init__(self, key, value):\n    \"\"\"\n    Initializes an Attribute object with the given key and value.\n\n    Args:\n        key (str): The key of the attribute.\n        value (str): The value of the attribute.\n    \"\"\"\n    self.key = key\n    self.value = value\n</code></pre>"},{"location":"api/client/tags/attribute/#zenaura.client.tags.attribute.Attribute.to_dict","title":"<code>to_dict()</code>","text":"<p>Returns a dictionary representation of the attribute.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the key and value of the attribute.</p> Source code in <code>zenaura\\client\\tags\\attribute.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Returns a dictionary representation of the attribute.\n\n    Returns:\n        dict: A dictionary containing the key and value of the attribute.\n    \"\"\"\n    return {\n        \"key\": self.key,\n        \"value\": self.value\n    }\n</code></pre>"},{"location":"api/client/tags/builder/","title":"Builder","text":""},{"location":"api/client/tags/builder/#zenaura.client.tags.builder.Builder","title":"<code>Builder</code>","text":"<p>A builder class for constructing HTML tags.</p> <p>This class provides a fluent interface for creating HTML tags with attributes, children, and styles. It simplifies the process of building complex HTML structures.</p> <p>Attributes:</p> Name Type Description <code>node</code> <code>Node</code> <p>The root node of the tag being built.</p> Source code in <code>zenaura\\client\\tags\\builder.py</code> <pre><code>class Builder:\n    \"\"\"\n    A builder class for constructing HTML tags.\n\n    This class provides a fluent interface for creating HTML tags with attributes,\n    children, and styles. It simplifies the process of building complex HTML structures.\n\n    Attributes:\n        node (Node): The root node of the tag being built.\n    \"\"\"\n\n    def __init__(self, name: str = \"div\") -&gt; None:\n        \"\"\"\n        Initializes a Builder object with the given tag name.\n\n        Args:\n            name (str, optional): The name of the tag. Defaults to \"div\".\n        \"\"\"\n        self.node = Node(name)\n\n    def with_attributes(self, **kwargs) -&gt; \"Builder\":\n        \"\"\"\n        Adds attributes to the tag.\n\n        Args:\n            **kwargs: Key-value pairs of attributes.\n\n        Returns:\n            Builder: The Builder object.\n        \"\"\"\n        for key, value in kwargs.items():\n            self.with_attribute(key, value)\n        return self\n\n    def with_children(self, *children) -&gt; \"Builder\":\n        \"\"\"\n        Adds child nodes to the tag.\n\n        Args:\n            *children: List of child nodes.\n\n        Returns:\n            Builder: The Builder object.\n        \"\"\"\n        for child in children:\n            self.with_child(child)\n        return self\n\n    def with_attribute(self, key: str, value: any) -&gt; \"Builder\":\n        \"\"\"\n        Adds an attribute to the tag.\n\n        Args:\n            key (str): The key of the attribute.\n            value: The value of the attribute.\n\n        Returns:\n            Builder: The Builder object.\n        \"\"\"\n        self.node.attributes.append(Attribute(key, value))\n        return self\n\n    def with_child(self, child: Node) -&gt; \"Builder\":\n        \"\"\"\n        Adds a child node to the tag.\n\n        Args:\n            child (Node): The child node to be added.\n\n        Returns:\n            Builder: The Builder object.\n        \"\"\"\n        self.node.append_child(child)\n        return self\n\n    def with_styles(self, styles: dict) -&gt; \"Builder\":\n        \"\"\"\n        Adds styles to the tag.\n\n        Args:\n            styles (dict): Dictionary of styles.\n\n        Returns:\n            Builder: The Builder object.\n        \"\"\"\n        style_str = \";\".join([f\"{k}:{v}\" for k, v in styles.items()])\n        self.node.attributes.append(Attribute(\"style\", style_str))\n        return self\n\n    def with_classes(self, *class_names: str) -&gt; \"Builder\":\n        \"\"\"\n        Adds multiple class names to the element.\n\n        Args:\n            *class_names (str): Variable number of class names.\n\n        Returns:\n            Builder: The Builder object.\n        \"\"\"\n        for class_name in class_names:\n            self.with_class(class_name)\n        return self\n\n    def with_class(self, class_name: str) -&gt; \"Builder\":\n        \"\"\"\n        Adds a single class name to the element.\n\n        Args:\n            class_name (str): The class name to be added.\n\n        Returns:\n            Builder: The Builder object.\n        \"\"\"\n        for i in self.node.attributes:\n            if i.key == \"class\":\n                if class_name not in i.value:\n                    i.value = i.value + \" \" + class_name\n                    return self\n        self.node.attributes.append(Attribute(\"class\", class_name))\n\n        return self\n\n    def with_class_if(self, class_name: str, condition: bool) -&gt; \"Builder\":\n        \"\"\"\n        Adds a class name to the element if the condition is True.\n        If the condition is False, the class is not added.\n\n        args:\n            class_name (str): The class name to be added.\n            condition (bool): The condition for adding the class.\n        \"\"\"\n        self.with_class(class_name) if condition else None\n        return self\n\n    def with_attribute_if(self, key: str, value: any, condition: bool) -&gt; \"Builder\":\n        \"\"\"\n            adds attribute if condition is true\n            args:\n            key (str): The key of the attribute.\n            value: The value of the attribute.\n            condition (bool): The condition for adding the attribute.\n        \"\"\"\n        self.with_attribute(key, value) if condition else None\n        return self\n\n    def with_child_if(self, child: Node, condition: bool) -&gt; \"Builder\":\n        \"\"\"\n            adds child if condition is true\n            args:\n            child (Node): The child node to be added.\n            condition (bool): The condition for adding the child.\n        \"\"\"\n        self.with_child(child) if condition else None\n        return self\n\n    def with_text(self, text: str):\n        \"\"\"\n            add text node\n        \"\"\"\n        self.with_child(Node(text=text))\n        return self\n\n    def build(self) -&gt; Node:\n        \"\"\"\n        Builds and returns the node.\n\n        Returns:\n            Node: The built node.\n        \"\"\"\n        return self.node\n</code></pre>"},{"location":"api/client/tags/builder/#zenaura.client.tags.builder.Builder.__init__","title":"<code>__init__(name='div')</code>","text":"<p>Initializes a Builder object with the given tag name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the tag. Defaults to \"div\".</p> <code>'div'</code> Source code in <code>zenaura\\client\\tags\\builder.py</code> <pre><code>def __init__(self, name: str = \"div\") -&gt; None:\n    \"\"\"\n    Initializes a Builder object with the given tag name.\n\n    Args:\n        name (str, optional): The name of the tag. Defaults to \"div\".\n    \"\"\"\n    self.node = Node(name)\n</code></pre>"},{"location":"api/client/tags/builder/#zenaura.client.tags.builder.Builder.build","title":"<code>build()</code>","text":"<p>Builds and returns the node.</p> <p>Returns:</p> Name Type Description <code>Node</code> <code>Node</code> <p>The built node.</p> Source code in <code>zenaura\\client\\tags\\builder.py</code> <pre><code>def build(self) -&gt; Node:\n    \"\"\"\n    Builds and returns the node.\n\n    Returns:\n        Node: The built node.\n    \"\"\"\n    return self.node\n</code></pre>"},{"location":"api/client/tags/builder/#zenaura.client.tags.builder.Builder.with_attribute","title":"<code>with_attribute(key, value)</code>","text":"<p>Adds an attribute to the tag.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the attribute.</p> required <code>value</code> <code>any</code> <p>The value of the attribute.</p> required <p>Returns:</p> Name Type Description <code>Builder</code> <code>Builder</code> <p>The Builder object.</p> Source code in <code>zenaura\\client\\tags\\builder.py</code> <pre><code>def with_attribute(self, key: str, value: any) -&gt; \"Builder\":\n    \"\"\"\n    Adds an attribute to the tag.\n\n    Args:\n        key (str): The key of the attribute.\n        value: The value of the attribute.\n\n    Returns:\n        Builder: The Builder object.\n    \"\"\"\n    self.node.attributes.append(Attribute(key, value))\n    return self\n</code></pre>"},{"location":"api/client/tags/builder/#zenaura.client.tags.builder.Builder.with_attribute_if","title":"<code>with_attribute_if(key, value, condition)</code>","text":"<p>adds attribute if condition is true args: key (str): The key of the attribute. value: The value of the attribute. condition (bool): The condition for adding the attribute.</p> Source code in <code>zenaura\\client\\tags\\builder.py</code> <pre><code>def with_attribute_if(self, key: str, value: any, condition: bool) -&gt; \"Builder\":\n    \"\"\"\n        adds attribute if condition is true\n        args:\n        key (str): The key of the attribute.\n        value: The value of the attribute.\n        condition (bool): The condition for adding the attribute.\n    \"\"\"\n    self.with_attribute(key, value) if condition else None\n    return self\n</code></pre>"},{"location":"api/client/tags/builder/#zenaura.client.tags.builder.Builder.with_attributes","title":"<code>with_attributes(**kwargs)</code>","text":"<p>Adds attributes to the tag.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Key-value pairs of attributes.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Builder</code> <code>Builder</code> <p>The Builder object.</p> Source code in <code>zenaura\\client\\tags\\builder.py</code> <pre><code>def with_attributes(self, **kwargs) -&gt; \"Builder\":\n    \"\"\"\n    Adds attributes to the tag.\n\n    Args:\n        **kwargs: Key-value pairs of attributes.\n\n    Returns:\n        Builder: The Builder object.\n    \"\"\"\n    for key, value in kwargs.items():\n        self.with_attribute(key, value)\n    return self\n</code></pre>"},{"location":"api/client/tags/builder/#zenaura.client.tags.builder.Builder.with_child","title":"<code>with_child(child)</code>","text":"<p>Adds a child node to the tag.</p> <p>Parameters:</p> Name Type Description Default <code>child</code> <code>Node</code> <p>The child node to be added.</p> required <p>Returns:</p> Name Type Description <code>Builder</code> <code>Builder</code> <p>The Builder object.</p> Source code in <code>zenaura\\client\\tags\\builder.py</code> <pre><code>def with_child(self, child: Node) -&gt; \"Builder\":\n    \"\"\"\n    Adds a child node to the tag.\n\n    Args:\n        child (Node): The child node to be added.\n\n    Returns:\n        Builder: The Builder object.\n    \"\"\"\n    self.node.append_child(child)\n    return self\n</code></pre>"},{"location":"api/client/tags/builder/#zenaura.client.tags.builder.Builder.with_child_if","title":"<code>with_child_if(child, condition)</code>","text":"<p>adds child if condition is true args: child (Node): The child node to be added. condition (bool): The condition for adding the child.</p> Source code in <code>zenaura\\client\\tags\\builder.py</code> <pre><code>def with_child_if(self, child: Node, condition: bool) -&gt; \"Builder\":\n    \"\"\"\n        adds child if condition is true\n        args:\n        child (Node): The child node to be added.\n        condition (bool): The condition for adding the child.\n    \"\"\"\n    self.with_child(child) if condition else None\n    return self\n</code></pre>"},{"location":"api/client/tags/builder/#zenaura.client.tags.builder.Builder.with_children","title":"<code>with_children(*children)</code>","text":"<p>Adds child nodes to the tag.</p> <p>Parameters:</p> Name Type Description Default <code>*children</code> <p>List of child nodes.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Builder</code> <code>Builder</code> <p>The Builder object.</p> Source code in <code>zenaura\\client\\tags\\builder.py</code> <pre><code>def with_children(self, *children) -&gt; \"Builder\":\n    \"\"\"\n    Adds child nodes to the tag.\n\n    Args:\n        *children: List of child nodes.\n\n    Returns:\n        Builder: The Builder object.\n    \"\"\"\n    for child in children:\n        self.with_child(child)\n    return self\n</code></pre>"},{"location":"api/client/tags/builder/#zenaura.client.tags.builder.Builder.with_class","title":"<code>with_class(class_name)</code>","text":"<p>Adds a single class name to the element.</p> <p>Parameters:</p> Name Type Description Default <code>class_name</code> <code>str</code> <p>The class name to be added.</p> required <p>Returns:</p> Name Type Description <code>Builder</code> <code>Builder</code> <p>The Builder object.</p> Source code in <code>zenaura\\client\\tags\\builder.py</code> <pre><code>def with_class(self, class_name: str) -&gt; \"Builder\":\n    \"\"\"\n    Adds a single class name to the element.\n\n    Args:\n        class_name (str): The class name to be added.\n\n    Returns:\n        Builder: The Builder object.\n    \"\"\"\n    for i in self.node.attributes:\n        if i.key == \"class\":\n            if class_name not in i.value:\n                i.value = i.value + \" \" + class_name\n                return self\n    self.node.attributes.append(Attribute(\"class\", class_name))\n\n    return self\n</code></pre>"},{"location":"api/client/tags/builder/#zenaura.client.tags.builder.Builder.with_class_if","title":"<code>with_class_if(class_name, condition)</code>","text":"<p>Adds a class name to the element if the condition is True. If the condition is False, the class is not added.</p> <p>Parameters:</p> Name Type Description Default <code>class_name</code> <code>str</code> <p>The class name to be added.</p> required <code>condition</code> <code>bool</code> <p>The condition for adding the class.</p> required Source code in <code>zenaura\\client\\tags\\builder.py</code> <pre><code>def with_class_if(self, class_name: str, condition: bool) -&gt; \"Builder\":\n    \"\"\"\n    Adds a class name to the element if the condition is True.\n    If the condition is False, the class is not added.\n\n    args:\n        class_name (str): The class name to be added.\n        condition (bool): The condition for adding the class.\n    \"\"\"\n    self.with_class(class_name) if condition else None\n    return self\n</code></pre>"},{"location":"api/client/tags/builder/#zenaura.client.tags.builder.Builder.with_classes","title":"<code>with_classes(*class_names)</code>","text":"<p>Adds multiple class names to the element.</p> <p>Parameters:</p> Name Type Description Default <code>*class_names</code> <code>str</code> <p>Variable number of class names.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Builder</code> <code>Builder</code> <p>The Builder object.</p> Source code in <code>zenaura\\client\\tags\\builder.py</code> <pre><code>def with_classes(self, *class_names: str) -&gt; \"Builder\":\n    \"\"\"\n    Adds multiple class names to the element.\n\n    Args:\n        *class_names (str): Variable number of class names.\n\n    Returns:\n        Builder: The Builder object.\n    \"\"\"\n    for class_name in class_names:\n        self.with_class(class_name)\n    return self\n</code></pre>"},{"location":"api/client/tags/builder/#zenaura.client.tags.builder.Builder.with_styles","title":"<code>with_styles(styles)</code>","text":"<p>Adds styles to the tag.</p> <p>Parameters:</p> Name Type Description Default <code>styles</code> <code>dict</code> <p>Dictionary of styles.</p> required <p>Returns:</p> Name Type Description <code>Builder</code> <code>Builder</code> <p>The Builder object.</p> Source code in <code>zenaura\\client\\tags\\builder.py</code> <pre><code>def with_styles(self, styles: dict) -&gt; \"Builder\":\n    \"\"\"\n    Adds styles to the tag.\n\n    Args:\n        styles (dict): Dictionary of styles.\n\n    Returns:\n        Builder: The Builder object.\n    \"\"\"\n    style_str = \";\".join([f\"{k}:{v}\" for k, v in styles.items()])\n    self.node.attributes.append(Attribute(\"style\", style_str))\n    return self\n</code></pre>"},{"location":"api/client/tags/builder/#zenaura.client.tags.builder.Builder.with_text","title":"<code>with_text(text)</code>","text":"<p>add text node</p> Source code in <code>zenaura\\client\\tags\\builder.py</code> <pre><code>def with_text(self, text: str):\n    \"\"\"\n        add text node\n    \"\"\"\n    self.with_child(Node(text=text))\n    return self\n</code></pre>"},{"location":"api/client/tags/html/","title":"Html","text":""},{"location":"api/client/tags/html/#zenaura.client.tags.html.HTMLElement","title":"<code>HTMLElement</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Abstract base class representing an HTML element.</p> <p>This class defines the common interface for all HTML elements, providing methods for manipulating child elements.</p> <p>Methods:</p> Name Description <code>appendChild</code> <p>HTMLElement) -&gt; None: Appends a child element to the current element.</p> <code>removeChild</code> <p>HTMLElement) -&gt; None: Removes a child element from the current element.</p> Source code in <code>zenaura\\client\\tags\\html.py</code> <pre><code>class HTMLElement(ABC):\n    \"\"\"\n    Abstract base class representing an HTML element.\n\n    This class defines the common interface for all HTML elements,\n    providing methods for manipulating child elements.\n\n    Attributes:\n        None\n\n    Methods:\n        appendChild(child: HTMLElement) -&gt; None:\n            Appends a child element to the current element.\n        removeChild(child: HTMLElement) -&gt; None:\n            Removes a child element from the current element.\n    \"\"\"\n\n    @abstractmethod\n    def appendChild(self, child: \"HTMLElement\") -&gt; None:\n        \"\"\"\n        Appends a child element to the current element.\n\n        Args:\n            child: The child element to be appended.\n\n        Raises:\n            TypeError: If the provided child is not an instance of `HTMLElement`.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def removeChild(self, child: \"HTMLElement\") -&gt; None:\n        \"\"\"\n        Removes a child element from the current element.\n\n        Args:\n            child: The child element to be removed.\n\n        Raises:\n            TypeError: If the provided child is not an instance of `HTMLElement`.\n            ValueError: If the provided child is not a child of the current element.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/client/tags/html/#zenaura.client.tags.html.HTMLElement.appendChild","title":"<code>appendChild(child)</code>  <code>abstractmethod</code>","text":"<p>Appends a child element to the current element.</p> <p>Parameters:</p> Name Type Description Default <code>child</code> <code>HTMLElement</code> <p>The child element to be appended.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the provided child is not an instance of <code>HTMLElement</code>.</p> Source code in <code>zenaura\\client\\tags\\html.py</code> <pre><code>@abstractmethod\ndef appendChild(self, child: \"HTMLElement\") -&gt; None:\n    \"\"\"\n    Appends a child element to the current element.\n\n    Args:\n        child: The child element to be appended.\n\n    Raises:\n        TypeError: If the provided child is not an instance of `HTMLElement`.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/client/tags/html/#zenaura.client.tags.html.HTMLElement.removeChild","title":"<code>removeChild(child)</code>  <code>abstractmethod</code>","text":"<p>Removes a child element from the current element.</p> <p>Parameters:</p> Name Type Description Default <code>child</code> <code>HTMLElement</code> <p>The child element to be removed.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the provided child is not an instance of <code>HTMLElement</code>.</p> <code>ValueError</code> <p>If the provided child is not a child of the current element.</p> Source code in <code>zenaura\\client\\tags\\html.py</code> <pre><code>@abstractmethod\ndef removeChild(self, child: \"HTMLElement\") -&gt; None:\n    \"\"\"\n    Removes a child element from the current element.\n\n    Args:\n        child: The child element to be removed.\n\n    Raises:\n        TypeError: If the provided child is not an instance of `HTMLElement`.\n        ValueError: If the provided child is not a child of the current element.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/client/tags/node/","title":"Node","text":""},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node","title":"<code>Node</code>","text":"Source code in <code>zenaura\\client\\tags\\node.py</code> <pre><code>class Node:\n    def __init__(\n            self,name : str = None, \n            children: Optional[List[\"Node\"]]=None, \n            attributes : Optional[List[Attribute]]=None,\n            text: str = None,\n            ):\n        \"\"\"\n        Represents an HTML element with attributes, children, and text content.\n\n        Attributes:\n            name (str): The tag name of the element.\n            children (list of Node): The child elements of this node.\n            attributes (list of Attribute): The attributes of this node.\n            text (str, optional): The text content of this node.\n            nodeId (str): A unique identifier for this node.\n            is_leaf (bool): Whether this node has no children.\n            is_text_node (bool): Whether this node represents text content.\n            level (int): The depth of this node in the tree.\n            key (int): A unique identifier for this node within its level.\n            path (str): The path from the root to this node.\n        \"\"\"\n        self._parent = None\n\n        # calculated properties\n        self._level = 0\n        self._key = 0 \n        self._is_leaf = True\n        self._path = \"\"\n\n        self.name = name\n        self._children = children if children else []\n        self.attributes = [] if attributes is None else attributes\n        self.nodeId = uuid.uuid4().hex\n        self.text = text        \n        # calculated proerty depends on children, text\n        self._is_text_node = isinstance(self.text, str)\n        update_root_properties(self)\n\n    @property\n    def level(self):\n        return self._level\n\n    @level.setter\n    def level(self, new_level):\n        self._level = new_level\n\n    @property\n    def is_leaf(self):\n        return self._is_leaf\n\n    @is_leaf.setter\n    def is_leaf(self, new_is_leaf):\n        self._is_leaf = new_is_leaf\n\n    @property\n    def key(self):\n        return self._key\n\n    @key.setter\n    def key(self, new_key):\n        self._key = new_key\n\n    @property\n    def path(self):\n        return self._path\n\n    @path.setter\n    def path(self, new_path):\n        self._path = new_path\n\n    @property\n    def is_text_node(self):\n        return self._is_text_node\n\n    @is_text_node.setter\n    def is_text_node(self, new_is_text_node):\n        self._is_text_node = new_is_text_node\n\n    @property\n    def parent(self):\n        \"\"\"Read-only property referencing the node's parent.\"\"\"\n        return self._parent\n\n    @parent.setter\n    def parent(self, new_parent):\n        self._parent = new_parent\n\n    @property\n    def children(self):\n        return self._children\n\n    @children.setter\n    def children(self, new_children):\n        \"\"\"Intercept assignment to update child relationships\"\"\"\n        self._children = new_children\n        update_root_properties(self)\n\n    def append_child(self, child):\n        \"\"\"\n        Adds a child node to this node.\n\n        Args:\n            child (Node or str): The child node to add. If a string is provided,\n                it will be converted to a text node.\n        \"\"\"\n        if isinstance(child, str):\n            child = Node(text=child)\n            child.is_text_node = True\n        self.children.append(child)\n        update_root_properties(self)\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Converts this node and its children into a nested dictionary representation.\n\n        Returns:\n            dict: A dictionary representing the node and its children.\n        \"\"\"\n        return {\n            \"name\": self.name,\n            \"parent\": self.parent.name if self.parent else \"none\",\n            \"level\" : self.level,\n            \"key\": self.key,\n            \"path\": self.path,\n            \"children\": [child.to_dict() if isinstance(child, Node) else child for child in self.children],\n        }\n\n    def getAttributes(self, node) -&gt; List[Attribute]:\n        attrs = []\n        for attr in node.attributes:\n            attrs.append(f' {attr.key}=\"{attr.value}\"')\n        return \"\".join(attrs)\n\n    def to_html(self) -&gt; str:\n        \"\"\"\n        Converts this node and its children into an HTML string.\n\n        Returns:\n            str: The HTML representation of the node and its children.\n        \"\"\"\n        if self.name in self_closing_tags:\n            return f\"&lt;{self.name}{self.getAttributes(self)}&gt;\"\n\n        html = f\"&lt;{self.name}\"\n        html += f\"{self.getAttributes(self)}\"\n        html += \"&gt;\"\n        for child in self.children:\n            if child.is_text_node:\n                html += child.text\n            elif isinstance(child, Node):\n                html += child.to_html()\n            else:\n                html += str(child)\n        html += f\"&lt;/{self.name}&gt;\"\n        return html\n\n    def findChildByName(self, name : str) -&gt; \"Node\":\n        \"\"\"\n        Finds a child node with the given name.\n\n        Args:\n            name (str): The name of the child node to find.\n\n        Returns:\n            Node: The child node with the given name, or None if not found.\n        \"\"\"\n        for child in self.children:\n            if isinstance(child, Node):\n                if child.name == name:\n                    return child\n        return None \n\n    def findAllByName(self, name) -&gt; List[\"Node\"]:\n        \"\"\"\n        Finds all child nodes with the given name.\n\n        Args:\n            name (str): The name of the child nodes to find.\n\n        Returns:\n            List[Node]: A list of child nodes with the given name.\n        \"\"\"\n        found = []\n        for child in self.children:\n            if isinstance(child, Node):\n                if child.name == name:\n                    found.append(child)\n\n        return found \n\n    def findByAttribute(self, key : str, value : str) -&gt; \"Node\":\n        \"\"\"\n        Finds a child node with the given attribute key and value.\n\n        Args:\n            key (str): The attribute key to search for.\n            value (str): The attribute value to search for.\n\n        Returns:\n            Node: The child node with the given attribute, or None if not found.\n        \"\"\"\n        found = None\n        for child in self.children:\n            if isinstance(child, Node):\n                for attribute in child.attributes:\n                    if attribute.key == key and attribute.value == value:\n                        return child\n        return found \n\n    def findAllChildrenByAttributeKey(self, key : str) -&gt; List[\"Node\"]:\n        \"\"\"\n        Finds all child nodes with the given attribute key.\n\n        Args:\n            key (str): The attribute key to search for.\n\n        Returns:\n            List[Node]: A list of child nodes with the given attribute key.\n        \"\"\"\n        found = []\n        for child in self.children:\n            if isinstance(child, Node):\n                for attribute in child.attributes:\n                    if attribute.key == key :\n                        found.append(child)\n                        break\n        return found \n\n    def findAllChildrenByAttributeValue(self, value : str) -&gt; List[\"Node\"]:\n        \"\"\"\n        Finds all child nodes with the given attribute value.\n\n        Args:\n            value (str): The attribute value to search for.\n\n        Returns:\n            List[Node]: A list of child nodes with the given attribute value.\n        \"\"\"\n        found = []\n        for child in self.children:\n            if isinstance(child, Node):\n                for attribute in child.attributes:\n                    if attribute.value == value :\n                        found.append(child)\n                        break\n        return found\n\n    def replace(self, oldNode : \"Node\", newNode: \"Node\") -&gt; None:\n        \"\"\"\n        Replaces a child node with a new node.\n\n        Args:\n            oldNode (Node): The node to be replaced.\n            newNode (Node): The new node to replace it with.\n        \"\"\"\n        found = self.getChildIndex(oldNode)\n        if found:\n            self.children[found] = newNode\n\n    def getChildIndex(self,node : \"Node\") -&gt; int :\n        \"\"\"\n        Gets the index of a child node.\n\n        Args:\n            node (Node): The child node to find the index of.\n\n        Returns:\n            int: The index of the child node, or -1 if not found.\n        \"\"\"\n        for idx, child in enumerate(self.children):\n              if isinstance(child, Node):\n                if child.nodeId == node.nodeId:\n                    return idx\n\n    def insertAfter(self, node : \"Node\", newNode : \"Node\") -&gt; None:\n        \"\"\"\n        Inserts a new node after a specific child node.\n\n        Args:\n            node (Node): The child node to insert after.\n            newNode (Node): The new node to insert.\n        \"\"\"\n        foundIdx = self.getChildIndex(node)\n        if foundIdx:\n            self.children.insert(foundIdx + 1, newNode)\n\n    def insertBefore(self, node : \"Node\", newNode : \"Node\") -&gt; None:\n        \"\"\"\n        Inserts a new node before a specific child node.\n\n        Args:\n            node (Node): The child node to insert before.\n            newNode (Node): The new node to insert.\n        \"\"\"\n        foundIdx = self.getChildIndex(node)\n        if foundIdx:\n            self.children.insert(foundIdx, newNode)\n\n    def remove(self, node : \"Node\"):\n        \"\"\"\n        Removes a child node.\n\n        Args:\n            node (Node): The child node to remove.\n        \"\"\"\n        foundIdx = self.getChildIndex(node)\n        if foundIdx:\n            del self.children[foundIdx]\n\n    def appendAttributeToChild(self, node : \"Node\", attribute : \"Attribute\") -&gt; None:\n        \"\"\"\n        Appends an attribute to a child node.\n\n        Args:\n            node (Node): The child node to add the attribute to.\n            attribute (Attribute): The attribute to add.\n        \"\"\"\n        for child in self.children:\n            if isinstance(child, Node):\n                if child.nodeId == node.nodeId:\n                    child.attributes.append(attribute)\n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.parent","title":"<code>parent</code>  <code>property</code> <code>writable</code>","text":"<p>Read-only property referencing the node's parent.</p>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.__init__","title":"<code>__init__(name=None, children=None, attributes=None, text=None)</code>","text":"<p>Represents an HTML element with attributes, children, and text content.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The tag name of the element.</p> <code>children</code> <code>list of Node</code> <p>The child elements of this node.</p> <code>attributes</code> <code>list of Attribute</code> <p>The attributes of this node.</p> <code>text</code> <code>str</code> <p>The text content of this node.</p> <code>nodeId</code> <code>str</code> <p>A unique identifier for this node.</p> <code>is_leaf</code> <code>bool</code> <p>Whether this node has no children.</p> <code>is_text_node</code> <code>bool</code> <p>Whether this node represents text content.</p> <code>level</code> <code>int</code> <p>The depth of this node in the tree.</p> <code>key</code> <code>int</code> <p>A unique identifier for this node within its level.</p> <code>path</code> <code>str</code> <p>The path from the root to this node.</p> Source code in <code>zenaura\\client\\tags\\node.py</code> <pre><code>def __init__(\n        self,name : str = None, \n        children: Optional[List[\"Node\"]]=None, \n        attributes : Optional[List[Attribute]]=None,\n        text: str = None,\n        ):\n    \"\"\"\n    Represents an HTML element with attributes, children, and text content.\n\n    Attributes:\n        name (str): The tag name of the element.\n        children (list of Node): The child elements of this node.\n        attributes (list of Attribute): The attributes of this node.\n        text (str, optional): The text content of this node.\n        nodeId (str): A unique identifier for this node.\n        is_leaf (bool): Whether this node has no children.\n        is_text_node (bool): Whether this node represents text content.\n        level (int): The depth of this node in the tree.\n        key (int): A unique identifier for this node within its level.\n        path (str): The path from the root to this node.\n    \"\"\"\n    self._parent = None\n\n    # calculated properties\n    self._level = 0\n    self._key = 0 \n    self._is_leaf = True\n    self._path = \"\"\n\n    self.name = name\n    self._children = children if children else []\n    self.attributes = [] if attributes is None else attributes\n    self.nodeId = uuid.uuid4().hex\n    self.text = text        \n    # calculated proerty depends on children, text\n    self._is_text_node = isinstance(self.text, str)\n    update_root_properties(self)\n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.appendAttributeToChild","title":"<code>appendAttributeToChild(node, attribute)</code>","text":"<p>Appends an attribute to a child node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>The child node to add the attribute to.</p> required <code>attribute</code> <code>Attribute</code> <p>The attribute to add.</p> required Source code in <code>zenaura\\client\\tags\\node.py</code> <pre><code>def appendAttributeToChild(self, node : \"Node\", attribute : \"Attribute\") -&gt; None:\n    \"\"\"\n    Appends an attribute to a child node.\n\n    Args:\n        node (Node): The child node to add the attribute to.\n        attribute (Attribute): The attribute to add.\n    \"\"\"\n    for child in self.children:\n        if isinstance(child, Node):\n            if child.nodeId == node.nodeId:\n                child.attributes.append(attribute)\n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.append_child","title":"<code>append_child(child)</code>","text":"<p>Adds a child node to this node.</p> <p>Parameters:</p> Name Type Description Default <code>child</code> <code>Node or str</code> <p>The child node to add. If a string is provided, it will be converted to a text node.</p> required Source code in <code>zenaura\\client\\tags\\node.py</code> <pre><code>def append_child(self, child):\n    \"\"\"\n    Adds a child node to this node.\n\n    Args:\n        child (Node or str): The child node to add. If a string is provided,\n            it will be converted to a text node.\n    \"\"\"\n    if isinstance(child, str):\n        child = Node(text=child)\n        child.is_text_node = True\n    self.children.append(child)\n    update_root_properties(self)\n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.findAllByName","title":"<code>findAllByName(name)</code>","text":"<p>Finds all child nodes with the given name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the child nodes to find.</p> required <p>Returns:</p> Type Description <code>List[Node]</code> <p>List[Node]: A list of child nodes with the given name.</p> Source code in <code>zenaura\\client\\tags\\node.py</code> <pre><code>def findAllByName(self, name) -&gt; List[\"Node\"]:\n    \"\"\"\n    Finds all child nodes with the given name.\n\n    Args:\n        name (str): The name of the child nodes to find.\n\n    Returns:\n        List[Node]: A list of child nodes with the given name.\n    \"\"\"\n    found = []\n    for child in self.children:\n        if isinstance(child, Node):\n            if child.name == name:\n                found.append(child)\n\n    return found \n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.findAllChildrenByAttributeKey","title":"<code>findAllChildrenByAttributeKey(key)</code>","text":"<p>Finds all child nodes with the given attribute key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The attribute key to search for.</p> required <p>Returns:</p> Type Description <code>List[Node]</code> <p>List[Node]: A list of child nodes with the given attribute key.</p> Source code in <code>zenaura\\client\\tags\\node.py</code> <pre><code>def findAllChildrenByAttributeKey(self, key : str) -&gt; List[\"Node\"]:\n    \"\"\"\n    Finds all child nodes with the given attribute key.\n\n    Args:\n        key (str): The attribute key to search for.\n\n    Returns:\n        List[Node]: A list of child nodes with the given attribute key.\n    \"\"\"\n    found = []\n    for child in self.children:\n        if isinstance(child, Node):\n            for attribute in child.attributes:\n                if attribute.key == key :\n                    found.append(child)\n                    break\n    return found \n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.findAllChildrenByAttributeValue","title":"<code>findAllChildrenByAttributeValue(value)</code>","text":"<p>Finds all child nodes with the given attribute value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The attribute value to search for.</p> required <p>Returns:</p> Type Description <code>List[Node]</code> <p>List[Node]: A list of child nodes with the given attribute value.</p> Source code in <code>zenaura\\client\\tags\\node.py</code> <pre><code>def findAllChildrenByAttributeValue(self, value : str) -&gt; List[\"Node\"]:\n    \"\"\"\n    Finds all child nodes with the given attribute value.\n\n    Args:\n        value (str): The attribute value to search for.\n\n    Returns:\n        List[Node]: A list of child nodes with the given attribute value.\n    \"\"\"\n    found = []\n    for child in self.children:\n        if isinstance(child, Node):\n            for attribute in child.attributes:\n                if attribute.value == value :\n                    found.append(child)\n                    break\n    return found\n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.findByAttribute","title":"<code>findByAttribute(key, value)</code>","text":"<p>Finds a child node with the given attribute key and value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The attribute key to search for.</p> required <code>value</code> <code>str</code> <p>The attribute value to search for.</p> required <p>Returns:</p> Name Type Description <code>Node</code> <code>Node</code> <p>The child node with the given attribute, or None if not found.</p> Source code in <code>zenaura\\client\\tags\\node.py</code> <pre><code>def findByAttribute(self, key : str, value : str) -&gt; \"Node\":\n    \"\"\"\n    Finds a child node with the given attribute key and value.\n\n    Args:\n        key (str): The attribute key to search for.\n        value (str): The attribute value to search for.\n\n    Returns:\n        Node: The child node with the given attribute, or None if not found.\n    \"\"\"\n    found = None\n    for child in self.children:\n        if isinstance(child, Node):\n            for attribute in child.attributes:\n                if attribute.key == key and attribute.value == value:\n                    return child\n    return found \n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.findChildByName","title":"<code>findChildByName(name)</code>","text":"<p>Finds a child node with the given name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the child node to find.</p> required <p>Returns:</p> Name Type Description <code>Node</code> <code>Node</code> <p>The child node with the given name, or None if not found.</p> Source code in <code>zenaura\\client\\tags\\node.py</code> <pre><code>def findChildByName(self, name : str) -&gt; \"Node\":\n    \"\"\"\n    Finds a child node with the given name.\n\n    Args:\n        name (str): The name of the child node to find.\n\n    Returns:\n        Node: The child node with the given name, or None if not found.\n    \"\"\"\n    for child in self.children:\n        if isinstance(child, Node):\n            if child.name == name:\n                return child\n    return None \n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.getChildIndex","title":"<code>getChildIndex(node)</code>","text":"<p>Gets the index of a child node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>The child node to find the index of.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the child node, or -1 if not found.</p> Source code in <code>zenaura\\client\\tags\\node.py</code> <pre><code>def getChildIndex(self,node : \"Node\") -&gt; int :\n    \"\"\"\n    Gets the index of a child node.\n\n    Args:\n        node (Node): The child node to find the index of.\n\n    Returns:\n        int: The index of the child node, or -1 if not found.\n    \"\"\"\n    for idx, child in enumerate(self.children):\n          if isinstance(child, Node):\n            if child.nodeId == node.nodeId:\n                return idx\n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.insertAfter","title":"<code>insertAfter(node, newNode)</code>","text":"<p>Inserts a new node after a specific child node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>The child node to insert after.</p> required <code>newNode</code> <code>Node</code> <p>The new node to insert.</p> required Source code in <code>zenaura\\client\\tags\\node.py</code> <pre><code>def insertAfter(self, node : \"Node\", newNode : \"Node\") -&gt; None:\n    \"\"\"\n    Inserts a new node after a specific child node.\n\n    Args:\n        node (Node): The child node to insert after.\n        newNode (Node): The new node to insert.\n    \"\"\"\n    foundIdx = self.getChildIndex(node)\n    if foundIdx:\n        self.children.insert(foundIdx + 1, newNode)\n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.insertBefore","title":"<code>insertBefore(node, newNode)</code>","text":"<p>Inserts a new node before a specific child node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>The child node to insert before.</p> required <code>newNode</code> <code>Node</code> <p>The new node to insert.</p> required Source code in <code>zenaura\\client\\tags\\node.py</code> <pre><code>def insertBefore(self, node : \"Node\", newNode : \"Node\") -&gt; None:\n    \"\"\"\n    Inserts a new node before a specific child node.\n\n    Args:\n        node (Node): The child node to insert before.\n        newNode (Node): The new node to insert.\n    \"\"\"\n    foundIdx = self.getChildIndex(node)\n    if foundIdx:\n        self.children.insert(foundIdx, newNode)\n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.remove","title":"<code>remove(node)</code>","text":"<p>Removes a child node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>The child node to remove.</p> required Source code in <code>zenaura\\client\\tags\\node.py</code> <pre><code>def remove(self, node : \"Node\"):\n    \"\"\"\n    Removes a child node.\n\n    Args:\n        node (Node): The child node to remove.\n    \"\"\"\n    foundIdx = self.getChildIndex(node)\n    if foundIdx:\n        del self.children[foundIdx]\n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.replace","title":"<code>replace(oldNode, newNode)</code>","text":"<p>Replaces a child node with a new node.</p> <p>Parameters:</p> Name Type Description Default <code>oldNode</code> <code>Node</code> <p>The node to be replaced.</p> required <code>newNode</code> <code>Node</code> <p>The new node to replace it with.</p> required Source code in <code>zenaura\\client\\tags\\node.py</code> <pre><code>def replace(self, oldNode : \"Node\", newNode: \"Node\") -&gt; None:\n    \"\"\"\n    Replaces a child node with a new node.\n\n    Args:\n        oldNode (Node): The node to be replaced.\n        newNode (Node): The new node to replace it with.\n    \"\"\"\n    found = self.getChildIndex(oldNode)\n    if found:\n        self.children[found] = newNode\n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts this node and its children into a nested dictionary representation.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary representing the node and its children.</p> Source code in <code>zenaura\\client\\tags\\node.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Converts this node and its children into a nested dictionary representation.\n\n    Returns:\n        dict: A dictionary representing the node and its children.\n    \"\"\"\n    return {\n        \"name\": self.name,\n        \"parent\": self.parent.name if self.parent else \"none\",\n        \"level\" : self.level,\n        \"key\": self.key,\n        \"path\": self.path,\n        \"children\": [child.to_dict() if isinstance(child, Node) else child for child in self.children],\n    }\n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.to_html","title":"<code>to_html()</code>","text":"<p>Converts this node and its children into an HTML string.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The HTML representation of the node and its children.</p> Source code in <code>zenaura\\client\\tags\\node.py</code> <pre><code>def to_html(self) -&gt; str:\n    \"\"\"\n    Converts this node and its children into an HTML string.\n\n    Returns:\n        str: The HTML representation of the node and its children.\n    \"\"\"\n    if self.name in self_closing_tags:\n        return f\"&lt;{self.name}{self.getAttributes(self)}&gt;\"\n\n    html = f\"&lt;{self.name}\"\n    html += f\"{self.getAttributes(self)}\"\n    html += \"&gt;\"\n    for child in self.children:\n        if child.is_text_node:\n            html += child.text\n        elif isinstance(child, Node):\n            html += child.to_html()\n        else:\n            html += str(child)\n    html += f\"&lt;/{self.name}&gt;\"\n    return html\n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.NodeList","title":"<code>NodeList</code>","text":"<p>             Bases: <code>list</code></p> <p>Custom list subclass to trigger update on append.</p> Source code in <code>zenaura\\client\\tags\\node.py</code> <pre><code>class NodeList(list):\n    \"\"\"Custom list subclass to trigger update on append.\"\"\"\n\n    def __init__(self, node, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.node = node  # Reference to the parent Node\n\n    def append(self, child):\n        super().append(child)\n        self.node.children = self  # Trigger the setter\n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.update_root_properties","title":"<code>update_root_properties(root)</code>","text":"<p>Upon intialization of a node or setting children This method create infromation rich tree nodes: 1. link children to their parent 2. assign level, key information  3. is_leaf_node, is_text node and so on</p> Source code in <code>zenaura\\client\\tags\\node.py</code> <pre><code>def update_root_properties(root):\n    \"\"\"\n        Upon intialization of a node or setting children\n        This method create infromation rich tree nodes:\n        1. link children to their parent\n        2. assign level, key information \n        3. is_leaf_node, is_text node\n        and so on\n    \"\"\"\n    stack = [(root, None, 0, 0, root.path)] # (node, level_parent, level, index, path)\n\n    while stack :\n        curr, curr.parent, curr.level, curr.key, curr.path   = stack.pop()\n        curr.is_leaf = len(curr.children) == 0\n        for idx, child in enumerate(curr.children):\n            if isinstance(child, str):\n                child = Node(text=child)\n                child.is_text_node = True\n            child.is_leaf = len(child.children) == 0\n            curr.children[idx] = child\n            stack.append((child, child, curr.level + 1, idx, curr.path + str(curr.level) + str(idx)))\n    return root\n</code></pre>"},{"location":"api/server/server/","title":"Server","text":""},{"location":"api/server/server/#zenaura.server.server.DevServer","title":"<code>DevServer</code>","text":"<p>A class for running a development server for Zenaura applications.</p> <p>This class provides methods for:</p> <ul> <li>Starting a Flask server with WebSocket support.</li> <li>Sending refresh signals to connected clients when changes are detected.</li> <li>Hydrating the application and notifying clients when changes are made.</li> <li>Running a file system observer to detect changes in the application files.</li> </ul> Source code in <code>zenaura\\server\\server.py</code> <pre><code>class DevServer:\n    \"\"\"\n    A class for running a development server for Zenaura applications.\n\n    This class provides methods for:\n\n    * Starting a Flask server with WebSocket support.\n    * Sending refresh signals to connected clients when changes are detected.\n    * Hydrating the application and notifying clients when changes are made.\n    * Running a file system observer to detect changes in the application files.\n    \"\"\"\n\n    def __init__(self, app, debug=True, port=5000):\n        \"\"\"\n        Initializes the DevServer class.\n\n        Args:\n            debug (bool, optional): Whether to run the server in debug mode. Defaults to True.\n            port (int, optional): The port on which to run the server. Defaults to 5000.\n        \"\"\"\n\n        self.debug = debug\n        self.port = port\n        self.app = app\n        self.sock = Sock()\n        self.ws_client_list = []\n        self.shutdown_event = Event()\n        self.observer = PausingObserver()\n        self.sock.init_app(self.app)\n        self.loop = asyncio.new_event_loop()\n\n        self.setup_websocket()\n\n    def setup_websocket(self):\n        \"\"\"\n        Sets up the WebSocket route for sending refresh signals to clients.\n        \"\"\"\n\n        @self.sock.route(\"/refresh\")\n        def refresh(ws):\n            \"\"\"\n            WebSocket handler for sending refresh signals to clients.\n\n            Args:\n                ws (WebSocket): The WebSocket connection.\n            \"\"\"\n\n            self.ws_client_list.append(ws)\n            while not self.shutdown_event.is_set():\n                try:\n                    ws.receive()\n                    ws.sleep(1)\n                    ws.send(\"refresh\")\n                except Exception as e:\n                    print(f\"Error in WebSocket connection: {e}\")\n                    break\n\n    def send_refresh_signal(self):\n        \"\"\"\n        Sends a refresh signal to all connected clients.\n        \"\"\"\n\n        logging.info(\"Sending refresh signal...\")\n        clients = self.ws_client_list.copy()\n        for client in clients:\n            try:\n                client.send(\"refresh\")\n            except Exception as e:\n                print(f\"Error sending refresh: {e}\")\n                self.ws_client_list.remove(client)\n\n    def get_change_handler(self):\n        \"\"\"\n        Returns a ChangeHandler class that handles file system events.\n\n        Returns:\n            ChangeHandler: A class that handles file system events.\n        \"\"\"\n\n        DEVSERVER = self\n\n        class ChangeHandler(FileSystemEventHandler):\n            \"\"\"\n            A class that handles file system events.\n\n            This class is used to detect changes in the application files and trigger a refresh of the browser.\n            \"\"\"\n\n            def __init__(self, server):\n                \"\"\"\n                Initializes the ChangeHandler class.\n\n                Args:\n                    server (DevServer): The DevServer instance.\n                \"\"\"\n\n                super().__init__()\n                self.server = server\n\n            def on_any_event(self, event):\n                \"\"\"\n                Handles file system events.\n\n                Args:\n                    event (FileSystemEvent): The file system event.\n                \"\"\"\n\n                try:\n                    logging.info(f\"File {event.src_path} has changed.\")\n                    logging.info(\"Changes are live...\")\n                    DEVSERVER.hydrate_and_notify()\n                    logging.info(\"Reloading browser...\")\n                    DEVSERVER.send_refresh_signal()\n                    logging.info(\"Browser reloaded.\")\n                except Exception as e:\n                    logging.info(f\"Error in ChangeHandler: {e}\")\n\n        return ChangeHandler\n\n    def start_server(self):\n        \"\"\"\n        Starts the Flask server.\n        \"\"\"\n\n        try:\n            self.app.run(debug=self.debug, port=self.port, use_reloader=False)\n        except Exception as e:\n            logging.info(f\"Error starting server: {e}\")\n\n    def hydrate_and_notify(self):\n        \"\"\"\n        Hydrates the application and notifies clients of changes.\n        \"\"\"\n\n        try:\n            self.observer.pause()\n            logging.info(\"Hydrating...\")\n            logging.info(\"Pausing the observer...\")\n            process = subprocess.Popen(\"python build.py\", shell=True)\n            process.communicate()\n            logging.info(\"Hydrated done...\")\n\n        finally:\n            logging.info(\"Running the observer...\")\n            self.observer.resume()\n\n    def run(self):\n        \"\"\"\n        Runs the development server.\n\n        This method starts the Flask server, file system observer, and WebSocket server.\n        \"\"\"\n\n        path = 'public'\n        ChangeHandler = self.get_change_handler()\n        event_handler = ChangeHandler(self)\n        self.observer.schedule(event_handler, path, recursive=True)\n        self.observer.start()\n\n        server_thread = Thread(target=self.start_server, daemon=True)\n        server_thread.start()\n\n        try:\n            while not self.shutdown_event.is_set():\n                time.sleep(0.1)  # Shorter sleep interval\n        except KeyboardInterrupt:\n            logging.info(\"KeyboardInterrupt received, stopping...\")\n        finally:\n            # Faster Shutdown of Observer\n            self.observer.event_queue.queue.clear()\n            self.observer.stop()  \n            self.observer.join()  \n</code></pre>"},{"location":"api/server/server/#zenaura.server.server.DevServer.__init__","title":"<code>__init__(app, debug=True, port=5000)</code>","text":"<p>Initializes the DevServer class.</p> <p>Parameters:</p> Name Type Description Default <code>debug</code> <code>bool</code> <p>Whether to run the server in debug mode. Defaults to True.</p> <code>True</code> <code>port</code> <code>int</code> <p>The port on which to run the server. Defaults to 5000.</p> <code>5000</code> Source code in <code>zenaura\\server\\server.py</code> <pre><code>def __init__(self, app, debug=True, port=5000):\n    \"\"\"\n    Initializes the DevServer class.\n\n    Args:\n        debug (bool, optional): Whether to run the server in debug mode. Defaults to True.\n        port (int, optional): The port on which to run the server. Defaults to 5000.\n    \"\"\"\n\n    self.debug = debug\n    self.port = port\n    self.app = app\n    self.sock = Sock()\n    self.ws_client_list = []\n    self.shutdown_event = Event()\n    self.observer = PausingObserver()\n    self.sock.init_app(self.app)\n    self.loop = asyncio.new_event_loop()\n\n    self.setup_websocket()\n</code></pre>"},{"location":"api/server/server/#zenaura.server.server.DevServer.get_change_handler","title":"<code>get_change_handler()</code>","text":"<p>Returns a ChangeHandler class that handles file system events.</p> <p>Returns:</p> Name Type Description <code>ChangeHandler</code> <p>A class that handles file system events.</p> Source code in <code>zenaura\\server\\server.py</code> <pre><code>def get_change_handler(self):\n    \"\"\"\n    Returns a ChangeHandler class that handles file system events.\n\n    Returns:\n        ChangeHandler: A class that handles file system events.\n    \"\"\"\n\n    DEVSERVER = self\n\n    class ChangeHandler(FileSystemEventHandler):\n        \"\"\"\n        A class that handles file system events.\n\n        This class is used to detect changes in the application files and trigger a refresh of the browser.\n        \"\"\"\n\n        def __init__(self, server):\n            \"\"\"\n            Initializes the ChangeHandler class.\n\n            Args:\n                server (DevServer): The DevServer instance.\n            \"\"\"\n\n            super().__init__()\n            self.server = server\n\n        def on_any_event(self, event):\n            \"\"\"\n            Handles file system events.\n\n            Args:\n                event (FileSystemEvent): The file system event.\n            \"\"\"\n\n            try:\n                logging.info(f\"File {event.src_path} has changed.\")\n                logging.info(\"Changes are live...\")\n                DEVSERVER.hydrate_and_notify()\n                logging.info(\"Reloading browser...\")\n                DEVSERVER.send_refresh_signal()\n                logging.info(\"Browser reloaded.\")\n            except Exception as e:\n                logging.info(f\"Error in ChangeHandler: {e}\")\n\n    return ChangeHandler\n</code></pre>"},{"location":"api/server/server/#zenaura.server.server.DevServer.hydrate_and_notify","title":"<code>hydrate_and_notify()</code>","text":"<p>Hydrates the application and notifies clients of changes.</p> Source code in <code>zenaura\\server\\server.py</code> <pre><code>def hydrate_and_notify(self):\n    \"\"\"\n    Hydrates the application and notifies clients of changes.\n    \"\"\"\n\n    try:\n        self.observer.pause()\n        logging.info(\"Hydrating...\")\n        logging.info(\"Pausing the observer...\")\n        process = subprocess.Popen(\"python build.py\", shell=True)\n        process.communicate()\n        logging.info(\"Hydrated done...\")\n\n    finally:\n        logging.info(\"Running the observer...\")\n        self.observer.resume()\n</code></pre>"},{"location":"api/server/server/#zenaura.server.server.DevServer.run","title":"<code>run()</code>","text":"<p>Runs the development server.</p> <p>This method starts the Flask server, file system observer, and WebSocket server.</p> Source code in <code>zenaura\\server\\server.py</code> <pre><code>def run(self):\n    \"\"\"\n    Runs the development server.\n\n    This method starts the Flask server, file system observer, and WebSocket server.\n    \"\"\"\n\n    path = 'public'\n    ChangeHandler = self.get_change_handler()\n    event_handler = ChangeHandler(self)\n    self.observer.schedule(event_handler, path, recursive=True)\n    self.observer.start()\n\n    server_thread = Thread(target=self.start_server, daemon=True)\n    server_thread.start()\n\n    try:\n        while not self.shutdown_event.is_set():\n            time.sleep(0.1)  # Shorter sleep interval\n    except KeyboardInterrupt:\n        logging.info(\"KeyboardInterrupt received, stopping...\")\n    finally:\n        # Faster Shutdown of Observer\n        self.observer.event_queue.queue.clear()\n        self.observer.stop()  \n        self.observer.join()  \n</code></pre>"},{"location":"api/server/server/#zenaura.server.server.DevServer.send_refresh_signal","title":"<code>send_refresh_signal()</code>","text":"<p>Sends a refresh signal to all connected clients.</p> Source code in <code>zenaura\\server\\server.py</code> <pre><code>def send_refresh_signal(self):\n    \"\"\"\n    Sends a refresh signal to all connected clients.\n    \"\"\"\n\n    logging.info(\"Sending refresh signal...\")\n    clients = self.ws_client_list.copy()\n    for client in clients:\n        try:\n            client.send(\"refresh\")\n        except Exception as e:\n            print(f\"Error sending refresh: {e}\")\n            self.ws_client_list.remove(client)\n</code></pre>"},{"location":"api/server/server/#zenaura.server.server.DevServer.setup_websocket","title":"<code>setup_websocket()</code>","text":"<p>Sets up the WebSocket route for sending refresh signals to clients.</p> Source code in <code>zenaura\\server\\server.py</code> <pre><code>def setup_websocket(self):\n    \"\"\"\n    Sets up the WebSocket route for sending refresh signals to clients.\n    \"\"\"\n\n    @self.sock.route(\"/refresh\")\n    def refresh(ws):\n        \"\"\"\n        WebSocket handler for sending refresh signals to clients.\n\n        Args:\n            ws (WebSocket): The WebSocket connection.\n        \"\"\"\n\n        self.ws_client_list.append(ws)\n        while not self.shutdown_event.is_set():\n            try:\n                ws.receive()\n                ws.sleep(1)\n                ws.send(\"refresh\")\n            except Exception as e:\n                print(f\"Error in WebSocket connection: {e}\")\n                break\n</code></pre>"},{"location":"api/server/server/#zenaura.server.server.DevServer.start_server","title":"<code>start_server()</code>","text":"<p>Starts the Flask server.</p> Source code in <code>zenaura\\server\\server.py</code> <pre><code>def start_server(self):\n    \"\"\"\n    Starts the Flask server.\n    \"\"\"\n\n    try:\n        self.app.run(debug=self.debug, port=self.port, use_reloader=False)\n    except Exception as e:\n        logging.info(f\"Error starting server: {e}\")\n</code></pre>"},{"location":"api/server/server/#zenaura.server.server.ZenauraServer","title":"<code>ZenauraServer</code>","text":"<p>A class for server-side rendering of Zenaura applications.</p> <p>This class provides methods for:</p> <ul> <li>Hydrating Zenaura pages for server-side rendering.</li> <li>Hydrating Zenaura apps for server-side rendering.</li> <li>Generating the HTML structure of a Zenaura page.</li> </ul> Source code in <code>zenaura\\server\\server.py</code> <pre><code>class ZenauraServer:\n    \"\"\"\n    A class for server-side rendering of Zenaura applications.\n\n    This class provides methods for:\n\n    * Hydrating Zenaura pages for server-side rendering.\n    * Hydrating Zenaura apps for server-side rendering.\n    * Generating the HTML structure of a Zenaura page.\n    \"\"\"\n\n    @staticmethod\n    def hydrate_page(page: Page, title=\"zenaura\", meta_description=\"this app created with zenaura\", icon=\"./public/favicon.ico\", pydide=\"https://pyscript.net/releases/2024.1.1/core.js\") -&gt; str:\n        \"\"\"\n        Hydrates a Zenaura page for server-side rendering.\n\n        This method compiles the page's components using the HydratorCompilerAdapter and generates the HTML structure of the page.\n\n        Args:\n            page (Page): The Zenaura page to be hydrated.\n            title (str, optional): The title of the page. Defaults to \"zenaura\".\n            meta_description (str, optional): The meta description of the page. Defaults to \"this app created with zenaura\".\n            icon (str, optional): The URL of the favicon. Defaults to \"./public/favicon.ico\".\n            pydide (str, optional): The URL of the PyScript library. Defaults to \"https://pyscript.net/releases/2024.1.1/core.js\".\n\n        Returns:\n            str: The HTML structure of the hydrated page.\n        \"\"\"\n\n        return template(compiler_adapter.hyd_comp_compile_page(page), meta_description, title, icon, pydide)\n\n    @staticmethod\n    def hydrate_app(app: App, title=\"zenaura\", meta_description=\"this app created with zenaura\", icon=\"./public/favicon.ico\", pydide=\"https://pyscript.net/releases/2024.1.1/core.js\", scripts=None) -&gt; None:\n        \"\"\"\n        Hydrates a Zenaura app for server-side rendering.\n\n        This method renders all pages in the app, sets the page with path \"/\" to visible, and the rest to hidden. It then compiles the index.html file for server-side rendering.\n\n        Args:\n            app (App): The Zenaura app to be hydrated.\n            title (str, optional): The title of the page. Defaults to \"zenaura\".\n            meta_description (str, optional): The meta description of the page. Defaults to \"this app created with zenaura\".\n            icon (str, optional): The URL of the favicon. Defaults to \"./public/favicon.ico\".\n            pydide (str, optional): The URL of the PyScript library. Defaults to \"https://pyscript.net/releases/2024.1.1/core.js\".\n            scripts (list, optional): An optional list of additional JavaScript scripts and CSS links to include in the page. Defaults to None.\n        \"\"\"\n\n        pages = io.StringIO()\n\n        # First page in the stack is shown\n        routes = app.routes.copy()\n\n        def page_div(comps, page_id, hidden, attributes=None):\n            \"\"\"\n                wraps rendered page components with a div, assign hidden attribute\n                if the page is hidden, and add the id\n            \"\"\"\n            if attributes:\n                attrs = []\n                for k,v in attributes.items():\n                    attrs.append(Attribute(k,v))\n\n                attrs = attrs_processor.process_attributes(attrs)\n            if hidden:\n                return f'&lt;div hidden{attrs if attributes else \"\"} data-zenaura=\"{page_id}\"&gt;{comps}&lt;/div&gt;'\n            return f'&lt;div{attrs if attributes else \"\"} data-zenaura=\"{page_id}\"&gt;{comps}&lt;/div&gt;'\n\n        # if / path in routes it's set to shown\n        if \"/\" in routes:\n            page, _, _, ssr = routes.pop(\"/\")\n            pages.write(\n                page_div(\n                    compiler_adapter.hyd_comp_compile_page(page),\n                    page.id,\n                    False,\n                    page.attributes\n                )\n            )\n        else: # first route , in keys stack will be shown, rest hidden\n            keys = list(routes.keys())\n            page, _, _, ssr = routes.pop(keys[0])\n            pages.write(\n                page_div(\n                    compiler_adapter.hyd_comp_compile_page(page),\n                    page.id,\n                    False,\n                    page.attributes\n\n                )\n            )\n\n\n        # Render rest of the pages hidden\n        while routes:\n            _ , (page, _, _, ssr) = routes.popitem()\n            if ssr:  # Ignore server side rendered routes and thier pages.\n                continue\n            # Pages other than / or first route in stack are set to hidden\n            pages.write(\n                page_div(\n                    compiler_adapter.hyd_comp_compile_page(page),\n                    page.id,\n                    True,\n                    page.attributes\n\n                )\n            )\n\n        pages = pages.getvalue()\n\n        # Overwrite in public dir\n        with open(\"./public/index.html\", \"w\") as file:\n            file.write(template(pages, meta_description, title, icon, pydide, scripts))\n\n        return template(pages, meta_description, title, icon, pydide, scripts)\n\n\n    @staticmethod\n    def hydrate_app_layout(layout: Layout, title=\"zenaura\", meta_description=\"this app created with zenaura\", icon=\"./public/favicon.ico\", pydide=\"https://pyscript.net/releases/2024.1.1/core.js\", scripts=None) -&gt; None:\n        \"\"\"\n        Hydrates a Zenaura layout for server-side rendering.\n\n        This method renders all top components -&gt; pages -&gt; bottom in the app, sets the page with path \"/\" to visible, and the rest to hidden. It then compiles the index.html file for server-side rendering.\n\n        Args:\n            layout (App): the layout to be hyderated with top components -&gt; pages -&gt; bottom components wrapped \n            title (str, optional): The title of the page. Defaults to \"zenaura\".\n            meta_description (str, optional): The meta description of the page. Defaults to \"this app created with zenaura\".\n            icon (str, optional): The URL of the favicon. Defaults to \"./public/favicon.ico\".\n            pydide (str, optional): The URL of the PyScript library. Defaults to \"https://pyscript.net/releases/2024.1.1/core.js\".\n            scripts (list, optional): An optional list of additional JavaScript scripts and CSS links to include in the page. Defaults to None.\n        \"\"\"\n\n        pages = io.StringIO()\n\n        # First page in the stack is shown\n        routes = layout.routes.copy()\n\n        # add top components first children of root div \n        for comp in layout.top:\n            pages.write(compiler_adapter.hyd_comp_compile_children(comp.render(), comp.id, True))\n\n        def page_div(comps, page_id, hidden, attributes=None):\n            \"\"\"\n                wraps rendered page components with a div, assign hidden attribute\n                if the page is hidden, and add the id\n            \"\"\"\n            if attributes:\n                attrs = []\n                for k,v in attributes.items():\n                    attrs.append(Attribute(k,v))\n\n                attrs = attrs_processor.process_attributes(attrs)\n            if hidden:\n                return f'&lt;div hidden{attrs if attributes else \"\"} data-zenaura=\"{page_id}\"&gt;{comps}&lt;/div&gt;'\n            return f'&lt;div{attrs if attributes else \"\"} data-zenaura=\"{page_id}\"&gt;{comps}&lt;/div&gt;'\n\n        # if / path in routes it's set to shown\n        if \"/\" in routes:\n            page, _, _, ssr = routes.pop(\"/\")\n            pages.write(\n                page_div(\n                    compiler_adapter.hyd_comp_compile_page(page),\n                    page.id,\n                    False,\n                    page.attributes\n                )\n            )\n        else: # first route , in keys stack will be shown, rest hidden\n            keys = list(routes.keys())\n            page, _, _, ssr = routes.pop(keys[0])\n            pages.write(\n                page_div(\n                    compiler_adapter.hyd_comp_compile_page(page),\n                    page.id,\n                    False,\n                    page.attributes\n\n                )\n            )\n\n\n        # Render rest of the pages hidden\n        while routes:\n            _ , (page, _, _, ssr) = routes.popitem()\n            if ssr:  # Ignore server side rendered routes and thier pages.\n                continue\n            # Pages other than / or first route in stack are set to hidden\n            pages.write(\n                page_div(\n                    compiler_adapter.hyd_comp_compile_page(page),\n                    page.id,\n                    True,\n                    page.attributes\n\n                )\n            )\n\n        # add bottom level components\n        for comp in layout.bottom:\n            pages.write(compiler_adapter.hyd_comp_compile_children(comp.render(), comp.id, True))\n\n        pages = pages.getvalue()\n\n        # Overwrite in public dir\n        with open(\"./public/index.html\", \"w\") as file:\n            file.write(template(pages, meta_description, title, icon, pydide, scripts))\n\n        return template(pages, meta_description, title, icon, pydide, scripts)\n</code></pre>"},{"location":"api/server/server/#zenaura.server.server.ZenauraServer.hydrate_app","title":"<code>hydrate_app(app, title='zenaura', meta_description='this app created with zenaura', icon='./public/favicon.ico', pydide='https://pyscript.net/releases/2024.1.1/core.js', scripts=None)</code>  <code>staticmethod</code>","text":"<p>Hydrates a Zenaura app for server-side rendering.</p> <p>This method renders all pages in the app, sets the page with path \"/\" to visible, and the rest to hidden. It then compiles the index.html file for server-side rendering.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>App</code> <p>The Zenaura app to be hydrated.</p> required <code>title</code> <code>str</code> <p>The title of the page. Defaults to \"zenaura\".</p> <code>'zenaura'</code> <code>meta_description</code> <code>str</code> <p>The meta description of the page. Defaults to \"this app created with zenaura\".</p> <code>'this app created with zenaura'</code> <code>icon</code> <code>str</code> <p>The URL of the favicon. Defaults to \"./public/favicon.ico\".</p> <code>'./public/favicon.ico'</code> <code>pydide</code> <code>str</code> <p>The URL of the PyScript library. Defaults to \"https://pyscript.net/releases/2024.1.1/core.js\".</p> <code>'https://pyscript.net/releases/2024.1.1/core.js'</code> <code>scripts</code> <code>list</code> <p>An optional list of additional JavaScript scripts and CSS links to include in the page. Defaults to None.</p> <code>None</code> Source code in <code>zenaura\\server\\server.py</code> <pre><code>@staticmethod\ndef hydrate_app(app: App, title=\"zenaura\", meta_description=\"this app created with zenaura\", icon=\"./public/favicon.ico\", pydide=\"https://pyscript.net/releases/2024.1.1/core.js\", scripts=None) -&gt; None:\n    \"\"\"\n    Hydrates a Zenaura app for server-side rendering.\n\n    This method renders all pages in the app, sets the page with path \"/\" to visible, and the rest to hidden. It then compiles the index.html file for server-side rendering.\n\n    Args:\n        app (App): The Zenaura app to be hydrated.\n        title (str, optional): The title of the page. Defaults to \"zenaura\".\n        meta_description (str, optional): The meta description of the page. Defaults to \"this app created with zenaura\".\n        icon (str, optional): The URL of the favicon. Defaults to \"./public/favicon.ico\".\n        pydide (str, optional): The URL of the PyScript library. Defaults to \"https://pyscript.net/releases/2024.1.1/core.js\".\n        scripts (list, optional): An optional list of additional JavaScript scripts and CSS links to include in the page. Defaults to None.\n    \"\"\"\n\n    pages = io.StringIO()\n\n    # First page in the stack is shown\n    routes = app.routes.copy()\n\n    def page_div(comps, page_id, hidden, attributes=None):\n        \"\"\"\n            wraps rendered page components with a div, assign hidden attribute\n            if the page is hidden, and add the id\n        \"\"\"\n        if attributes:\n            attrs = []\n            for k,v in attributes.items():\n                attrs.append(Attribute(k,v))\n\n            attrs = attrs_processor.process_attributes(attrs)\n        if hidden:\n            return f'&lt;div hidden{attrs if attributes else \"\"} data-zenaura=\"{page_id}\"&gt;{comps}&lt;/div&gt;'\n        return f'&lt;div{attrs if attributes else \"\"} data-zenaura=\"{page_id}\"&gt;{comps}&lt;/div&gt;'\n\n    # if / path in routes it's set to shown\n    if \"/\" in routes:\n        page, _, _, ssr = routes.pop(\"/\")\n        pages.write(\n            page_div(\n                compiler_adapter.hyd_comp_compile_page(page),\n                page.id,\n                False,\n                page.attributes\n            )\n        )\n    else: # first route , in keys stack will be shown, rest hidden\n        keys = list(routes.keys())\n        page, _, _, ssr = routes.pop(keys[0])\n        pages.write(\n            page_div(\n                compiler_adapter.hyd_comp_compile_page(page),\n                page.id,\n                False,\n                page.attributes\n\n            )\n        )\n\n\n    # Render rest of the pages hidden\n    while routes:\n        _ , (page, _, _, ssr) = routes.popitem()\n        if ssr:  # Ignore server side rendered routes and thier pages.\n            continue\n        # Pages other than / or first route in stack are set to hidden\n        pages.write(\n            page_div(\n                compiler_adapter.hyd_comp_compile_page(page),\n                page.id,\n                True,\n                page.attributes\n\n            )\n        )\n\n    pages = pages.getvalue()\n\n    # Overwrite in public dir\n    with open(\"./public/index.html\", \"w\") as file:\n        file.write(template(pages, meta_description, title, icon, pydide, scripts))\n\n    return template(pages, meta_description, title, icon, pydide, scripts)\n</code></pre>"},{"location":"api/server/server/#zenaura.server.server.ZenauraServer.hydrate_app_layout","title":"<code>hydrate_app_layout(layout, title='zenaura', meta_description='this app created with zenaura', icon='./public/favicon.ico', pydide='https://pyscript.net/releases/2024.1.1/core.js', scripts=None)</code>  <code>staticmethod</code>","text":"<p>Hydrates a Zenaura layout for server-side rendering.</p> <p>This method renders all top components -&gt; pages -&gt; bottom in the app, sets the page with path \"/\" to visible, and the rest to hidden. It then compiles the index.html file for server-side rendering.</p> <p>Parameters:</p> Name Type Description Default <code>layout</code> <code>App</code> <p>the layout to be hyderated with top components -&gt; pages -&gt; bottom components wrapped </p> required <code>title</code> <code>str</code> <p>The title of the page. Defaults to \"zenaura\".</p> <code>'zenaura'</code> <code>meta_description</code> <code>str</code> <p>The meta description of the page. Defaults to \"this app created with zenaura\".</p> <code>'this app created with zenaura'</code> <code>icon</code> <code>str</code> <p>The URL of the favicon. Defaults to \"./public/favicon.ico\".</p> <code>'./public/favicon.ico'</code> <code>pydide</code> <code>str</code> <p>The URL of the PyScript library. Defaults to \"https://pyscript.net/releases/2024.1.1/core.js\".</p> <code>'https://pyscript.net/releases/2024.1.1/core.js'</code> <code>scripts</code> <code>list</code> <p>An optional list of additional JavaScript scripts and CSS links to include in the page. Defaults to None.</p> <code>None</code> Source code in <code>zenaura\\server\\server.py</code> <pre><code>@staticmethod\ndef hydrate_app_layout(layout: Layout, title=\"zenaura\", meta_description=\"this app created with zenaura\", icon=\"./public/favicon.ico\", pydide=\"https://pyscript.net/releases/2024.1.1/core.js\", scripts=None) -&gt; None:\n    \"\"\"\n    Hydrates a Zenaura layout for server-side rendering.\n\n    This method renders all top components -&gt; pages -&gt; bottom in the app, sets the page with path \"/\" to visible, and the rest to hidden. It then compiles the index.html file for server-side rendering.\n\n    Args:\n        layout (App): the layout to be hyderated with top components -&gt; pages -&gt; bottom components wrapped \n        title (str, optional): The title of the page. Defaults to \"zenaura\".\n        meta_description (str, optional): The meta description of the page. Defaults to \"this app created with zenaura\".\n        icon (str, optional): The URL of the favicon. Defaults to \"./public/favicon.ico\".\n        pydide (str, optional): The URL of the PyScript library. Defaults to \"https://pyscript.net/releases/2024.1.1/core.js\".\n        scripts (list, optional): An optional list of additional JavaScript scripts and CSS links to include in the page. Defaults to None.\n    \"\"\"\n\n    pages = io.StringIO()\n\n    # First page in the stack is shown\n    routes = layout.routes.copy()\n\n    # add top components first children of root div \n    for comp in layout.top:\n        pages.write(compiler_adapter.hyd_comp_compile_children(comp.render(), comp.id, True))\n\n    def page_div(comps, page_id, hidden, attributes=None):\n        \"\"\"\n            wraps rendered page components with a div, assign hidden attribute\n            if the page is hidden, and add the id\n        \"\"\"\n        if attributes:\n            attrs = []\n            for k,v in attributes.items():\n                attrs.append(Attribute(k,v))\n\n            attrs = attrs_processor.process_attributes(attrs)\n        if hidden:\n            return f'&lt;div hidden{attrs if attributes else \"\"} data-zenaura=\"{page_id}\"&gt;{comps}&lt;/div&gt;'\n        return f'&lt;div{attrs if attributes else \"\"} data-zenaura=\"{page_id}\"&gt;{comps}&lt;/div&gt;'\n\n    # if / path in routes it's set to shown\n    if \"/\" in routes:\n        page, _, _, ssr = routes.pop(\"/\")\n        pages.write(\n            page_div(\n                compiler_adapter.hyd_comp_compile_page(page),\n                page.id,\n                False,\n                page.attributes\n            )\n        )\n    else: # first route , in keys stack will be shown, rest hidden\n        keys = list(routes.keys())\n        page, _, _, ssr = routes.pop(keys[0])\n        pages.write(\n            page_div(\n                compiler_adapter.hyd_comp_compile_page(page),\n                page.id,\n                False,\n                page.attributes\n\n            )\n        )\n\n\n    # Render rest of the pages hidden\n    while routes:\n        _ , (page, _, _, ssr) = routes.popitem()\n        if ssr:  # Ignore server side rendered routes and thier pages.\n            continue\n        # Pages other than / or first route in stack are set to hidden\n        pages.write(\n            page_div(\n                compiler_adapter.hyd_comp_compile_page(page),\n                page.id,\n                True,\n                page.attributes\n\n            )\n        )\n\n    # add bottom level components\n    for comp in layout.bottom:\n        pages.write(compiler_adapter.hyd_comp_compile_children(comp.render(), comp.id, True))\n\n    pages = pages.getvalue()\n\n    # Overwrite in public dir\n    with open(\"./public/index.html\", \"w\") as file:\n        file.write(template(pages, meta_description, title, icon, pydide, scripts))\n\n    return template(pages, meta_description, title, icon, pydide, scripts)\n</code></pre>"},{"location":"api/server/server/#zenaura.server.server.ZenauraServer.hydrate_page","title":"<code>hydrate_page(page, title='zenaura', meta_description='this app created with zenaura', icon='./public/favicon.ico', pydide='https://pyscript.net/releases/2024.1.1/core.js')</code>  <code>staticmethod</code>","text":"<p>Hydrates a Zenaura page for server-side rendering.</p> <p>This method compiles the page's components using the HydratorCompilerAdapter and generates the HTML structure of the page.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Page</code> <p>The Zenaura page to be hydrated.</p> required <code>title</code> <code>str</code> <p>The title of the page. Defaults to \"zenaura\".</p> <code>'zenaura'</code> <code>meta_description</code> <code>str</code> <p>The meta description of the page. Defaults to \"this app created with zenaura\".</p> <code>'this app created with zenaura'</code> <code>icon</code> <code>str</code> <p>The URL of the favicon. Defaults to \"./public/favicon.ico\".</p> <code>'./public/favicon.ico'</code> <code>pydide</code> <code>str</code> <p>The URL of the PyScript library. Defaults to \"https://pyscript.net/releases/2024.1.1/core.js\".</p> <code>'https://pyscript.net/releases/2024.1.1/core.js'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The HTML structure of the hydrated page.</p> Source code in <code>zenaura\\server\\server.py</code> <pre><code>@staticmethod\ndef hydrate_page(page: Page, title=\"zenaura\", meta_description=\"this app created with zenaura\", icon=\"./public/favicon.ico\", pydide=\"https://pyscript.net/releases/2024.1.1/core.js\") -&gt; str:\n    \"\"\"\n    Hydrates a Zenaura page for server-side rendering.\n\n    This method compiles the page's components using the HydratorCompilerAdapter and generates the HTML structure of the page.\n\n    Args:\n        page (Page): The Zenaura page to be hydrated.\n        title (str, optional): The title of the page. Defaults to \"zenaura\".\n        meta_description (str, optional): The meta description of the page. Defaults to \"this app created with zenaura\".\n        icon (str, optional): The URL of the favicon. Defaults to \"./public/favicon.ico\".\n        pydide (str, optional): The URL of the PyScript library. Defaults to \"https://pyscript.net/releases/2024.1.1/core.js\".\n\n    Returns:\n        str: The HTML structure of the hydrated page.\n    \"\"\"\n\n    return template(compiler_adapter.hyd_comp_compile_page(page), meta_description, title, icon, pydide)\n</code></pre>"},{"location":"api/server/server/#zenaura.server.server.template","title":"<code>template(content, meta_description=None, title=None, icon=None, pydide='https://pyscript.net/releases/2024.1.1/core.js', scripts=None)</code>","text":"<p>This function generates the HTML structure of a Zenaura page.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The main content of the page, typically generated by compiling Zenaura components.</p> required <code>meta_description</code> <code>str</code> <p>A brief description of the page, used by search engines. Defaults to None.</p> <code>None</code> <code>title</code> <code>str</code> <p>The title of the page, displayed in the browser tab. Defaults to None.</p> <code>None</code> <code>icon</code> <code>str</code> <p>The URL of the favicon, a small icon associated with the page. Defaults to None.</p> <code>None</code> <code>pydide</code> <code>str</code> <p>The URL of the PyScript library, used for running Python code in the browser. Defaults to \"https://pyscript.net/releases/2024.1.1/core.js\".</p> <code>'https://pyscript.net/releases/2024.1.1/core.js'</code> <code>scripts</code> <code>list</code> <p>An optional list of additional JavaScript scripts, CSS links to include in the page. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <p>The complete HTML code as a string.</p> Source code in <code>zenaura\\server\\server.py</code> <pre><code>def template(content, meta_description=None, title=None, icon=None, pydide=\"https://pyscript.net/releases/2024.1.1/core.js\", scripts=None):\n  \"\"\"\n    This function generates the HTML structure of a Zenaura page.\n\n    Args:\n        content (str): The main content of the page, typically generated by compiling Zenaura components.\n        meta_description (str, optional): A brief description of the page, used by search engines. Defaults to None.\n        title (str, optional): The title of the page, displayed in the browser tab. Defaults to None.\n        icon (str, optional): The URL of the favicon, a small icon associated with the page. Defaults to None.\n        pydide (str, optional): The URL of the PyScript library, used for running Python code in the browser. Defaults to \"https://pyscript.net/releases/2024.1.1/core.js\".\n        scripts (list, optional): An optional list of additional JavaScript scripts, CSS links to include in the page. Defaults to None.\n\n    Returns:\n        str: The complete HTML code as a string.\n  \"\"\"\n  if scripts:\n    s = io.StringIO()\n    for script in scripts:\n        s.write(script)\n        s.write(\"\\n\")\n    scripts = s.getvalue()\n\n  return f\"\"\"\n\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"utf-8\" /&gt;\n    &lt;link rel=\"icon\" href=\"{icon}\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /&gt;\n    &lt;meta name=\"theme-color\" content=\"#000000\" /&gt;\n    &lt;meta name=\"title\" content=\"{title}\" /&gt;\n    &lt;meta http-equiv=\"refresh\"  /&gt;\n    &lt;meta\n      name=\"description\"\n      content=\"{meta_description}\"\n    /&gt;\n    &lt;script type=\"module\" src=\"{pydide}\"&gt;&lt;/script&gt;\n    {scripts if scripts else \"\"}\n\n\t&lt;script type=\"py\" src=\"./public/main.py\" config=\"./public/config.json\"&gt;&lt;/script&gt;\n\n    &lt;link  rel=\"stylesheet\" href=\"./public/main.css\"&gt;\n\n    &lt;title&gt;{title}&lt;/title&gt;\n\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"root\"&gt;\n        {content}\n    &lt;/div&gt;\n\n  &lt;/body&gt;\n\n&lt;/html&gt;\n\"\"\"\n</code></pre>"},{"location":"basics/components/","title":"Zenaura Components","text":"<p>Zenaura components allow Python developers to create the building blocks for their applications. These components are categorized into three types:</p> <ol> <li>Stateful Limited Class Components (limited, not reusable)</li> <li>Stateful Reusable Class Components (reusable)</li> <li>Stateless Presentational Functional Components</li> </ol>"},{"location":"basics/components/#understanding-the-node-data-structure","title":"Understanding the Node Data Structure","text":"<p>The <code>Node</code> data structure is the fundamental building block in the Zenaura library. It enables the virtual DOM to compare the previous and current state of a component, diff the changes, and update the real DOM efficiently. Every component must return a <code>Node</code> data structure via the <code>render</code> method in class components or via a return statement in functional components.</p> <p>Here's an example of creating a <code>Node</code>:</p> <pre><code>from zenaura.client.tags import Node, Attribute\n\nnode = Node(\n    \"div\",\n    children=[\n        Node(\n            'h1', \n            children=[\n                Node(text='hello')\n            ]\n        )\n    ], \n    attributes=[\n        Attribute(\"class\", \"test\")\n    ]\n)\n</code></pre> <p>This will render the following HTML:</p> <pre><code>&lt;div class=\"test\"&gt;\n    &lt;h1&gt;hello&lt;/h1&gt;\n&lt;/div&gt;\n</code></pre> <p>While the <code>Node</code> data structure is powerful, it can be cumbersome for building UI components, which is where the Builder Interface comes in.</p>"},{"location":"basics/components/#the-builder-interface","title":"The Builder Interface","text":"<p>The Builder Interface abstracts away the complexities of the <code>Node</code> data structure, allowing developers to write more maintainable, readable, and declarative UI building blocks.</p> <p>Example using the Builder Interface:</p> <pre><code>from zenaura.client.tags.builder import Builder\n\nh1 = Builder('h1').with_text(\"test\").build()\ndiv = Builder(\"div\").with_child(h1).with_attribute(\"class\", \"test\").build()\n</code></pre> <p>This will render the following HTML:</p> <pre><code>&lt;div class=\"test\"&gt;\n    &lt;h1&gt;test&lt;/h1&gt;\n&lt;/div&gt;\n</code></pre> <p>The Builder Interface enhances readability and maintainability. To further simplify, you can use functional components.</p>"},{"location":"basics/components/#stateless-presentational-functional-components","title":"Stateless Presentational Functional Components","text":"<p>Stateless presentational components allow you to break down large stateful components into smaller, reusable pieces. They are simple Python functions that return a <code>Node</code> data structure.</p> <p>Example:</p> <pre><code>from zenaura.client.tags.builder import Builder\n\ndef Div(class_name, children):\n    div = Builder('div').with_attribute('class', class_name).build()\n    div.children = children\n    return div\n\ndef Header1(text):\n    return Builder('h1').with_text(text).build()\n\ndiv = Div('test', [Header1('test')])\n</code></pre> <p>This will render the following HTML:</p> <pre><code>&lt;div class=\"test\"&gt;\n    &lt;h1&gt;test&lt;/h1&gt;\n&lt;/div&gt;\n</code></pre> <p>Using the Builder Interface with functional components helps in building robust and reusable components for any Zenaura project.</p>"},{"location":"basics/components/#stateful-limited-class-components-limited-not-reusable","title":"Stateful Limited Class Components (Limited, Not Reusable)","text":"<p>These are the default class components in the Zenaura library. They can maintain state and wrap functional components to create fully-featured UIs. However, they are limited and cannot be reused within the same project unless specified with the <code>@Reusable</code> decorator.</p> <p>Example:</p> <pre><code>from zenaura.client.component import Component\nfrom public.presentational import *\n\nclass ZenauraStarter(Component):\n    def __init__(self, di):\n        super().__init__()\n        self.di = di\n        self.state = None\n\n    def render(self):\n        return Div(\"zenaura\", [\n           Div(\"\", [\n            Image(\"./public/logo.png\", \"zenaura\", \"255\", \"255\", \"starterLogo\"),\n            Header1(\"The Python Library For, Hello world!\"),\n            Header1(\"Building Modern Web User Interfaces\")\n           ])\n        ])\n\nzen = ZenauraStarter()  # No error\nzen2 = ZenauraStarter()  # Error: Zenaura components are limited by design\n</code></pre>"},{"location":"basics/components/#stateful-reusable-class-components-reusable","title":"Stateful Reusable Class Components (Reusable)","text":"<p>These components are designed to be reusable across your codebase. They manage their state independently and can be used multiple times within the same project.</p> <p>Example:</p> <pre><code>from zenaura.client.component import Component, Reuseable\nfrom public.presentational import *\n\n@Reuseable\nclass ZenauraStarter(Component):\n    def render(self):\n        return Div(\"zenaura\", [\n           Div(\"\", [\n            Image(\"./public/logo.png\", \"zenaura\", \"255\", \"255\", \"starterLogo\"),\n            Header1(\"The Python Library For, Hello world!\"),\n            Header1(\"Building Modern Web User Interfaces\")\n           ])\n        ])\n\nzen = ZenauraStarter()  # No error\nzen2 = ZenauraStarter()  # No error\n</code></pre>"},{"location":"basics/components/#nesting-component-logic","title":"Nesting Component Logic","text":"<p>In the Zenaura library, there is a specific nesting order that must be followed: </p> <ul> <li>Pages</li> <li>Class Components<ul> <li>Functional Components</li> </ul> </li> </ul> <p>This order ensures predictable and debuggable source code. Pages render the components as a stack from index 0 to n in the browser. Nested stateful class components can be confusing, so maintain the hierarchy to avoid errors.</p>"},{"location":"basics/components/#summary","title":"Summary","text":"<p>In this guide, we've covered the different types of components in Zenaura and how to use the Node data structure and Builder Interface to create maintainable and reusable UI components. Following these principles will help you build scalable and efficient applications with Zenaura.</p> <p>In the next guide, we'll dive deep into dependency injection and component state management.</p>"},{"location":"basics/data_binding/","title":"Zenaura Data Binding Model Guide","text":"<p>Data binding is a powerful technique that allows seamless synchronization between the user interface and the underlying data model. In Zenaura, data binding facilitates automatic updates to the UI when the state changes, enabling a reactive and efficient user experience. This guide will walk you through the fundamentals of data binding in Zenaura components.</p>"},{"location":"basics/data_binding/#understanding-data-binding-in-components","title":"Understanding Data Binding in Components","text":"<p>Data binding in Zenaura involves creating a connection between the component's state and the UI elements, ensuring that changes in the state are reflected in the UI and vice versa. This helps maintain a consistent and interactive user interface.</p> <p>The way zenaura implement synchronization between the user interface and the underlying data model is through mutations. Mutations are event handlers decorated with mutator. Use mutator over an event handler if and only if we want the component to re-render. The data can still be synced if we set the state within event handler, without re-rendering the component.</p>"},{"location":"basics/data_binding/#example-of-a-simple-data-binding-component","title":"Example of a Simple Data Binding Component","text":"<p>Let's create a simple form component to demonstrate how data binding works in Zenaura.</p> <pre><code>from zenaura.client.component import Component\nfrom zenaura.client.tags.builder import Builder\nfrom zenaura.client.mutator import mutator\n\nclass SimpleForm(Component):\n    def __init__(self):\n        super().__init__()\n        self.set_state({\"inputValue\": \"\"})\n\n    # note here we did not pass re-render\n    # we just want to grap the user input value\n    async def update_input(self, event):\n        new_value = event.target.value\n        self.set_state({\"inputValue\": new_value})\n\n    def render(self):\n        input_value = self.get_state()[\"inputValue\"]\n        return Builder(\"div\").with_children([\n            Builder(\"input\")\n                .with_attribute(\"value\", input_value)\n                .with_attribute(\"py-change\", f\"{self.instance_name}.update_input\")\n                .build(),\n            Builder(\"p\")\n                .with_text(f\"Current input: {input_value}\")\n                .build()\n        ]).build()\n</code></pre>"},{"location":"basics/data_binding/#explanation","title":"Explanation","text":"<ol> <li>Initialization: The <code>SimpleForm</code> component initializes its state with an <code>inputValue</code> key, set to an empty string.</li> <li>Mutator: The <code>update_input</code> method updates the <code>inputValue</code> state based on the user's input.</li> <li>Rendering: The <code>render</code> method constructs the UI using the <code>Builder</code> interface. It creates an input field bound to <code>inputValue</code> and a paragraph element to display the current input value.</li> </ol>"},{"location":"basics/data_binding/#two-way-data-binding","title":"Two-Way Data Binding","text":"<p>Two-way data binding ensures that changes in the UI update the component's state and that changes in the state update the UI. This is essential for creating interactive forms and inputs.</p> <p>Make sure to use text, node via builder <code>.with_text</code> zenaura will sanitize the data for you, but extra sanitization is never wrong. Zenaura as well will sanitize attributes, same extra sanitization is good. Better to be careful than sorry.</p>"},{"location":"basics/data_binding/#example-of-two-way-data-binding","title":"Example of Two-Way Data Binding","text":"<p>Here's an example of a component demonstrating two-way data binding:</p> <pre><code>from zenaura.client.component import Component\nfrom zenaura.client.tags.builder import Builder\nfrom zenaura.client.mutator import mutator\n\nclass TwoWayBinding(Component):\n    def __init__(self):\n        super().__init__()\n        self.set_state({\"text\": \"Hello, Zenaura!\"})\n\n    @mutator\n    async def update_text(self, event):\n        new_text = event.target.value\n        self.set_state({\"text\": new_text})\n\n    def render(self):\n        text = self.get_state()[\"text\"]\n        return Builder(\"div\").with_children([\n            Builder(\"input\")\n                .with_attribute(\"value\", text)\n                .with_attribute(\"py-change\", f\"{self.instance_name}.update_text\")\n                .build(),\n            Builder(\"p\")\n                .with_text(f\"Typed text: {text}\")\n                .build()\n        ]).build()\n</code></pre>"},{"location":"basics/data_binding/#explanation_1","title":"Explanation","text":"<ol> <li>Initialization: The <code>TwoWayBinding</code> component initializes its state with a <code>text</code> key.</li> <li>Mutator: The <code>update_text</code> method updates the <code>text</code> state based on the user's input.</li> <li>Rendering: The <code>render</code> method creates an input field bound to <code>text</code> and a paragraph element to display the current text.</li> </ol>"},{"location":"basics/data_binding/#best-practices-for-data-binding","title":"Best Practices for Data Binding","text":"<ol> <li>Keep State Consistent: Ensure that the state accurately reflects the UI and vice versa. This helps maintain a reliable and predictable user experience.</li> <li>Use Mutators for State Changes: use <code>@mutator</code>-decorated methods to modify the state. This ensures that state changes are tracked and the UI is updated correctly.</li> <li>Initialize State in the Constructor: Set initial state values in the <code>__init__</code> method to ensure the component starts with a known state.</li> <li>Use Clear Naming Conventions: Use descriptive names for state keys and mutator methods to make the code more readable and maintainable.</li> </ol>"},{"location":"basics/data_binding/#summary","title":"Summary","text":"<p>In this guide, we've covered the basics of data binding in Zenaura components. We created examples of components with one-way and two-way data binding and discussed best practices for managing state and data binding. Following these principles will help you build dynamic and interactive UIs with Zenaura.</p>"},{"location":"basics/di/","title":"Simple Guide to Dependency Injection in Zenaura","text":"<p>Dependency injection (DI) allows you to inject external dependencies into your components, making your code more modular and easier to test.</p>"},{"location":"basics/di/#why-use-dependency-injection","title":"Why Use Dependency Injection?","text":"<ul> <li>Decoupling: Makes your components independent of the specific implementations of their dependencies.</li> <li>Testability: Easier to mock dependencies during testing.</li> <li>Flexibility: Easily swap out dependencies without changing your component code.</li> </ul>"},{"location":"basics/di/#basic-steps-for-dependency-injection","title":"Basic Steps for Dependency Injection","text":""},{"location":"basics/di/#step-1-define-your-dependencies","title":"Step 1: Define Your Dependencies","text":"<p>First, create the dependencies that your components will need. These could be services, configurations, or any other objects.</p> <pre><code>class ApiService:\n    def fetch_data(self):\n        return \"data from API\"\n\nclass Logger:\n    def log(self, message):\n        print(f\"LOG: {message}\")\n\n# Create instances of your dependencies\ndependencies = {\n    \"api_service\": ApiService(),\n    \"logger\": Logger()\n}\n</code></pre>"},{"location":"basics/di/#inject-dependencies-into-components","title":"Inject Dependencies into Components","text":"<p>When creating a component, pass the dependencies to the component's constructor.</p> <pre><code>from zenaura.client.component import Component\n\nclass MyComponent(Component):\n    def __init__(self, di):\n        super().__init__()\n        self.api_service = di[\"api_service\"]\n        self.logger = di[\"logger\"]\n\n    def render(self):\n        return Builder(\"div\").with_text(\"My Component\").build()\n\n# Instantiate the component with dependencies\nmy_component = MyComponent(dependencies)\n</code></pre>"},{"location":"basics/di/#use-dependencies-in-component-methods","title":"Use Dependencies in Component Methods","text":"<p>Utilize the injected dependencies in your component's methods as needed.</p> <pre><code>class DataFetcherComponent(Component):\n    def __init__(self, di):\n        super().__init__()\n        self.api_service = di[\"api_service\"]\n        self.logger = di[\"logger\"]\n\n    async def fetch_and_log_data(self):\n        data = self.api_service.fetch_data()\n        self.logger.log(f\"Data: {data}\")\n\n    def render(self):\n        return Builder(\"div\").with_text(\"Data Fetcher Component\").build()\n\n# Instantiate the component with dependencies\ndata_fetcher_component = DataFetcherComponent(dependencies)\n</code></pre>"},{"location":"basics/di/#step-4-injecting-dependencies-into-nested-components","title":"Step 4: Injecting Dependencies into Nested Components","text":"<p>If you have nested components, pass the dependencies down to the child components.</p> <pre><code>class ParentComponent(Component):\n    def __init__(self, di):\n        super().__init__()\n        self.di = di\n\n    def render(self):\n        child_component = ChildComponent(self.di)\n        return Builder(\"div\").with_child(child_component.render()).build()\n\ndef ChildComponent(Component):\n    self.logger.log(\"Child component rendered\")\n    return Builder(\"div\").with_text(\"Child Component\").build()\n\n# Instantiate the parent component with dependencies\nparent_component = ParentComponent(dependencies)\n</code></pre>"},{"location":"basics/di/#summary","title":"Summary","text":"<ul> <li>Define your dependencies outside the components.</li> <li>Pass these dependencies to the component's constructor.</li> <li>Use the dependencies inside the component as needed.</li> <li>Pass dependencies to nested components if necessary.</li> </ul> <p>By following these simple steps, you can effectively manage dependencies in your Zenaura components, making your code more modular, testable, and maintainable.</p>"},{"location":"basics/lifecycle/","title":"Zenaura Lifecycle Guide","text":"<p>In Zenaura, lifecycle methods allow you to hook into various stages of a component's life in the zenaura virtual DOM. This guide will introduce the key lifecycle methods and how to use them effectively.</p>"},{"location":"basics/lifecycle/#overview","title":"Overview","text":"<p>Zenaura provides two main lifecycle classes: 1. MountLifeCycles: Handles actions when a component is first mounted to the DOM. 2. RenderLifeCycle: Manages actions before and after a component is updated and re-rendered in the DOM.</p>"},{"location":"basics/lifecycle/#key-lifecycle-methods","title":"Key Lifecycle Methods","text":"<ul> <li>attached: Called after a component is mounted to the DOM.</li> <li>on_mutation: Called before a component is updated in the DOM.</li> <li>on_settled: Called after a component is updated and re-rendered in the DOM.</li> </ul>"},{"location":"basics/lifecycle/#mountlifecycles","title":"MountLifeCycles","text":"<p>The <code>MountLifeCycles</code> class provides the <code>attached</code> method, which is invoked after a component is mounted to the DOM. This is useful for initializing state, setting up event listeners, making API calls, or performing animations.</p>"},{"location":"basics/lifecycle/#usage","title":"Usage","text":"<pre><code>from zenaura.client.component import Component\nfrom zenaura.client.mutator import mutator\n\nclass MyComponent(Component):\n\n    @mutator\n    async def attached(self):\n        # Initialize state\n        self.state = {\"count\": 0}\n        # Set up event listeners\n        self.setup_event_listeners()\n        # Make an API call\n        await self.fetch_data()\n        # Perform an animation\n        self.perform_animation()\n\n    def setup_event_listeners(self):\n        pass\n\n    async def fetch_data(self):\n        pass\n\n    def perform_animation(self):\n        pass\n\n    @\n\n    def render(self):\n        return Builder(\"div\").with_text(\"Hello, World!\").build()\n</code></pre>"},{"location":"basics/lifecycle/#explanation","title":"Explanation","text":"<ol> <li>Initialization: State initialization and other setup actions are performed in the <code>attached</code> method.</li> <li>Event Listeners and API Calls: Set up event listeners and make any necessary API calls.</li> <li>Rendering: Define the component's render method to return the desired HTML structure.</li> <li>mutator: attached must be decorated with mutator , so once we trigger the ui or state mutation the component re-renders.</li> </ol>"},{"location":"basics/lifecycle/#renderlifecycle","title":"RenderLifeCycle","text":"<p>The <code>RenderLifeCycle</code> class provides two methods: <code>on_mutation</code> and <code>on_settled</code>. These methods are invoked before and after a component is updated and re-rendered in the DOM.</p>"},{"location":"basics/lifecycle/#on_mutation","title":"on_mutation","text":"<p>The <code>on_mutation</code> method is called before the component is updated. This is useful for updating state based on new props, setting up event listeners, making API calls, or performing animations.</p>"},{"location":"basics/lifecycle/#usage_1","title":"Usage","text":"<pre><code>from zenaura.client.component import Component\n\nclass MyComponent(Component):\n    async def on_mutation(self):\n        # Update state based on new props\n        self.state[\"updated\"] = True\n        # Set up event listeners\n        self.setup_event_listeners()\n        # Make an API call\n        await self.fetch_data()\n        # Perform an animation\n        self.perform_animation()\n\n    def setup_event_listeners(self):\n        pass\n\n    async def fetch_data(self):\n        pass\n\n    def perform_animation(self):\n        pass\n\n    def render(self):\n        return Builder(\"div\").with_text(\"Hello, World!\").build()\n</code></pre>"},{"location":"basics/lifecycle/#explanation_1","title":"Explanation","text":"<p>Important note: Unlike mount lifecycle methods, render lifecycle methods should not be decorated with mutator decorator, they are already within the lifecycle of render, passing mutator will result in a recurision cycle. Render lifecycle methods are called when the component is rendering.</p> <ol> <li>Update State and Setup: Perform necessary actions before the component is updated, such as updating state and setting up event listeners.</li> </ol>"},{"location":"basics/lifecycle/#on_settled","title":"on_settled","text":"<p>The <code>on_settled</code> method is called after the component is updated and re-rendered. This is useful for focusing on an input element, scrolling to a specific position, or triggering custom events.</p>"},{"location":"basics/lifecycle/#usage_2","title":"Usage","text":"<pre><code>from zenaura.client.component import Component\n\nclass MyComponent(Component):\n    async def on_settled(self):\n        # Focus on an input element\n        self.focus_input()\n        # Scroll to a specific position\n        self.scroll_to_position()\n        # Trigger custom events\n        self.trigger_custom_event()\n\n    def focus_input(self):\n        pass\n\n    def scroll_to_position(self):\n        pass\n\n    def trigger_custom_event(self):\n        pass\n\n    def render(self):\n        return Builder(\"div\").with_text(\"Hello, World!\").build()\n</code></pre>"},{"location":"basics/lifecycle/#explanation_2","title":"Explanation","text":"<ol> <li>Post-Update Actions: Perform actions such as focusing on elements, scrolling, or triggering custom events after the component is re-rendered.</li> </ol>"},{"location":"basics/lifecycle/#example-complete-component-lifecycle","title":"Example: Complete Component Lifecycle","text":"<p>Here\u2019s an example that integrates all lifecycle methods in a single component:</p> <pre><code>from zenaura.client.component import Component\nfrom zenaura.client.tags.builder import Builder\nfrom zenaura.client.mutator import mutator\n\nclass FullLifecycleComponent(Component):\n    @mutator\n    async def attached(self):\n        self.state = {\"initialized\": True}\n        print(\"Component mounted and initialized.\")\n\n    async def on_mutation(self):\n        self.state[\"updated\"] = True\n        print(\"Component state updated before rendering.\")\n\n    async def on_settled(self):\n        print(\"Component re-rendered and settled.\")\n\n    def render(self):\n        return Builder(\"div\").with_text(\"Lifecycle Component\").build()\n\n# Create and mount the component\ncomponent = FullLifecycleComponent()\ncomponent.attached()\ncomponent.on_mutation()\ncomponent.on_settled()\n</code></pre>"},{"location":"basics/lifecycle/#explanation_3","title":"Explanation","text":"<ol> <li>Mounting: The <code>attached</code> method initializes the state when the component is mounted. We need mutator because we want to re-render the component, let zenaura virtual DOM diff, and update the real dom affected parts with the changes from attached method.</li> <li>Updating: The <code>on_mutation</code> method updates the state before re-rendering.</li> <li>Settling: The <code>on_settled</code> method logs a message after the component is re-rendered.</li> </ol>"},{"location":"basics/lifecycle/#summary","title":"Summary","text":"<p>Lifecycle methods in Zenaura provide hooks to perform actions at different stages of a component\u2019s life. The <code>MountLifeCycles</code> and <code>RenderLifeCycle</code> classes offer methods to initialize state, set up event listeners, make API calls, perform animations, and more. By leveraging these lifecycle methods, you can create dynamic and interactive components with ease.</p>"},{"location":"basics/pages/","title":"Working with Pages in Zenaura","text":"<p>Pages in Zenaura serve as the top-level structure for organizing and rendering your application\u2019s components. This guide will cover the basics of creating and managing pages, adding components to them, and setting up routing to navigate between different pages.</p>"},{"location":"basics/pages/#overview","title":"Overview","text":"<p>A page in Zenaura is essentially a container for components. It defines what components should be displayed and how they are structured. Pages are managed by the router, which handles navigation and rendering based on the application's routes.</p>"},{"location":"basics/pages/#key-concepts","title":"Key Concepts","text":"<ul> <li>Page: A top-level container for components.</li> <li>Component: A building block of the UI, which can be stateful or stateless.</li> <li>Router: Manages navigation and rendering of pages based on URL routes.</li> </ul>"},{"location":"basics/pages/#creating-a-page","title":"Creating a Page","text":"<p>To create a page, you need to define which components it contains. Here\u2019s an example of setting up a simple page with some components:</p> <pre><code>from zenaura.client.page import Page\nfrom zenaura.client.component import Component\nfrom zenaura.client.tags.builder import Builder\n\n# Define some sample components\nclass Header(Component):\n    def render(self):\n        return Builder(\"h1\").with_text(\"Welcome to Zenaura!\").build()\n\nclass Footer(Component):\n    def render(self):\n        return Builder(\"footer\").with_text(\"\u00a9 2024 Zenaura Inc.\").build()\n\nclass MainContent(Component):\n    def render(self):\n        return Builder(\"div\").with_text(\"This is the main content area.\").build()\n\n# Create a page and add components to it\nheader = Header()\nfooter = Footer()\nmain_content = MainContent()\n\nhome_page = Page([header, main_content, footer])\n</code></pre>"},{"location":"basics/pages/#explanation","title":"Explanation","text":"<ol> <li>Define Components: In this example, we define three simple components: <code>Header</code>, <code>Footer</code>, and <code>MainContent</code>.</li> <li>Create a Page: We then create a <code>Page</code> instance and pass a list of components that should be rendered on this page.</li> </ol>"},{"location":"basics/pages/#adding-pages-to-the-router","title":"Adding Pages to the Router","text":"<p>To enable navigation between pages, we need to add them to the router. The router manages different routes and renders the appropriate page based on the current URL.</p> <pre><code>from zenaura.client.app import Route, App\nfrom public.routes import ClientRoutes\n\n# Initialize the router\nrouter = App()\n\n# Add routes for different pages\nrouter.add_route(Route(\n    title=\"Home\",\n    path=ClientRoutes.home.value,\n    page=home_page\n))\n\n# Add more routes as needed\n</code></pre>"},{"location":"basics/pages/#explanation_1","title":"Explanation","text":"<ol> <li>Initialize Router: We create an instance of the <code>App</code> class, which serves as the router.</li> <li>Add Routes: We add a route for the <code>home_page</code> we created earlier. Each route is defined by a title, a path, and the page to be rendered.</li> </ol>"},{"location":"basics/pages/#navigation-between-pages","title":"Navigation Between Pages","text":"<p>To navigate between pages, you can use the <code>navigate</code> method provided by the router. This can be done within component event handlers or other parts of your application.</p> <pre><code>class NavigationComponent(Component):\n    async def go_to_home(self, event):\n        await router.navigate(ClientRoutes.home.value)\n\n    def render(self):\n        return Builder(\"button\").with_text(\"Go to Home\").with_attribute(\"py-click\", f\"{self.instance_name}.go_to_home\").build()\n</code></pre>"},{"location":"basics/pages/#explanation_2","title":"Explanation","text":"<ol> <li>Navigation Method: The <code>go_to_home</code> method uses the <code>navigate</code> method of the router to change the current URL to the home path.</li> <li>Event Handler: The <code>py-click</code> attribute in the <code>Builder</code> method links the button click event to the <code>go_to_home</code> method, enabling navigation when the button is clicked.</li> </ol>"},{"location":"basics/pages/#example-complete-application","title":"Example: Complete Application","text":"<p>Let\u2019s put everything together in a complete example:</p> <pre><code>from zenaura.client.component import Component\nfrom zenaura.client.tags.builder import Builder\nfrom zenaura.client.page import Page\nfrom zenaura.client.app import Route, App\nfrom public.routes import ClientRoutes\nfrom zenaura.client.tags.node import Node, Attribute\n\n# Define Components\nclass Header(Component):\n    def render(self):\n        return Builder(\"h1\").with_text(\"Welcome to Zenaura!\").build()\n\nclass Footer(Component):\n    def render(self):\n        return Builder(\"footer\").with_text(\"\u00a9 2024 Zenaura Inc.\").build()\n\nclass MainContent(Component):\n    def render(self):\n        return Builder(\"div\").with_text(\"This is the main content area.\").build()\n\nclass NavigationComponent(Component):\n    async def go_to_home(self, event):\n        await router.navigate(ClientRoutes.home.value)\n\n    def render(self):\n        return Builder(\"button\").with_text(\"Go to Home\").with_attribute(\"py-click\", f\"{self.instance_name}.go_to_home\").build()\n\n# Create Pages\nheader = Header()\nfooter = Footer()\nmain_content = MainContent()\nnavigation = NavigationComponent()\n\nhome_page = Page([header, main_content, footer])\nnavigation_page = Page([navigation, footer])\n\n# Initialize Router\nrouter = App()\n\n# Add Routes\nrouter.add_route(Route(\n    title=\"Home\",\n    path=ClientRoutes.home.value,\n    page=home_page\n))\n\nrouter.add_route(Route(\n    title=\"Navigation\",\n    path=ClientRoutes.navigation.value,\n    page=navigation_page\n))\n\n# Start the App\nif __name__ == \"__main__\":\n    import asyncio\n    event_loop = asyncio.get_event_loop()\n    event_loop.run_until_complete(router.handle_location())\n</code></pre>"},{"location":"basics/pages/#adding-attributes-for-page-wrapper-div","title":"Adding attributes for page wrapper div","text":"<p>Each page components are wrapped in single div where it's <code>data-zenara</code> is set to <code>page.id</code>, if you need functionality to add attributes to the page such as <code>class=\"flex\"</code> you can do so using optional page attributes.  <pre><code>home_page = Page([header, main_content, footer], {\"class\": \"flex\" })\n</code></pre></p> <p>The above page will render as follow : <pre><code>&lt;div data-zenaura=\"72e7e09f\" class=\"flex\"&gt;&lt;/div&gt;\n</code></pre></p>"},{"location":"basics/pages/#explanation_3","title":"Explanation","text":"<ol> <li>Components and Pages: We define components and create two pages: <code>home_page</code> and <code>navigation_page</code>.</li> <li>Router Setup: We initialize the router, add routes for both pages, and start the application.</li> </ol>"},{"location":"basics/pages/#best-practices","title":"Best Practices","text":"<ol> <li>Component Organization: Organize your components into separate files or modules for better maintainability.</li> <li>Consistent Structure: Follow a consistent structure for defining and adding pages to the router.</li> <li>Reusability: Use reusable components wherever possible to keep your code DRY (Don't Repeat Yourself).</li> </ol>"},{"location":"basics/pages/#summary","title":"Summary","text":"<p>In this guide, we've covered how to create and manage pages in Zenaura. We explored adding components to pages, setting up the router, and handling navigation. By following these principles, you can build a well-structured and navigable Zenaura application.</p>"},{"location":"basics/router/","title":"Zenaura Router Guide","text":"<p>The Zenaura Router, encapsulated in the <code>App</code> class, provides a powerful and flexible way to manage routes and navigation in your application. This guide will walk you through the essential aspects of setting up and using the router.</p> <p>When you build zenaura client app, zenaura will rewrite index.html as the pages wihin your application. Each page will have hidden, except /. Each route by default is set to ssr = False, ssr can be used to allow the client route to ignore the server side rendered components. </p> <p>When you visit a page within a zenaura application , the page previous page will be set to hidden, the current page hidden attribute will be removed.</p> <p>This is simple way to achieve single page application UI/UX. </p> <p>If \"/\" path is defined then the page associated with it will be visible the rest is hidden. If \"/\" path is not defined, then the first path page is set to visible the rest is hidden.</p>"},{"location":"basics/router/#overview","title":"Overview","text":"<p>The <code>App</code> class manages routes, navigation, and the current location in a Zenaura application. It supports adding routes, navigating between pages, and handling browser history.</p>"},{"location":"basics/router/#key-features","title":"Key Features","text":"<ul> <li>Routing: Define paths and associate them with components.</li> <li>Navigation: Move between different routes programmatically.</li> <li>History Management: Keep track of navigation history and handle forward/backward navigation.</li> <li>SSR Support: Handle server-side rendered (SSR) pages.</li> </ul>"},{"location":"basics/router/#app-class","title":"App Class","text":""},{"location":"basics/router/#attributes","title":"Attributes","text":"<ul> <li><code>routes</code> (dict): Maps paths to their associated pages and titles.</li> <li><code>paths</code> (list): List of registered paths.</li> <li><code>history</code> (PageHistory): Manages the history of visited pages.</li> </ul>"},{"location":"basics/router/#methods","title":"Methods","text":"<ul> <li><code>__init__()</code></li> <li><code>navigate(path)</code></li> <li><code>handle_location()</code></li> <li><code>add_route(route)</code></li> <li><code>back()</code></li> <li><code>forward()</code></li> <li><code>get_current_route()</code></li> </ul>"},{"location":"basics/router/#setting-up-the-router","title":"Setting Up the Router","text":""},{"location":"basics/router/#initialization","title":"Initialization","text":"<p>To start using the router, instantiate the <code>App</code> class:</p> <pre><code>from zenaura.client.app import App\n\napp = App()\n</code></pre>"},{"location":"basics/router/#adding-routes","title":"Adding Routes","text":"<p>Define routes using the <code>add_route</code> method. Each route is represented by a <code>Route</code> object, which includes the path, page, title, and optional middleware and SSR settings.</p> <pre><code>from zenaura.client.app import Route\nfrom zenaura.client.component import Page\n\n# Define your page components\nhome_page = Page([HomeComponent()])\nabout_page = Page([AboutComponent()])\n\n# Add routes\napp.add_route(Route(title=\"Home\", path=\"/\", page=home_page))\napp.add_route(Route(title=\"About\", path=\"/about\", page=about_page))\n</code></pre>"},{"location":"basics/router/#navigating-between-routes","title":"Navigating Between Routes","text":"<p>Use the <code>navigate</code> method to programmatically navigate to a different route.</p> <pre><code>await app.navigate(\"/about\")\n</code></pre>"},{"location":"basics/router/#handling-current-location","title":"Handling Current Location","text":"<p>The <code>handle_location</code> method mounts the page associated with the current location.</p> <pre><code>await app.handle_location()\n</code></pre>"},{"location":"basics/router/#navigation-history","title":"Navigation History","text":"<p>Navigate back and forth through the history stack using the <code>back</code> and <code>forward</code> methods.</p> <pre><code>await app.back()\nawait app.forward()\n</code></pre>"},{"location":"basics/router/#getting-the-current-route","title":"Getting the Current Route","text":"<p>Retrieve the current route's page and title using the <code>get_current_route</code> method.</p> <pre><code>current_route = app.get_current_route() \nprint(current_route)\n</code></pre>"},{"location":"basics/router/#handle-params-and-queries","title":"Handle params and queries","text":"<p>Retrieve the current route with it's params and queries</p> <pre><code>route = Route(\"test\", \"/test\", Page([]), None)\nrouter = App()\nrouter.add_route(route)\nself.window.location.pathname = \"/test/123/123?k=1&amp;k2=3\"\ncurrent_route, info = self.router.get_current_route()\nprint(info[\"wildcard\"][\"params\"]) #  [\"123\", \"123\"]\nprint(info[\"wildcard\"][\"query\"][\"k\"]) # 1\nprint(info[\"wildcard\"][\"query\"][\"k2\"]) # 3\n</code></pre>"},{"location":"basics/router/#handle-wild-card-client-routes","title":"Handle wild card client routes","text":"<p>Zenaura router handles wild card routes if they are defined as follow : <pre><code>route = Route(\"wildcard\", \"/users/*\", Page([]), None)\nrouter = App()\nrouter.add_route(route)\nself.window.location.pathname = \"/users/123/123?k=1&amp;k2=3\"\ncurrent_route, info = self.router.get_current_route()\nprint(info[\"wildcard\"][\"params\"]) #  [\"123\", \"123\"]\nprint(info[\"wildcard\"][\"query\"][\"k\"]) # 1\nprint(info[\"wildcard\"][\"query\"][\"k2\"]) # 3\n</code></pre></p>"},{"location":"basics/router/#adding-middleware-that-runs-before-the-route-is-matched","title":"Adding middleware that runs before the route is matched","text":"<p>In every route you can define a middleware a specific logic that runs before zenaura match the route and mount the page: <pre><code>middleware_order = []\ndef middleware1():\n    middleware_order.append(1)\n    print(middleware_order)\n\ndef middleware2():\n    middleware_order.append(2)\n    print(middleware_order)\n\ndef middleware():\n    middleware1()\n    middleware2()\n\nroute = Route(\"middlewareorder\", \"/middleware\", Page([]), middleware)\nrouter = App()\nrouter.add_route(route)\nawait router.navigate(\"/middleware\") \n# prints [1]\n# prints [1, 2]\n</code></pre></p>"},{"location":"basics/router/#route-configuration","title":"Route Configuration","text":"<p>The <code>Route</code> class represents the configuration for each route.</p>"},{"location":"basics/router/#attributes_1","title":"Attributes","text":"<ul> <li><code>title</code> (str): The title of the route.</li> <li><code>path</code> (str): The path of the route.</li> <li><code>page</code> (Page): The page component associated with the route.</li> <li><code>middleware</code> (Optional[Callable]): Optional middleware function to be executed.</li> <li><code>ssr</code> (bool): Indicates if the route is server-side rendered.</li> </ul>"},{"location":"basics/router/#example","title":"Example","text":"<pre><code>route = Route(title=\"Home\", path=\"/\", page=home_page)\napp.add_route(route)\n</code></pre>"},{"location":"basics/router/#handling-not-found-pages","title":"Handling Not Found Pages","text":"<p>If a route is not found, the <code>not_found</code> method displays a \"Page Not Found\" message.</p> <pre><code>class NotFound(Page):\n    def render(self):\n        return Builder(\"div\").with_text(\"Page Not Found\").build()\n\napp.not_found_page = NotFound()\n</code></pre>"},{"location":"basics/router/#example-complete-router-setup","title":"Example: Complete Router Setup","text":"<p>Here's an example demonstrating the full setup of the Zenaura Router:</p> <pre><code>from zenaura.client.app import App, Route\nfrom zenaura.client.component import Page\nfrom zenaura.client.tags.builder import Builder\n\nclass HomeComponent(Page):\n    def render(self):\n        return Builder(\"div\").with_text(\"Welcome to the Home Page\").build()\n\nclass AboutComponent(Page):\n    def render(self):\n        return Builder(\"div\").with_text(\"About Us\").build()\n\nclass NotFound(Page):\n    def render(self):\n        return Builder(\"div\").with_text(\"Page Not Found\").build()\n\n# Initialize the app\napp = App()\n\n# Define pages\nhome_page = Page([HomeComponent()])\nabout_page = Page([AboutComponent()])\n\n# Add routes\napp.add_route(Route(title=\"Home\", path=\"/\", page=home_page))\napp.add_route(Route(title=\"About\", path=\"/about\", page=about_page))\n\n# Set not found page\napp.not_found_page = NotFound()\n\n# Handle initial location\nawait app.handle_location()\n\n# Navigate to a different route\nawait app.navigate(\"/about\")\n\n# Navigate back and forth\nawait app.back()\nawait app.forward()\n</code></pre>"},{"location":"basics/router/#summary","title":"Summary","text":"<p>The Zenaura Router (<code>App</code> class) provides a robust way to manage routes and navigation within your application. By defining routes, handling navigation, and managing browser history, you can create a seamless user experience. This guide covers the essential methods and setup needed to get started with routing in Zenaura.</p>"},{"location":"basics/state/","title":"Zenaura Component State Management","text":"<p>State management is a crucial aspect of building dynamic and interactive user interfaces. In Zenaura, components can maintain and update their state to reflect changes in the application. This guide will walk you through the basics of managing state within Zenaura components.</p>"},{"location":"basics/state/#understanding-state-in-components","title":"Understanding State in Components","text":"<p>State in Zenaura components refers to the data that changes over time and drives the UI. Each stateful component can hold its own state, which can be updated in response to user interactions or other events.</p>"},{"location":"basics/state/#example-of-a-simple-stateful-component","title":"Example of a Simple Stateful Component","text":"<p>Let's create a simple counter component to illustrate how state works in Zenaura.</p> <pre><code>from zenaura.client.component import Component\nfrom zenaura.client.tags.builder import Builder\nfrom zenaura.client.mutator import mutator\n\nclass Counter(Component):\n    def __init__(self):\n        super().__init__()\n        self.set_state({\"count\": 0})\n\n    @mutator\n    async def increment(self, event):\n        current_count = self.get_state()[\"count\"]\n        self.set_state({\"count\": current_count + 1})\n\n    @mutator\n    async def decrement(self, event):\n        current_count = self.get_state()[\"count\"]\n        self.set_state({\"count\": current_count - 1})\n\n    def render(self):\n        count = self.get_state()[\"count\"]\n        return Builder(\"div\").with_children([\n            Builder(\"h1\").with_text(f\"Count: {count}\").build(),\n            Builder(\"button\").with_text(\"+\").with_attribute(\"py-click\", f\"{self.instance_name}.increment\").build(),\n            Builder(\"button\").with_text(\"-\").with_attribute(\"py-click\", f\"{self.instance_name}.decrement\").build()\n        ]).build()\n</code></pre>"},{"location":"basics/state/#explanation","title":"Explanation","text":"<ol> <li>Initialization: The <code>Counter</code> component initializes its state with a <code>count</code> value of <code>0</code> in the <code>__init__</code> method.</li> <li>Mutators: The <code>increment</code> and <code>decrement</code> methods are marked with the <code>@mutator</code> decorator, indicating that they can modify the component's state, mutate the component and trigger a zenaura dom re-render. These methods update the <code>count</code> value based on user interactions.</li> <li>Rendering: The <code>render</code> method constructs the UI using the <code>Builder</code> interface. It creates an <code>h1</code> element to display the count and two buttons to increment and decrement the count.</li> </ol> <p>Note when a user click on increment or decrement button the data follow will be as follow: 1. Pydide will call increment function. 2. increment function will run the code mutate the state. 3. mutator funciton will call the zenaura virtual dom to kick starts the diffing algorithm and patch update the real dom. 4. user see count increased by 1.</p>"},{"location":"basics/state/#handling-state-changes","title":"Handling State Changes","text":"<p>State changes in Zenaura components are handled by mutator methods. These methods are asynchronous and use the <code>@mutator</code> decorator to indicate that they will modify the component's state.</p> <p>The reason they are asynchronous because zenaura dom patch updates the real dom in non-blocking high performant way using scheduling and tasks, expressed as optimized dom minipulations patch updates.</p>"},{"location":"basics/state/#example-of-a-stateful-component-with-multiple-states","title":"Example of a Stateful Component with Multiple States","text":"<p>Here's an example of a component managing multiple pieces of state:</p> <pre><code>from zenaura.client.component import Component\nfrom zenaura.client.tags.builder import Builder\nfrom zenaura.client.mutator import mutator\n\nclass UserProfile(Component):\n    def __init__(self):\n        super().__init__()\n        self.set_state({\n            \"name\": \"John Doe\",\n            \"age\": 30\n        })\n\n    @mutator\n    async def update_name(self, event):\n        new_name = event.target.value  # Assume this value comes from an input field\n        self.set_state({\"name\": new_name})\n\n    @mutator\n    async def increment_age(self, event):\n        current_age = self.get_state()[\"age\"]\n        self.set_state({\"age\": current_age + 1})\n\n    def render(self):\n        state = self.get_state()\n        return Builder(\"div\").with_children([\n            Builder(\"h1\").with_text(f\"Name: {state['name']}\").build(),\n            Builder(\"input\").with_attribute(\"value\", state['name']).with_attribute(\"py-change\", f\"{self.instance_name}.update_name\").build(),\n            Builder(\"h2\").with_text(f\"Age: {state['age']}\").build(),\n            Builder(\"button\").with_text(\"Increase Age\").with_attribute(\"py-click\", f\"{self.instance_name}.increment_age\").build()\n        ]).build()\n</code></pre>"},{"location":"basics/state/#explanation_1","title":"Explanation","text":"<ol> <li>Initialization: The <code>UserProfile</code> component initializes its state with <code>name</code> and <code>age</code>.</li> <li>Mutators: The <code>update_name</code> method updates the <code>name</code> state based on user input, while the <code>increment_age</code> method increments the <code>age</code> state.</li> <li>Rendering: The <code>render</code> method creates a UI that includes an <code>h1</code> element for the name, an input field for updating the name, an <code>h2</code> element for the age, and a button to increment the age.</li> </ol>"},{"location":"basics/state/#best-practices-for-state-management","title":"Best Practices for State Management","text":"<ol> <li>Keep State Localized: Manage state within the component that needs it. If multiple components need the same state, consider lifting the state up using a subject which is an intermediate concept we will cover in Beyond the basics guide. </li> <li>Use Mutators for State Changes: Always use <code>@mutator</code>-decorated methods to modify the state. This ensures that state changes are tracked and the UI is updated correctly.</li> <li>Initialize State in the Constructor: Set initial state values in the <code>__init__</code> method to ensure the component starts with a known state.</li> <li>for event handlers use py-* for py-script , for example if you are using JS function you will pass onclick=\"jsfunction\", but for python we need the instance name, then py- e.g.: py-click, py-change, py-hover."},{"location":"basics/state/#summary","title":"Summary","text":"<p>In this guide, we've covered the basics of managing state in Zenaura components. We created examples of stateful components and discussed how to handle state changes using mutators. Following these principles will help you build dynamic and interactive UIs with Zenaura.</p>"},{"location":"basics/user_events/","title":"Handling User Events in Zenaura","text":"<p>In Zenaura, handling user events is a key aspect of creating interactive and dynamic applications. This guide will cover how Zenaura processes user events, updates the state, and re-renders components.</p>"},{"location":"basics/user_events/#overview","title":"Overview","text":"<p>The workflow in Zenaura for handling user events follows this sequence: 1. User Event: An event (e.g., click, input change) occurs in the browser. 2. Mutate State: The event triggers a mutator method in the component, which updates the component's state. 3. Re-render Component: Zenaura compares the new state with the previous state and generates a virtual DOM diff. 4. Render Component on the Browser: The diff is applied to update the actual DOM in the browser.</p>"},{"location":"basics/user_events/#example-of-handling-user-events","title":"Example of Handling User Events","text":"<p>Let's illustrate this with an example. We will create a simple counter component that increments and decrements a count value based on button clicks.</p> <pre><code>from zenaura.client.component import Component\nfrom zenaura.client.tags.builder import Builder\nfrom zenaura.client.mutator import mutator\nfrom zenaura.client.tags import Node, Attribute\n\nclass Counter(Component):\n    def __init__(self):\n        super().__init__()\n        self.set_state({\"count\": 0})\n\n    @mutator\n    async def increment(self, event):\n        self.set_state({\"count\": self.get_state()[\"count\"] + 1})\n\n    @mutator\n    async def decrement(self, event):\n        self.set_state({\"count\": self.get_state()[\"count\"] - 1})\n\n    def render(self):\n        count = self.get_state()[\"count\"]\n        return Builder(\"div\").with_children([\n            Builder(\"h1\").with_text(f\"Count: {count}\").build(),\n            Builder(\"button\").with_text(\"+\").with_attribute(\"py-click\", f\"{self.instance_name}.increment\").build(),\n            Builder(\"button\").with_text(\"-\").with_attribute(\"py-click\", f\"{self.instance_name}.decrement\").build()\n        ]).build()\n\ncounter = Counter()\n</code></pre>"},{"location":"basics/user_events/#explanation","title":"Explanation","text":"<ol> <li>User Event: When the user clicks the \"+\" or \"-\" button, a <code>click</code> event is triggered.</li> <li>Mutate State: The event handler (<code>increment</code> or <code>decrement</code> method) is called. These methods are decorated with <code>@mutator</code>, indicating that they will change the component's state.</li> <li>Re-render Component: After the state is updated, Zenaura automatically triggers a re-render of the component. The <code>render</code> method is called again with the updated state.</li> <li>Render Component on the Browser: Zenaura performs a virtual DOM diff between the previous and new states. Only the changed parts of the DOM are updated in the browser, ensuring efficient rendering.</li> </ol>"},{"location":"basics/user_events/#detailed-steps","title":"Detailed Steps","text":""},{"location":"basics/user_events/#1-user-event","title":"1. User Event","text":"<p>User events are linked to component methods using the <code>py-click</code>, <code>py-change</code>, and other attributes in the <code>Builder</code> interface. For example:</p> <pre><code>Builder(\"button\").with_text(\"+\").with_attribute(\"py-click\", f\"{self.instance_name}.increment\").build()\n</code></pre> <p>The <code>py-click</code> attribute specifies that the <code>increment</code> method of the component instance should be called when the button is clicked.</p>"},{"location":"basics/user_events/#2-mutate-state","title":"2. Mutate State","text":"<p>Mutator methods are defined with the <code>@mutator</code> decorator. These methods update the component's state and ensure that the changes are tracked:</p> <pre><code>@mutator\nasync def increment(self, event):\n    self.set_state({\"count\": self.get_state()[\"count\"] + 1})\n</code></pre> <p>The <code>set_state</code> method updates the state and triggers a re-render.</p>"},{"location":"basics/user_events/#3-re-render-component","title":"3. Re-render Component","text":"<p>When the state is updated, Zenaura automatically calls the <code>render</code> method of the component to generate the new virtual DOM:</p> <pre><code>def render(self):\n    count = self.get_state()[\"count\"]\n    return Builder(\"div\").with_children([\n        Builder(\"h1\").with_text(f\"Count: {count}\").build(),\n        Builder(\"button\").with_text(\"+\").with_attribute(\"py-click\", f\"{self.instance_name}.increment\").build(),\n        Builder(\"button\").with_text(\"-\").with_attribute(\"py-click\", f\"{self.instance_name}.decrement\").build()\n    ]).build()\n</code></pre>"},{"location":"basics/user_events/#4-render-component-on-the-browser","title":"4. Render Component on the Browser","text":"<p>Zenaura compares the previous virtual DOM with the new virtual DOM and applies only the differences to the actual DOM. This diffing algorithm ensures efficient updates and minimizes reflows and repaints in the browser.</p>"},{"location":"basics/user_events/#best-practices","title":"Best Practices","text":"<ol> <li>Use Mutators for State Changes: Always use <code>@mutator</code>-decorated methods to handle state changes. This ensures the state changes are tracked and the component is re-rendered correctly.</li> <li>Keep Event Handlers Simple: Event handlers should focus on updating the state. Avoid complex logic in event handlers; instead, delegate it to other methods or services.</li> <li>Optimize Rendering: Ensure that your <code>render</code> method is efficient. Avoid unnecessary computations or side effects in the <code>render</code> method.</li> </ol>"},{"location":"basics/user_events/#summary","title":"Summary","text":"<p>In this guide, we've covered how Zenaura handles user events and updates the component state. The sequence of user events leading to state mutations, virtual DOM diffing, and efficient rendering ensures that Zenaura applications are both interactive and performant. By following these principles, you can build dynamic and responsive user interfaces with Zenaura.</p>"},{"location":"examples/contributing/","title":"Contributing to zenaura examples:","text":"<p>The following guide shows steps to contribute your example so it can be featured on zenaura documentation page.</p> <ol> <li>Create the example Repo on GitHub. </li> <li>Test the example make sure it's working.</li> <li>Fork zenaura.</li> <li>Create pull request where you add the example into the proper example section:<ul> <li>docs/examples/basic/my_example.md</li> <li>docs/examples/intermediate/my_example.md</li> <li>docs/examples/advanced/my_example.md</li> </ul> </li> <li>Make sure you correctly set the difficulty of the example, basic example should touch on zenaura basics, intermediate example should touch on zenaura intermediate and advanced example should touch on zenaura advanced.</li> <li>Create your example markdown with the following format, copy template.md :<ul> <li>Author: authorName</li> <li>Title: title of the example</li> <li>Description: Brief description of the example.</li> <li>Example GitHub URL.</li> </ul> </li> <li>add your example to mkdocs.yml <pre><code> - Basic Examples:\n      - A counter app: examples/basic/counter.md\n      - My Example Name: examples/basic/my_example.md # here\n    - Beyond The Basics Examples:\n      - Cory Game of Life: examples/intermediate/game_of_life.md\n    - Advanced Examples:\n      - Admin Portal: examples/advanced/admin_portal.md\n</code></pre></li> <li>create pull request.</li> </ol>"},{"location":"examples/start_here/","title":"Starting With Zenaura Examples.","text":"<p>Before jumping into the examples make sure you finished the Quick start guide, and at least the Basics guide. </p> <p>Zenaura have a repository where all examples live can be found here: Zenaura examples</p> <p>For every example you must follow the following steps:</p>"},{"location":"examples/start_here/#1-clone-the-example-on-your-device","title":"1. clone the example on your device :","text":"<pre><code>git clone https://github.com/ARAldhafeeri/zenaura-examples.git\n</code></pre>"},{"location":"examples/start_here/#2-navigate-into-the-example-and-open-a-terminal-build-run-the-example","title":"2. navigate into the example and open a terminal, build , run the example:","text":"<pre><code>zenaura build \n</code></pre> <pre><code>zenaura run\n</code></pre> <p>the example should be live at localhost -&gt; http://localhost:5000/</p>"},{"location":"examples/template/","title":"This is the title for the example","text":""},{"location":"examples/template/#about","title":"About","text":"<p>this is brief description of the example ...</p>"},{"location":"examples/template/#author","title":"Author","text":"<p>Araldhafeeri</p>"},{"location":"examples/template/#example-link","title":"Example link :","text":"<p>Example source code</p>"},{"location":"examples/template/#live-demo-optional","title":"Live demo ( Optional )","text":"<p>Live demo</p>"},{"location":"examples/advanced/data_fetching/","title":"Data Fetching and API integration with zenaura","text":""},{"location":"examples/advanced/data_fetching/#about","title":"About","text":"<p>The following advanced example showcase how to integrate with API endpoints and display data.</p>"},{"location":"examples/advanced/data_fetching/#author","title":"Author","text":"<p>Araldhafeeri</p>"},{"location":"examples/advanced/data_fetching/#example-link","title":"Example link :","text":"<p>Example source code</p>"},{"location":"examples/advanced/game_of_life/","title":"Game of Life implementation with Python.","text":""},{"location":"examples/advanced/game_of_life/#about","title":"About","text":"<p>The following advanced example showcase the game of life implementation with Python and Zenaura.</p>"},{"location":"examples/advanced/game_of_life/#author","title":"Author","text":"<p>Araldhafeeri</p>"},{"location":"examples/advanced/game_of_life/#example-link","title":"Example link :","text":"<p>Example source code</p>"},{"location":"examples/basic/counter/","title":"Counter example with navigation","text":""},{"location":"examples/basic/counter/#about","title":"About","text":"<p>The following simple example have single counter, and navigation between two pages.</p>"},{"location":"examples/basic/counter/#author","title":"Author","text":"<p>Araldhafeeri</p>"},{"location":"examples/basic/counter/#example-link","title":"Example link :","text":"<p>Example source code</p>"},{"location":"examples/intermediate/global_state/","title":"Synced 4 counters","text":""},{"location":"examples/intermediate/global_state/#about","title":"About","text":"<p>The following simple example have 4 counters, and global subject, whenever counter 1 reaches the count 5, all the other counters reset.</p>"},{"location":"examples/intermediate/global_state/#author","title":"Author","text":"<p>Araldhafeeri</p>"},{"location":"examples/intermediate/global_state/#example-link","title":"Example link :","text":"<p>Example source code</p>"},{"location":"examples/intermediate/handling_forms/","title":"Simple form","text":""},{"location":"examples/intermediate/handling_forms/#about","title":"About","text":"<p>The following simple example show case how to handle forms with zenaura application </p>"},{"location":"examples/intermediate/handling_forms/#author","title":"Author","text":"<p>Araldhafeeri</p>"},{"location":"examples/intermediate/handling_forms/#example-link","title":"Example link :","text":"<p>Example source code</p>"},{"location":"intermediate/forms/","title":"Handling Forms in Zenaura","text":"<p>Handling forms efficiently in Zenaura involves managing form states and handlers in a structured way. This guide will walk you through creating and handling a form using a pattern that mimics dependency injection to keep your code clean and maintainable.</p>"},{"location":"intermediate/forms/#step-1-define-needed-presentaional-components","title":"Step 1: Define Needed presentaional components","text":"<p>First, create needed presentational components such as <code>Label</code>, <code>Input</code>, and <code>Button</code>, <code>TextArea</code>, and <code>Form</code>.</p> <p>In <code>presentational.py</code></p> <pre><code>from zenaura.client.tags.builder import Builder\n\ndef Div(class_name, children):\n    div = Builder('div').with_attribute('class', class_name).build()\n    div.children = children\n    return div\n\ndef Label(text):\n    return Builder('label').with_text(text).build()\n\ndef Input(type, name, oninput):\n    return Builder('input').with_attributes(\n        type=type,\n        name=name,\n    ).with_attribute(\n        \"py-change\", oninput\n    ).build()\n\ndef TextArea(name, oninput):\n    return Builder('textarea').with_attributes(\n        name=name,\n    ).with_attribute(\n        \"py-change\", oninput\n    ).build()\n\ndef Button(type, text):\n    return Builder('button').with_attributes(\n        type=type\n    ).with_text(text).build()\n\ndef UserForm(onsubmit, handle_input):\n    return Builder('form').with_attribute(\n        \"py-submit\", onsubmit\n    ).with_children(\n        Div('form-group', [\n            Label(\"Name:\"),\n            Input(\"text\", \"name\", handle_input),\n            Label(\"Email:\"),\n            Input(\"email\", \"email\", handle_input),\n\n            Label(\"Message:\"),\n            TextArea(\"message\", handle_input),\n            Button(\"submit\", \"Submit\")\n        ])\n    ).build()\n</code></pre>"},{"location":"intermediate/forms/#step-2-we-will-create-our-form-component","title":"Step 2: We will create our Form component","text":"<p>The form component will handle 3 fields, name, email, message, and submit button.</p> <p>in <code>components.py</code></p> <pre><code>from zenaura.client.component import Component\nfrom public.presentational import UserForm\n\nclass UserFormComponent(Component):\n    def __init__(self, instance_name):\n        super().__init__()\n        self.instance_name = instance_name\n        self.state = {\n\n                \"name\": \"\",\n\n                \"email\": \"\",\n\n                \"message\": \"\"\n\n            }\n\n    def update_state(self, field, value):\n\n        self.state[field] = value\n\n    def submit_form(self):\n\n        print(\"Form submitted with:\", self.state)\n    def handle_input(self, event):\n        field = event.target.name\n        value = event.target.value\n        self.update_state(field, value)\n        print(self.state)\n\n\n    def handle_submit(self, event):\n        event.preventDefault()\n        self.submit_form()\n\n    def render(self):\n        return UserForm(f\"{self.instance_name}.handle_submit\",f\"{self.instance_name}.handle_input\")\n</code></pre>"},{"location":"intermediate/forms/#step-3-link-the-form-to-a-page","title":"Step 3: Link the form to a page","text":"<p>finally we link the form to a page in <code>main.py</code></p>"},{"location":"intermediate/forms/#application-component","title":"Application Component","text":"<pre><code>from zenaura.client.app import Route, App\nfrom zenaura.client.page import Page\nfrom public.routes import ClientRoutes\nfrom public.components import UserFormComponent\nimport asyncio\n\nstarter = UserFormComponent(\"starter\")\n\n# App and routing\nrouter = App()\nhome_page = Page([starter])\n\nrouter.add_route(Route(\n    title=\"Developer-Focused | Zenaura\",\n    path=ClientRoutes.home.value,\n    page=home_page\n))\n\n# Run the application\nevent_loop = asyncio.get_event_loop()\nevent_loop.run_until_complete(router.handle_location())\n</code></pre>"},{"location":"intermediate/forms/#step-4-build-and-run-the-application","title":"Step 4: build and run the application","text":"<p><pre><code>zenaura build\n</code></pre> <pre><code>zenaura run\n</code></pre></p> <p>Note in the console when we type in the input field, the state is updated and printed out, when we submit we get the following message in the console of the browser </p> <pre><code>Form submitted with: {'name': 'sdf', 'email': 'sdf@gmail.com', 'message': 'alksdfhe'}\n</code></pre>"},{"location":"intermediate/forms/#summary","title":"Summary","text":"<p>In this guide, we've demonstrated how to handle forms in Zenaura using a pattern that mimics dependency injection. By separating the form handling logic into a dedicated <code>FormHandler</code> class and passing it as a dependency to the form component, we've achieved a clean and maintainable structure.</p>"},{"location":"intermediate/forms/#key-points","title":"Key Points:","text":"<ul> <li>FormHandlers: Manages form state and submission logic, it can live within the form component or seperated class.</li> <li>Form Component: Handles user input and form submission, utilizing the <code>FormHandler</code>.</li> <li>Application Component: Integrates the form into the application and passes the handler as a dependency.</li> <li>Main Entry Point: Renders the application.</li> </ul> <p>This pattern keeps your codebase modular and promotes separation of concerns, making it easier to manage and extend.</p> <p>The example is available in the examples repository under Handling_forms directory.</p>"},{"location":"intermediate/global_comp/","title":"Global Componets","text":""},{"location":"intermediate/global_comp/#handling-global-components-with-higher-order-components","title":"Handling Global Components with Higher Order Components","text":"<p>Global components are components used in multiple places within an application. Examples include navigation bars, footers, or modals that appear consistently across various pages. To efficiently manage these components and adhere to the DRY (Don't Repeat Yourself) principle, you can utilize Higher Order Components (HOCs).</p>"},{"location":"intermediate/global_comp/#why-use-global-components","title":"Why Use Global Components?","text":"<ul> <li>Maintainability: Enhances the codebase's maintainability and comprehensibility by centralizing component logic.</li> <li>Evolvability: Facilitates easier updates and changes. For instance, modifying a nav bar component will automatically reflect the changes across all the pages where it is used.</li> </ul>"},{"location":"intermediate/global_comp/#step-1-create-a-global-component","title":"Step 1: Create a Global Component","text":"<p>Design your global component. This can range from a simple navigation bar to a complex global modal that appears with different content throughout the application. For the simplicity of this tutorial, we'll create a nav bar component.</p>"},{"location":"intermediate/global_comp/#example-creating-a-navbar-component","title":"Example: Creating a NavBar Component","text":"<p>In <code>presentational.py</code></p> <p><pre><code>from zenaura.client.tags.builder import Builder\nfrom zenaura.client.tags.node import Node, Attribute\n\ndef Paragraph(text, class_name=None):\n    builder = Builder('p').with_text(text)\n    if class_name:\n        builder = builder.with_attribute('class', class_name)\n    return builder.build()\n\ndef Header1(text):\n    return Builder('h1').with_text(text).build()\n\ndef Div(class_name, children):\n    div = Builder('div').with_attribute('class', class_name).build()\n    div.children = children\n    return div\n\ndef NavItemText(href, text):\n    return Builder('a').with_attribute('href', href).with_text(text).build()\n</code></pre> in <code>main.py</code> we create a <code>NavBar</code> component:</p> <pre><code>from zenaura.client import Component, Reuseable\nfrom public.presentational import Div, NavItemText, Header1, Paragraph\nfrom zenaura.client.app import App, Route\nfrom zenaura.client.page import Page\n\n@Reuseable\nclass NavBar(Component):\n    def render(self):\n        return Div(\"navbar\",[\n            NavItemText(\"Home\", \"/\"),\n            NavItemText(\"About\", \"/about\"),\n            NavItemText(\"Contact\", \"/contact\")\n        ])\n</code></pre>"},{"location":"intermediate/global_comp/#step-2-create-a-higher-order-component-hoc","title":"Step 2: Create a Higher Order Component (HOC)","text":"<p>Higher Order Components are functions that take a component and return a new component with additional properties or behavior. We'll create an HOC that wraps a given page component with our <code>NavBar</code> component.</p>"},{"location":"intermediate/global_comp/#example-creating-an-hoc","title":"Example: Creating an HOC","text":"<p>Create a new file <code>main.py</code> and define the HOC:</p> <p><pre><code># previous code \ndef with_navbar(page_children):\n    return [\n        NavBar(),\n        *page_children\n    ]\n</code></pre> Note: here we are passing the global component, and the rest of the page children.</p>"},{"location":"intermediate/global_comp/#step-3-apply-the-hoc-to-your-page-components","title":"Step 3: Apply the HOC to Your Page Components","text":"<p>Now, you can apply the <code>with_navbar</code> HOC to your page components to include the <code>NavBar</code> globally.</p>"},{"location":"intermediate/global_comp/#example-applying-the-hoc","title":"Example: Applying the HOC","text":"<p>Let's say you have a <code>HomePage</code>, <code>AboutPage</code>, and <code>ContactPage</code> component defined in <code>main.py</code>:</p> <pre><code>class HomePage(Component):\n    def render(self):\n        return Div(\"homepage\", [\n            Header1(\"Home Page\"), \n            Paragraph(\"This is the home page\")\n        ])\n\nclass AboutPage(Component):\n    def render(self):\n        return Div(\"aboutpage\", [\n            Header1(\"About Page\"), \n            Paragraph(\"This is the about page\")\n        ])\n\nclass ContactPage(Component):\n    def render(self):\n        return Div( \"contactpage\", [\n            Header1(\"Contact Page\"), \n            Paragraph(\"This is the contact page\")\n        ])\n</code></pre> <p>You can apply the <code>with_navbar</code> HOC to this component as follows:</p> <pre><code>router = App()\nrouter.add_route(\n    Route(\n        \"Home\", \n        \"/\",\n        Page(\n            with_navbar([HomePage()])\n       ) \n    )\n)\n\nrouter.add_route(\n    Route(\n        \"About\", \n        \"/about\",\n        Page(\n            with_navbar([AboutPage()])\n        ) \n    )\n)\n\nrouter.add_route(\n    Route(\n        \"Contact\", \n        \"/contact\",\n        Page(\n            with_navbar([ContactPage()])\n        ) \n    )\n)\n</code></pre> <p>Full <code>main.py</code>:</p> <p><pre><code>from zenaura.client.component import Component, Reuseable\nfrom public.presentational import Div, NavItemText, Header1, Paragraph\nfrom zenaura.client.app import App, Route\nfrom zenaura.client.page import Page\nimport asyncio\n@Reuseable\nclass NavBar(Component):\n    def render(self):\n        return Div(\"navbar\",[\n            NavItemText(\"Home\", \"/\"),\n            NavItemText(\"About\", \"/about\"),\n            NavItemText(\"Contact\", \"/contact\")\n        ])\n\n\ndef with_navbar(page_children):\n    return [\n        NavBar(),\n        *page_children\n    ]\n\nclass HomePage(Component):\n    def render(self):\n        return Div(\"homepage\", [\n            Header1(\"Home Page\"), \n            Paragraph(\"This is the home page\")\n        ])\n\nclass AboutPage(Component):\n    def render(self):\n        return Div(\"aboutpage\", [\n            Header1(\"About Page\"), \n            Paragraph(\"This is the about page\")\n        ])\n\nclass ContactPage(Component):\n    def render(self):\n        return Div( \"contactpage\", [\n            Header1(\"Contact Page\"), \n            Paragraph(\"This is the contact page\")\n        ])\n\nrouter = App()\nrouter.add_route(\n    Route(\n        \"Home\", \n        \"/\",\n        Page(\n            with_navbar([HomePage()])\n       ) \n    )\n)\n\nrouter.add_route(\n    Route(\n        \"About\", \n        \"/about\",\n        Page(\n            with_navbar([AboutPage()])\n        ) \n    )\n)\n\nrouter.add_route(\n    Route(\n        \"Contact\", \n        \"/contact\",\n        Page(\n            with_navbar([ContactPage()])\n        ) \n    )\n)\n\n# Run the application\nevent_loop = asyncio.get_event_loop()\nevent_loop.run_until_complete(router.handle_location())\n</code></pre> Basically, we return the page children with the global component, as a Page in zenaura expect a list of components. This way, whenever we need the navbar with a specific page, we pass with_navbar HOC to the page component, with the page children as list.</p>"},{"location":"intermediate/global_comp/#conclusion","title":"Conclusion","text":"<p>By creating global components and using Higher Order Components (HOCs), you can efficiently manage and reuse common UI elements across your application. This approach not only improves maintainability but also ensures a consistent user experience across different pages.</p> <p>Explore further by creating more complex global components and integrating them using HOCs to enhance your application's architecture and usability.</p>"},{"location":"intermediate/global_state/","title":"Global State","text":""},{"location":"intermediate/global_state/#managing-global-state-with-the-observer-pattern","title":"Managing Global State with the Observer Pattern","text":"<p>In this guide, we'll implement a global state management system using the Observer pattern. We'll create four counters, and when Counter 1 reaches 5, all counters will reset. This example will demonstrate how to use subjects and observers to manage global state in a Zenaura application.</p>"},{"location":"intermediate/global_state/#step-1-create-needed-presentational-components","title":"Step 1: Create needed presentational components","text":"<pre><code>from zenaura.client.tags.builder import Builder\nfrom zenaura.client.tags.node import Node, Attribute\n\ndef Header1(text):\n    return Builder('h1').with_text(text).build()\n\ndef Paragraph(text, class_name=None):\n    builder = Builder('p').with_text(text)\n    if class_name:\n        builder = builder.with_attribute('class', class_name)\n    return builder.build()\n\ndef Div(class_name, children):\n    div = Builder('div').with_attribute('class', class_name).build()\n    div.children = children\n    return div\n\ndef Button(class_name, text, onclick_handler=None, name=None):\n    builder = Builder('button').with_attribute('class', class_name).with_text(text)\n    if onclick_handler:\n        builder = builder.with_attribute('py-click', onclick_handler)\n    if name:\n        builder = builder.with_attribute(\"name\", name)\n    return builder.build()\n\ndef CounterPresntaional(increaseBtn, headertext, count) -&gt; Node:\n    return Builder(\"div\") \\\n        .with_attribute(\"id\", \"large-header\") \\\n        .with_children(\n            headertext,\n            increaseBtn\n        ).build()\n</code></pre>"},{"location":"intermediate/global_state/#step-2-observer-subject-counter-component","title":"Step 2: Observer, Subject, Counter component","text":"<p>First, we need to import our <code>Observer</code> abstract base class and our <code>Subject</code> class that will manage the observers. Also we will define some presentational components that helps us build the counters. </p> <p>importing the <code>Observer</code>, <code>Subject</code>. <pre><code>from zenaura.client.observer import Observer, Subject\n</code></pre> importing presentational components </p> <pre><code>from public.presentational import Div, Header1, CounterPresntaional, Button\n</code></pre> <p>creating the <code>Subject</code> class that will manage the observers. and the <code>CounterObserver</code> class that will react to state changes.</p> <pre><code># Create the subject\ncounter_subject = Subject()\ncounter_subject.state = {\"counter1\": 0, \"counter2\": 0, \"counter3\": 0, \"counter4\": 0}\n\n\n# create counter observer:\nclass CounterObserver(Observer):\n    pass\n</code></pre> <p>now we will create the counter component, where we manage a global state between different instances of it.</p> <p><pre><code>@Reuseable\nclass Counter(Component, CounterObserver):\n    def __init__(self, subject, counter_name):\n        super().__init__()\n        self.subject = subject\n        self.subject.attach(self)\n        self.counter_name = counter_name\n\n    @mutator\n    async def increment(self, event):\n        self.subject.state[self.counter_name] += 1\n        self.subject.notify()\n\n    def update(self, value):\n        if self.subject.state[\"counter1\"] == 5:\n            for k in self.subject.state.keys():\n                self.subject.state[k] = 0\n        asyncio.get_event_loop().run_until_complete(zenaura_dom.render(self))\n\n    def render(self):\n        return Div(\"container\", [\n            CounterPresntaional(\n                Button(\"btn\", \"Increment\", f\"{self.counter_name}.increment\"),\n                Header1(f\"count {self.subject.state[self.counter_name]}\"),\n                self.subject.state[self.counter_name],\n\n            )\n        ])\n</code></pre> In init,</p> <pre><code>class Counter(Component, CounterObserver):\n    def __init__(self, subject, counter_name):\n        super().__init__()\n        self.subject = subject\n        self.subject.attach(self)\n        self.counter_name = counter_name\n</code></pre> <p>We link every instance of the counter to the global subject, since subject will only call counterInstance.update.</p> <p>In increment, <pre><code>@mutator\nasync def increment(self, event):\n    self.subject.state[self.counter_name] += 1\n    self.subject.notify()\n</code></pre></p> <p>we decorate with mutator so the component re-renders after increment called which is user event. </p> <p>In update,  <pre><code>  def update(self, value):\n        if self.subject.state[\"counter1\"] == 5:\n            for k in self.subject.state.keys():\n                self.subject.state[k] = 0\n        asyncio.get_event_loop().run_until_complete(zenaura_dom.render(self))\n</code></pre> we implement the functionality of the global state, reseting all the counters when counter 1 reaches 5. Note we are calling asycnio.get_event_loop().run_until_complete(zenaura_dom.render(self)) to render the component.</p> <p>This is for the fact zenaura_dom will update the real dom asyncrounsly, in non-blocking way, and self refer to an instance of the counter which is counter 1, counter2, counter3 , counter4, this allow when the state of counter 1 reached 5, all the other counters will be reset to 0.</p>"},{"location":"intermediate/global_state/#step-3-create-and-attach-counters-to-the-subject-create-the-page","title":"Step 3: Create and Attach Counters to the Subject, create the page","text":"<p>Now, we'll create the counters and attach them to the subject. And create the page of the counters</p>"},{"location":"intermediate/global_state/#main-application","title":"Main Application","text":"<p>in <code>main.py</code> :</p> <pre><code>from zenaura.client.app import App, Route\nfrom zenaura.client.page import Page\nfrom public.components import Counter, counter_subject\nimport asyncio\n\n# Create counter components\ncounter1 = Counter(counter_subject, \"counter1\")\ncounter2 = Counter(counter_subject, \"counter2\")\ncounter3 = Counter(counter_subject, \"counter3\")\ncounter4 = Counter(counter_subject, \"counter4\")\n\nprint(counter1.id != counter2.id != counter3.id != counter4.id)\nrouter = App()\nrouter.add_route(\n    Route(\n        \"Home\", \n        \"/\",\n        Page(\n            [counter1, counter2, counter3, counter4]\n       ) \n    )\n)\n\n\n# Run the application\nevent_loop = asyncio.get_event_loop()\nevent_loop.run_until_complete(router.handle_location())\n</code></pre> <p>This will result in the required behavior, where the four counters are synced to a single global state as shown in the below GIF: </p> <p></p>"},{"location":"intermediate/global_state/#conclusion","title":"Conclusion","text":"<p>By implementing the Observer pattern, we can efficiently manage global state and ensure that all parts of the application react to changes. In this example, we created four counters, and when Counter 1 reaches 5, all counters reset. This approach ensures maintainability, flexibility, and separation of concerns in your Zenaura applications.</p> <p>The source code for the full example is available on GitHub in the examples repository.</p>"},{"location":"intermediate/layout/","title":"Layout","text":""},{"location":"intermediate/layout/#layouts","title":"Layouts","text":"<p>Layouts in Zenaura allow you to define global components that exist within the root <code>div</code> for every route. Like other Zenaura components, their state is preserved. Layouts are a way to organize your Zenaura application, ensuring consistency and reusability of common UI elements.</p> <p>The typical structure is: <pre><code>Top Components -&gt; App Routes -&gt; Bottom Components\n</code></pre></p>"},{"location":"intermediate/layout/#example-structure","title":"Example Structure","text":"<pre><code>&lt;div id=\"root\"&gt;\n    &lt;nav&gt;&lt;/nav&gt; &lt;!-- Global top-of-page navigation component --&gt;\n    &lt;div id=\"page1\"&gt;&lt;/div&gt;\n    &lt;div id=\"page2\" hidden&gt;&lt;/div&gt;\n    &lt;div id=\"page3\" hidden&gt;&lt;/div&gt;\n    &lt;div id=\"page4\" hidden&gt;&lt;/div&gt;\n    &lt;footer&gt;&lt;/footer&gt; &lt;!-- Global bottom-of-page footer component --&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"intermediate/layout/#example-of-creating-a-layout","title":"Example of Creating a Layout","text":""},{"location":"intermediate/layout/#step-1-define-layout-in-mainpy","title":"Step 1: Define Layout in <code>main.py</code>","text":"<pre><code>from zenaura.client.app import Route, App\nfrom zenaura.client.page import Page\nfrom zenaura.client.layout import Layout\nfrom public.routes import ClientRoutes\nfrom public.components.header import Header\nfrom public.components.intro import IntroSection\nfrom public.components.footer import Footer\nfrom public.components.examples import Example\n\n# Instantiate components\nnav_bar_header = Header(router)\nintro_section = IntroSection()\nfooter = Footer()\nexample = Example()\n\n# Define pages\nhome_page = Page([intro_section])\nexample_page = Page([example])\n\n# Define routes\nrouter.add_route(Route(\n    title=\"Developer-Focused | Zenaura\",\n    path=ClientRoutes.home.value,\n    page=home_page\n))\n\nrouter.add_route(Route(\n    title=\"Example\",\n    path=ClientRoutes.examples.value,\n    page=example_page\n))\n\n# Create the app layout\nmy_app_layout = Layout(\n    top=[nav_bar_header],    # Components to appear before the routes\n    routes=app.routes,       # Application routes (pages)\n    bottom=[footer]          # Components to appear after the routes\n)\n\n# optional : pass layout to router to trigger global components attached lifecycle method\nrouter.layout = my_app_layout\n</code></pre>"},{"location":"intermediate/layout/#step-2-hydrate-layout-in-buildpy","title":"Step 2: Hydrate Layout in <code>build.py</code>","text":"<pre><code>from public.main import my_app_layout\nfrom zenaura.client.server import ZenauraServer\n\nZenauraServer.hydrate_app_layout(my_app_layout, scripts=[\n    '&lt;link rel=\"stylesheet\" href=\"public/gigavolt.min.css\"&gt;',\n    '&lt;link rel=\"stylesheet\" href=\"public/output.css\"&gt;',\n    '&lt;script src=\"public/highlight.min.js\"&gt;&lt;/script&gt;',\n    '&lt;script src=\"public/python.min.js\"&gt;&lt;/script&gt;',\n    '&lt;script&gt;hljs.highlightAll();&lt;/script&gt;',\n    \"\"\"\n    &lt;script&gt;\n        const ws = new WebSocket(\"ws://localhost:5000/refresh\");\n        ws.onmessage = () =&gt; {\n            console.log(\"Reloading...\");\n            location.reload();\n        };\n    &lt;/script&gt;\n    \"\"\"\n])\n</code></pre> <p>This setup ensures that the navigation bar (<code>nav_bar_header</code>) and footer (<code>footer</code>) components appear on every page of the application. You can add multiple components to the top or bottom sections as needed for your application layout.</p>"},{"location":"intermediate/layout/#conclusion","title":"Conclusion","text":"<p>By using app layout for global component this insure maximum reuseability and yields more onrganized maintained codebase, even though one of the guides encourage the use of higher order components, however this approach is far more optimized. </p>"},{"location":"quick/first_app/","title":"Creating your first zenaura app","text":"<p>In this example we will go over creating your first zenaura application, go over basic concepts as well. </p> <p>Once you installed the library, the library, it comes with simple CLI tool.</p>"},{"location":"quick/first_app/#cli-commands","title":"CLI Commands:","text":"<pre><code>- init: Will create simple zenaura application\n- build : Will build the application\n- run : Will run the development server\n</code></pre> <p>First let's initials a basic zenaura application: <pre><code>zenaura init \n</code></pre> This command will auto generate basic zenaura application with the needed files auto generated for you, so you can get up to speed with the library.</p>"},{"location":"quick/first_app/#auto-generated-files-from-init-command","title":"Auto generated files from init command:","text":"<ul> <li>build.py : used for building zenaura application.</li> <li>index.py : simple zenaura server.</li> <li>public/components.py: single zenaura component.</li> <li>public/presentational.py: few zenaura presentational components created using builder interface.</li> <li>public/main.py : main file where we import components, create pages and  configure the client router. </li> <li>public/routes.py : where your client side routes lives.</li> <li>public/main.css : the main css file.</li> <li>public/config.json: pyscript pydide configuration. </li> </ul>"},{"location":"quick/first_app/#building-zenaura","title":"Building zenaura","text":"<p><pre><code>zenaura build\n</code></pre> This command will build index.html.</p>"},{"location":"quick/first_app/#running-zenaura","title":"Running zenaura","text":"<pre><code>zenaura run\n</code></pre> <p>This command will run the development server. Now open browser tab and go to localhost:5000. You will see the following Rendered HTML : </p> <p> The Python Library For !Building Modern Web User Interface <p></p> <p>Now if we opened components.py, and changed the header text: <pre><code>from zenaura.client.component import Component\nfrom public.presentational import * \n\n\nclass ZenauraStarter(Component):\n    def render(self):\n        return Div(\"zenaura\", [\n           Div(\"\", [\n            Image(\"./public/logo.png\", \"zenaura\", \"255\", \"255\", \"starterLogo\"),\n            Header1(\"The Python Library For, Hello world !\"), # note here we changed the content\n            Header1(\"Building Modern Web User Interface\")\n           ])\n        ])\n</code></pre></p> <p>The development server have hot reloading feature built-in , it will trigger reloading of the page and we will see the changes live. And changes will be applied.</p> <p>Rendered HTML : </p> <p> The Python Library For, Hello world !Building Modern Web User Interface <p></p>"},{"location":"quick/first_app/#adding-new-component-to-the-page","title":"Adding new component to the page","text":"<p>Now we will add new component to the page, this component will be simply a header:</p> <p>in public/components.py: </p> <p><pre><code>from zenaura.client.component import Component\nfrom public.presentational import * \n\n\nclass ZenauraStarter(Component):\n    def render(self):\n        return Div(\"zenaura\", [\n           Div(\"\", [\n            Image(\"./public/logo.png\", \"zenaura\", \"255\", \"255\", \"starterLogo\"),\n            Header1(\"The Python Library For, Hello world !\"), # note here we changed the content\n            Header1(\"Building Modern Web User Interface\")\n           ])\n        ])\n\nclass ZenauraStarter2(Component):\n    def render(self):\n        return  Header1(\"Simple Header !\")\n</code></pre> In public/main.py</p> <p><pre><code>from zenaura.client.app import Route, App\nfrom zenaura.client.page import Page\nfrom public.routes import ClientRoutes\nfrom public.components import ZenauraStarter, ZenauraStarter2 # add the new component\nimport asyncio\n\n\nstarter = ZenauraStarter()\n\nstarter2 = ZenauraStarter2() # create instance of the component\n# App and routing\nrouter = App()\nhome_page = Page([starter, starter2]) # add component to the page\n\nrouter.add_route(Route(\n    title=\"Developer-Focused | Zenaura\",\n    path=ClientRoutes.home.value,\n    page=home_page\n))\n\n# Run the application\nevent_loop = asyncio.get_event_loop()\nevent_loop.run_until_complete(router.handle_location())\n</code></pre> Rendered HTML : </p> <p> The Python Library For, Hello world !Building Modern Web User Interface <p></p> Simple Header !"},{"location":"quick/first_app/#adding-state-to-the-component","title":"Adding State to the component","text":"<p>Now we will add state to the component, the state will be simple keyword rendered within the h1 tag.</p> <pre><code>from zenaura.client.component import Component\nfrom public.presentational import * \n\n\nclass ZenauraStarter(Component):\n    def __init__(self, state):\n        self.state = state\n    def render(self):\n        return  Header1(f\"{state}\")\n</code></pre> <p>Note if we took a look at public/presentational.py, we will notice a text node <pre><code>def Header1(text):\n    return Builder('h1').with_text(text).build()\n</code></pre> with_text, or Node(text=text), is very important this is how you should render user text, the compiler will santize and render the text, to prevent known security issues.</p> <p>Note this is very simple guide to help you start with zenaura library, in The Basics guide we will go over each building block in zenaura library and explain it, in rich details.</p>"},{"location":"quick/installation/","title":"Installing zenaura","text":"<p>prerequisits:     - Python 3.12 or above.     - pip      - devolopment server requirements:         + flask==2.3.3         + watchdog==4.0.1         + flask-sock==0.7.0</p> <pre><code>pip install zenaura flask==2.3.3 watchdog==4.0.1 flask-sock==0.7.0\n</code></pre> <p>This command will install zenaura library, client and server, CLI. </p>"},{"location":"releases/0.11.122/","title":"Introduction","text":"<p>The following release introduces two minor, backward-compatible changes. The first change allows users to add attributes to page wrapper div:</p> <pre><code>&lt;div data-zenaura=\"72e7e09f\" hidden=\"\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"releases/0.11.122/#adding-attributes-to-pages","title":"Adding Attributes to Pages","text":"<p>The updated implementation now allows adding class names for styling purposes:</p> <pre><code>&lt;div data-zenaura=\"72e7e09f\" hidden=\"\" class=\"flex\"&gt;&lt;/div&gt;\n</code></pre> <p>Users can specify class names for the pages when configuring the router:</p> <pre><code>home_page = Page([intro_section], attributes={\"class\": \"flex\"}) # Optional class name\n</code></pre>"},{"location":"releases/0.11.122/#layout","title":"Layout","text":"<p>Support for higher-order components will remain unchanged. However, this release introduces a custom app hydration method called <code>hydrate_app_layou</code>, for the hydration of the app and pages.</p> <p>For example, consider this layout: nav \u2192 page content \u2192 footer. Using higher-order components and pages, this results in the following structure, using  <code>@Reuseable</code> on nav component, footer and passing new instance for each page  will yield the expected behavior but with html redundancy  : </p> <pre><code>&lt;div&gt;\n    &lt;div data-zenaura=\"72e7e09f\" hidden=\"\"&gt;\n        &lt;nav&gt;&lt;/nav&gt;\n        &lt;div&gt;content&lt;/div&gt;\n        &lt;footer&gt;&lt;/footer&gt;\n    &lt;/div&gt;\n    &lt;div data-zenaura=\"72e7e09f\" hidden=\"\"&gt;\n        &lt;nav&gt;&lt;/nav&gt;\n        &lt;div&gt;content&lt;/div&gt;\n        &lt;footer&gt;&lt;/footer&gt;\n    &lt;/div&gt;\n    &lt;div data-zenaura=\"72e7e09f\" hidden=\"\"&gt;\n        &lt;nav&gt;&lt;/nav&gt;\n        &lt;div&gt;content&lt;/div&gt;\n        &lt;footer&gt;&lt;/footer&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"releases/0.11.122/#solution","title":"Solution","text":"<p>Instead of users passing the router class to the build process, they now use <code>ZenauraServer.hydrate_app_layout</code>, which allows them to pass multiple components and a list of pages in the order they want them to be rendered. Here is an example using higher-order components:</p> <pre><code>from zenaura.client.app import Route, App\nfrom zenaura.client.page import Page\nfrom public.routes import ClientRoutes\nfrom public.components.header import Header\nfrom public.components.intro import IntroSection\nfrom public.components.footer import Footer\nfrom public.components.examples import Example\n\nnav_bar_header = Header(router)\nintro_section = IntroSection()\nfooter = Footer()\nexample = Example()\n\n# Higher-order component\ndef AppLayout(page_children):\n    return [\n        nav_bar_header,\n        *page_children,\n        footer,\n    ]\n\n# App and routing\nhome_page = Page(AppLayout([intro_section]))\n\nrouter.add_route(Route(\n    title=\"components\",\n    path=ClientRoutes.components.value,\n    page=components_page\n))\n</code></pre> <p>This approach is now replaced with:</p> <pre><code>from zenaura.client.app import Route, App\nfrom zenaura.client.page import Page\nfrom zenaura.client.layout import Layout  # Change\nfrom public.routes import ClientRoutes\nfrom public.components.header import Header\nfrom public.components.intro import IntroSection\nfrom public.components.footer import Footer\nfrom public.components.examples import Example\n\nnav_bar_header = Header(router)\nintro_section = IntroSection()\nfooter = Footer()\nexample = Example()\n# No higher-order component needed\n\n# App and routing\nhome_page = Page([intro_section])\nexample_page = Page([example])\n\nrouter.add_route(Route(\n    title=\"Developer-Focused | Zenaura\",\n    path=ClientRoutes.home.value,\n    page=home_page\n))\n\nrouter.add_route(Route(\n    title=\"example\",\n    path=ClientRoutes.examples.value,\n    page=example_page\n))\n\n# Adding app layout\nmy_app_layout = Layout(\n    top= [nav_bar_header], # first child component to root div\n    routes=app.routes,  # Pages stored here\n    bottom=[footer] # last child components to root div\n)\n</code></pre> <p>Updating <code>build.py</code>:</p> <pre><code>from public.main import my_app_layout\nZenauraServer.hydrate_app_layout(my_app_layout, scripts=[\n    '&lt;link rel=\"stylesheet\" href=\"public/gigavolt.min.css\"&gt;',\n    '&lt;link rel=\"stylesheet\" href=\"public/output.css\"&gt;',\n    '&lt;script src=\"public/highlight.min.js\"&gt;&lt;/script&gt;',\n    '&lt;script src=\"public/python.min.js\"&gt;&lt;/script&gt;',\n    '&lt;script&gt;hljs.highlightAll();&lt;/script&gt;',\n    \"\"\"\n    &lt;script&gt;\n        const ws = new WebSocket(\"ws://localhost:5000/refresh\");\n        ws.onmessage = () =&gt; {\n        console.log(\"Reloading...\");\n        location.reload();\n        };\n    &lt;/script&gt;\n    \"\"\"\n])\n</code></pre> <p>This change ensures that global components are included within the root div, not within every page:</p> <pre><code>&lt;div id=\"root\"&gt;\n    &lt;nav&gt;&lt;/nav&gt; &lt;!-- Global top of pages nav component --&gt;\n    &lt;div id=\"page1\"&gt;&lt;/div&gt;\n    &lt;div id=\"page2\" hidden&gt;&lt;/div&gt;\n    &lt;div id=\"page3\" hidden&gt;&lt;/div&gt;\n    &lt;div id=\"page4\" hidden&gt;&lt;/div&gt;\n    &lt;footer&gt;&lt;/footer&gt; &lt;!-- Global bottom of pages footer component --&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"releases/0.11.125/","title":"Introduction","text":"<p>The following release introduces a minor fix, for layout, users can optionally pass layout to the router if they want the component life cycle methods to be synced on every mount. <pre><code>from zenaura.client.app import Route, App\nfrom zenaura.client.page import Page\nfrom zenaura.client.layout import Layout\nfrom public.routes import ClientRoutes\nfrom public.components.header import Header\nfrom public.components.intro import IntroSection\nfrom public.components.footer import Footer\nfrom public.components.examples import Example\n\n# Instantiate components\nnav_bar_header = Header(router)\nintro_section = IntroSection()\nfooter = Footer()\nexample = Example()\n\n# Define pages\nhome_page = Page([intro_section])\nexample_page = Page([example])\n\n# Define routes\nrouter.add_route(Route(\n    title=\"Developer-Focused | Zenaura\",\n    path=ClientRoutes.home.value,\n    page=home_page\n))\n\nrouter.add_route(Route(\n    title=\"Example\",\n    path=ClientRoutes.examples.value,\n    page=example_page\n))\n\n# Create the app layout\nmy_app_layout = Layout(\n    top=[nav_bar_header],    # Components to appear before the routes\n    routes=app.routes,       # Application routes (pages)\n    bottom=[footer]          # Components to appear after the routes\n)\n\n# optional : pass layout to router to trigger global components attached lifecycle method\nrouter.layout = my_app_layout\n</code></pre></p>"},{"location":"releases/0.9.118/","title":"First offocial release 0.9.118","text":"<p>The release contain the core functioanlity of zenaura as framework for building UI using python. This core functioanlity include the following features :</p> <ul> <li>Exceptional Developer Experience: Intuitive and efficient development workflow.</li> <li>Smooth Learning Curve: Easy to learn and get started.</li> <li>Modular Code Structure: Write clean, readable, and maintainable code.</li> <li>Component-Based Architecture: Build reusable and scalable components.</li> <li>Page Management: Simplify page creation and navigation.</li> <li>Built-in Router: Seamless client-side routing.</li> <li>State and Props Management: Efficiently handle component states and properties.</li> <li>Dependency Injection: Manage dependencies effortlessly.</li> <li>Global States and Components: Share states and components across the application.</li> <li>Optimized Virtual DOM: Enhance application performance with a highly efficient virtual DOM.</li> <li>Component Lifecycle Methods: Control component behavior at different stages.</li> <li>Form Support: Easily manage form inputs and validation.</li> <li>API Integration: Integrate external APIs using the requests module.</li> </ul>"},{"location":"releases/0.9.122/","title":"0.9.122","text":"<ul> <li>Fix '/' path logic in app:<ul> <li>if the route is defined and linked to a page, on app first render, this page is shown, the rest of the pages are hidden.</li> <li>if the route '/' is not defined and not linked to a page, the first route in the router stack will be shown, the rest are hidden.</li> </ul> </li> <li>Added CLI documentation.</li> <li>Added releases section to documentation.</li> <li>Added Data binding model to documentation.</li> </ul>"}]}