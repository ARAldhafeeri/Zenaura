{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Start Here","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Zenaura is a Python-based framework designed for building web applications with simplicity, developer experience, and event-driven design.</p>"},{"location":"#architecture-guidelines","title":"Architecture Guidelines","text":"<ul> <li>Modular components for scalability.</li> <li>Event-driven architecture via <code>dispatcher.bind</code>.</li> <li>Python-first approach, enabling PyScript and Pyodide integration.</li> </ul>"},{"location":"#why-zenaura","title":"Why Zenaura","text":"<ul> <li>Simplified async programming.</li> <li>Intuitive routing and state management.</li> <li>Easy integration with Python and JS packages.</li> </ul>"},{"location":"#rules","title":"Rules","text":""},{"location":"#dos","title":"Do's","text":"<ol> <li>Use <code>dispatcher.bind</code> and <code>dispatcher.dispatch</code> for event management:    <pre><code>dispatcher.bind(\"button-id\", \"click\", callback_function)\n</code></pre></li> <li>Ensure <code>render</code> in components has a single parent and one child level:    <pre><code>def render(self):\n    return div(\n        h1(\"Parent\"),\n        div(\"Child 1\"),\n        div(\"Child 2\")\n    )\n</code></pre>    Use functional components for nested children:    <pre><code>def child1(prop1, prop2):\n    return div(\n        p(prop1),\n        p(prop2)\n    )\n</code></pre></li> <li>Follow the hierarchy: <code>HTML tags -&gt; Functional Components -&gt; Class Components -&gt; Pages -&gt; Layout</code>.</li> <li>For multiple layouts, use:<ul> <li>Microfrontend architecture.</li> <li>Conditional rendering (discussed in Layout section).</li> </ul> </li> <li>Use <code>subject</code> and <code>observer</code> for shared states:    <pre><code>from zenaura.client.observer import subject\nstate = subject(shared_data)\n</code></pre></li> </ol>"},{"location":"#donts","title":"Don'ts","text":"<ol> <li>Don\u2019t use inline event handlers like <code>on_click</code>.</li> <li>Don\u2019t deeply nest child elements in <code>render</code>.</li> <li>Don\u2019t use <code>builder</code> calls for UI construction.</li> <li>Don\u2019t hard-code shared states or use global variables.</li> </ol>"},{"location":"#quick-overview","title":"Quick Overview","text":""},{"location":"#basics","title":"Basics","text":""},{"location":"#html-tags","title":"HTML Tags","text":"<p>Simplified tag usage: <pre><code>from zenaura.ui import div, h1, button\nfrom zenaura.client.component import Component\n\nclass MyComponent(Component):\n    def render(self):\n        return div(\n            h1(\"Welcome to Zenaura\"),\n            button(\"Click Me\", id=\"my-button\"),\n        )\n</code></pre></p>"},{"location":"#special-attributes","title":"Special Attributes","text":"<p>Attributes conflicting with Python keywords use <code>_</code> suffix: <pre><code>div(\"Hello World\", class_=\"greeting\")\ninput_(id=\"my_input\")\n</code></pre></p>"},{"location":"#components","title":"Components","text":"<p>Define reusable components: <pre><code>from zenaura.client.component import Component, Reuseable\n\n@Reuseable\nclass WelcomeComponent(Component):\n    def render(self):\n        return div(\"Welcome to Zenaura\", class_=\"welcome\")\n</code></pre> Zenaura prompts for <code>@Reuseable</code> if missing.</p>"},{"location":"#state-management","title":"State Management","text":"<p>Integrated event-driven patterns: <pre><code>class Counter(Component):\n    def __init__(self):\n        self.count = 0\n\n    def increment(self):\n        self.count += 1\n</code></pre></p>"},{"location":"#dispatcher","title":"Dispatcher","text":"<p>Bind events with <code>dispatcher.bind</code>: <pre><code>from zenaura.client.dispatcher import dispatcher\n\ndispatcher.bind(\"my-button\", \"click\", counter.increment)\n</code></pre> Dispatch events with <code>dispatcher.dispatch</code>.</p>"},{"location":"#beyond-basics","title":"Beyond Basics","text":""},{"location":"#router","title":"Router","text":"<p>Simplified routing: <pre><code>from zenaura.client.app import App\nfrom zenaura.client.page import Page\n\napp = App()\nhome_page = Page([WelcomeComponent()])\napp.add_route(\"/\", home_page)\napp.run()\n</code></pre></p>"},{"location":"#pages","title":"Pages","text":"<p>Encapsulate components: <pre><code>from zenaura.client.page import Page\n\nhome_page = Page([WelcomeComponent()])\n</code></pre></p>"},{"location":"#layout","title":"Layout","text":"<p>Define app layout: <pre><code>from zenaura.client.layout import Layout\nfrom zenaura.client.app import App\n\napp = App()\n\nmy_app_layout = Layout(\n    top=[NavigationAuthNotAuth],\n    routes=app.routes,\n    bottom=[FooterAuthNotAuth]\n)\n</code></pre></p>"},{"location":"#global-state","title":"Global State","text":"<p>Share state between components: <pre><code>from zenaura.client.observer import Subject\n\ncounter_subject = Subject()\ncounter_subject.state = {\"counter1\": 0}\n\nclass CounterObserver(Observer):\n    pass\n\nclass Counter1(Component, CounterObserver):\n    async def increment(self, event):\n        counter_subject.state[\"counter1\"] += 1\n        counter_subject.notify()\n\n    def update(self, value):\n        # Logic for state update\n</code></pre></p>"},{"location":"#forms","title":"Forms","text":"<p>Handle forms: <pre><code>def render_form():\n    return form(\n        input_(type=\"text\", id=\"name\"),\n        button(\"Submit\", id=\"submit-button\")\n    )\n</code></pre></p>"},{"location":"#advanced-concepts","title":"Advanced Concepts","text":""},{"location":"#virtual-dom","title":"Virtual DOM","text":"<p>Minimizes re-rendering by efficiently patching changes.</p>"},{"location":"#component-lifecycle","title":"Component Lifecycle","text":"<ul> <li><code>attached</code>: Runs after mounting.</li> <li><code>on_mutation</code>: Runs before DOM updates.</li> <li><code>on_settled</code>: Runs after DOM updates.</li> </ul>"},{"location":"#api-integration","title":"API Integration","text":"<p>Fetch data with async handlers: <pre><code>from zenaura.client.mutator import mutator\n\n@mutator\nasync def fetch_data():\n    data = await fetch(\"/api/data\")\n    return data\n</code></pre></p>"},{"location":"#pyscript-and-pyodide","title":"PyScript and Pyodide","text":"<ul> <li>PyScript: Run Python in the browser.</li> <li>Pyodide: Python interpreter in WebAssembly.</li> </ul>"},{"location":"#deployment","title":"Deployment","text":"<ul> <li>Configure <code>config.json</code>.</li> <li>Host static files on a CDN/server.</li> </ul>"},{"location":"#external-js-or-css","title":"External JS or CSS","text":"<p>Add scripts to <code>build.py</code>: <pre><code>from zenaura.server import ZenauraServer\nZenauraServer.hydrate_app(app, scripts=[\n    \"\"\"\n    &lt;script&gt;\n        const ws = new WebSocket(\"ws://localhost:5000/refresh\");\n        ws.onmessage = () =&gt; location.reload();\n    &lt;/script&gt;\n    \"\"\"\n])\n</code></pre> Import JS dynamically: <pre><code>from zenaura.web.utils import to_js\n\ndef use_js_function():\n    from js import my_js_function\n    my_js_function(to_js({\"data\": 1}))\n</code></pre></p>"},{"location":"#external-python-packages","title":"External Python Packages","text":"<p>List dependencies in <code>config.json</code>: <pre><code>\"packages\": [\"numpy\", \"pandas\"]\n</code></pre></p>"},{"location":"#zenaura-cli","title":"Zenaura CLI","text":"<p>Zenaura cli is a tool to use, to quickly intialize, build, and run application</p> <ul> <li><code>zenaura init</code> will initialize basic zenaura application.</li> <li><code>zenaura build</code> will build the zenaura application, and run everytime you change a file in zenaura public folder.</li> <li><code>zenaura run</code> run the application on port 5000, you can change the port from index.py</li> </ul>"},{"location":"#zenaura-ui","title":"Zenaura UI","text":"<p>Multiple ready to use UI components.</p> <pre><code>from zenaura.ui import Button, BreadCrumbs\n</code></pre>"},{"location":"#zenaura-charts","title":"Zenaura Charts","text":"<p>Multiple ready to use charts, built on top of chartjs</p> <pre><code>from zenaura.ui.charts import ChartThis, Canvas\n\nconfig = {} # chartjs config as python dict\nasync def chart_logic(self):\n   ChartThis(config, self.chart_name)\n\ndef my_chart():\n   return Canvas(\"bar_chart\")\n</code></pre>"},{"location":"algorithm/","title":"Algorithm","text":""},{"location":"algorithm/#zenaura.client.algorithm.algorithm.DiffingAlgorithm","title":"<code>DiffingAlgorithm</code>","text":"<p>               Bases: <code>Searcher</code>, <code>Updater</code></p> <p>The diffing algorithm in Zenaura virtual DOM.</p> <p>This class is responsible for comparing the old and new virtual DOM trees and generating a list of changes that need to be applied to the real DOM.</p> <p>The diffing algorithm is implemented in two steps:</p> <ol> <li>Search: The <code>Searcher</code> class traverses the old and new virtual DOM trees and identifies the nodes that have changed.</li> <li>Update: The <code>Updater</code> class applies the changes to the real DOM.</li> </ol> <p>The diffing algorithm is designed to be efficient and performant. It uses a number of techniques to minimize the number of changes that need to be applied to the real DOM.</p> <p>Attributes:</p> <ul> <li><code>Searcher</code>: An instance of the <code>Searcher</code> class.</li> <li><code>Updater</code>: An instance of the <code>Updater</code> class.</li> </ul> <p>Methods:</p> <ul> <li><code>diff(old_tree, new_tree)</code>: Compares the old and new virtual DOM trees and generates a list of changes that need to be applied to the real DOM.</li> </ul> <p>Example:</p> <pre><code># Create an instance of the DiffingAlgorithm class.\ndiffing_algorithm = DiffingAlgorithm()\n\n# Compare the old and new virtual DOM trees.\nchanges = diffing_algorithm.diff(old_tree, new_tree)\n\n# Apply the changes to the real DOM.\ndiffing_algorithm.update(changes)\n</code></pre> Source code in <code>zenaura/client/algorithm/algorithm.py</code> <pre><code>class DiffingAlgorithm(\n    Searcher,\n    Updater\n):\n    \"\"\"\n        The diffing algorithm in Zenaura virtual DOM.\n\n        This class is responsible for comparing the old and new virtual DOM trees and generating a list of changes that need to be applied to the real DOM.\n\n        The diffing algorithm is implemented in two steps:\n\n        1. **Search:** The `Searcher` class traverses the old and new virtual DOM trees and identifies the nodes that have changed.\n        2. **Update:** The `Updater` class applies the changes to the real DOM.\n\n        The diffing algorithm is designed to be efficient and performant. It uses a number of techniques to minimize the number of changes that need to be applied to the real DOM.\n\n        **Attributes:**\n\n        * `Searcher`: An instance of the `Searcher` class.\n        * `Updater`: An instance of the `Updater` class.\n\n        **Methods:**\n\n        * `diff(old_tree, new_tree)`: Compares the old and new virtual DOM trees and generates a list of changes that need to be applied to the real DOM.\n\n        **Example:**\n\n        ```python\n        # Create an instance of the DiffingAlgorithm class.\n        diffing_algorithm = DiffingAlgorithm()\n\n        # Compare the old and new virtual DOM trees.\n        changes = diffing_algorithm.diff(old_tree, new_tree)\n\n        # Apply the changes to the real DOM.\n        diffing_algorithm.update(changes)\n        ```\n    \"\"\"\n</code></pre>"},{"location":"algorithm/#zenaura.client.algorithm.operations.ADD_ATTRIBUTE","title":"<code>ADD_ATTRIBUTE = 'ADD_ATTRIBUTE'</code>  <code>module-attribute</code>","text":"<p>{     name : \"ADD_ATTRIBUTE\",     context: {         \"attr_name\" : \"attr-name\",         \"attr_value\" : \"attr-value\",     } }</p>"},{"location":"algorithm/#zenaura.client.algorithm.operations.ADD_NODE","title":"<code>ADD_NODE = 'ADD_NODE'</code>  <code>module-attribute</code>","text":"<p>{     name : \"ADD_NODE\",     context: {         \"children\" : child-node,     } }</p>"},{"location":"algorithm/#zenaura.client.algorithm.operations.NODE_INNER_TEXT","title":"<code>NODE_INNER_TEXT = 'NODE_INNER_TEXT'</code>  <code>module-attribute</code>","text":"<p>{     name : \"NODE_INNER_TEXT\",     context: {         \"text\" : \"sanitized-text\",     } }</p>"},{"location":"algorithm/#zenaura.client.algorithm.operations.REMOVE_ATTRIBUTE","title":"<code>REMOVE_ATTRIBUTE = 'REMOVE_ATTRIBUTE'</code>  <code>module-attribute</code>","text":"<p>{     name : \"REMOVE_ATTRIBUTE\",     context: {         \"attr_name\" : \"attr-name\",     } }</p>"},{"location":"algorithm/#zenaura.client.algorithm.operations.REMOVE_NODE","title":"<code>REMOVE_NODE = 'REMOVE_NODE'</code>  <code>module-attribute</code>","text":"<p>{     name : \"REMOVE_NODE\",     context: {         \"children\" : child-node,     } }</p>"},{"location":"algorithm/#zenaura.client.algorithm.operations.REPLACE_ATTRIBUTE","title":"<code>REPLACE_ATTRIBUTE = 'REPLACE_ATTRIBUTE'</code>  <code>module-attribute</code>","text":"<p>{     name : \"REPLACE_ATTRIBUTE\",     context: {         \"attr_name\" : \"attr-name\",         \"attr_value\" : \"attr-value\",     } }</p>"},{"location":"CLI/cli/","title":"Zenaura CLI Guide","text":"<p>The Zenaura CLI tool simplifies the process of creating, building, and running Zenaura projects. This guide will walk you through the basic commands and functionalities provided by the Zenaura CLI.</p>"},{"location":"CLI/cli/#installation","title":"Installation","text":"<p>Zenaura cli comes out of the box with zenaura framework:</p> <pre><code>pip install zenaura\n</code></pre>"},{"location":"CLI/cli/#cli-commands","title":"CLI Commands","text":"<p>The Zenaura CLI provides three main commands: <code>init</code>, <code>build</code>, and <code>run</code>.</p>"},{"location":"CLI/cli/#init","title":"init","text":"<p>The <code>init</code> command sets up a new Zenaura project with the necessary structure and files.</p> <pre><code>zenaura init\n</code></pre> <p>This command creates a <code>public</code> directory with initial files and folders, including:</p> <ul> <li><code>public/main.py</code> : where main project code lives</li> <li><code>public/config.json</code> : configuration for pyscript</li> <li><code>public/index.html</code> : root html.</li> <li><code>main.css</code> : main css.</li> <li><code>public/__init__.py</code> : where you import other components used inside the project in any directory.</li> </ul> <p>It also creates two additional files in the project root:</p> <ul> <li><code>build.py</code></li> <li><code>index.py</code></li> </ul>"},{"location":"CLI/cli/#build","title":"build","text":"<p>The <code>build</code> command runs the <code>build.py</code> script to prepare your project for deployment.</p> <pre><code>zenaura build\n</code></pre>"},{"location":"CLI/cli/#run","title":"run","text":"<p>The <code>run</code> command starts the development server using the <code>index.py</code> script.</p> <pre><code>zenaura run\n</code></pre>"},{"location":"CLI/cli/#example-workflow","title":"Example Workflow","text":"<p>Here is an example of a typical workflow using the Zenaura CLI:</p> <ol> <li>Initialize a new project:</li> </ol> <pre><code>zenaura init\n</code></pre> <ol> <li>Build the project:</li> </ol> <pre><code>zenaura build\n</code></pre> <ol> <li>Run the project:    <pre><code>zenaura run\n</code></pre></li> </ol>"},{"location":"CLI/cli/#notes","title":"Notes","text":"<ul> <li>Hot-reloading: The hot-reloading feature is currently under development. To ensure your changes are reflected in the browser, use the <code>build</code> command before running the project.</li> <li>Python Versions: Ensure you are using a compatible Python version with Zenaura and the required packages.</li> </ul> <p>By following this guide, you can efficiently manage your Zenaura projects using the CLI tool. Enjoy building dynamic and interactive UIs with Zenaura!</p>"},{"location":"Examples/contributing/","title":"Contributing to zenaura examples:","text":"<p>The following guide shows steps to contribute your example so it can be featured on zenaura documentation page.</p> <ol> <li>Create the example Repo on GitHub. </li> <li>Test the example make sure it's working.</li> <li>Fork zenaura.</li> <li>Create pull request where you add the example into the proper example section:<ul> <li>docs/examples/basic/my_example.md</li> <li>docs/examples/intermediate/my_example.md</li> <li>docs/examples/advanced/my_example.md</li> </ul> </li> <li>Make sure you correctly set the difficulty of the example, basic example should touch on zenaura basics, intermediate example should touch on zenaura intermediate and advanced example should touch on zenaura advanced.</li> <li>Create your example markdown with the following format, copy template.md :<ul> <li>Author: authorName</li> <li>Title: title of the example</li> <li>Description: Brief description of the example.</li> <li>Example GitHub URL.</li> </ul> </li> <li>add your example to mkdocs.yml <pre><code> - Basic Examples:\n      - A counter app: examples/basic/counter.md\n      - My Example Name: examples/basic/my_example.md # here\n    - Beyond The Basics Examples:\n      - Cory Game of Life: examples/intermediate/game_of_life.md\n    - Advanced Examples:\n      - Admin Portal: examples/advanced/admin_portal.md\n</code></pre></li> <li>create pull request.</li> </ol>"},{"location":"Examples/start_here/","title":"Starting With Zenaura Examples.","text":"<p>Before jumping into the examples make sure you finished the Quick start guide, and at least the Basics guide. </p> <p>Zenaura have a repository where all examples live can be found here: Zenaura examples</p> <p>For every example you must follow the following steps:</p>"},{"location":"Examples/start_here/#1-clone-the-example-on-your-device","title":"1. clone the example on your device :","text":"<pre><code>git clone https://github.com/ARAldhafeeri/zenaura-examples.git\n</code></pre>"},{"location":"Examples/start_here/#2-navigate-into-the-example-and-open-a-terminal-build-run-the-example","title":"2. navigate into the example and open a terminal, build , run the example:","text":"<pre><code>zenaura build \n</code></pre> <pre><code>zenaura run\n</code></pre> <p>the example should be live at localhost -&gt; http://localhost:5000/</p>"},{"location":"Examples/template/","title":"This is the title for the example","text":""},{"location":"Examples/template/#about","title":"About","text":"<p>this is brief description of the example ...</p>"},{"location":"Examples/template/#author","title":"Author","text":"<p>Araldhafeeri</p>"},{"location":"Examples/template/#example-link","title":"Example link :","text":"<p>Example source code</p>"},{"location":"Examples/template/#live-demo-optional","title":"Live demo ( Optional )","text":"<p>Live demo</p>"},{"location":"Examples/advanced/data_fetching/","title":"Data Fetching and API integration with zenaura","text":""},{"location":"Examples/advanced/data_fetching/#about","title":"About","text":"<p>The following advanced example showcase how to integrate with API endpoints and display data.</p>"},{"location":"Examples/advanced/data_fetching/#author","title":"Author","text":"<p>Araldhafeeri</p>"},{"location":"Examples/advanced/data_fetching/#example-link","title":"Example link :","text":"<p>Example source code</p>"},{"location":"Examples/advanced/game_of_life/","title":"Game of Life implementation with Python.","text":""},{"location":"Examples/advanced/game_of_life/#about","title":"About","text":"<p>The following advanced example showcase the game of life implementation with Python and Zenaura.</p>"},{"location":"Examples/advanced/game_of_life/#author","title":"Author","text":"<p>Araldhafeeri</p>"},{"location":"Examples/advanced/game_of_life/#example-link","title":"Example link :","text":"<p>Example source code</p>"},{"location":"Examples/basic/counter/","title":"Counter example with navigation","text":""},{"location":"Examples/basic/counter/#about","title":"About","text":"<p>The following simple example have single counter, and navigation between two pages.</p>"},{"location":"Examples/basic/counter/#author","title":"Author","text":"<p>Araldhafeeri</p>"},{"location":"Examples/basic/counter/#example-link","title":"Example link :","text":"<p>Example source code</p>"},{"location":"Examples/intermediate/global_state/","title":"Synced 4 counters","text":""},{"location":"Examples/intermediate/global_state/#about","title":"About","text":"<p>The following simple example have 4 counters, and global subject, whenever counter 1 reaches the count 5, all the other counters reset.</p>"},{"location":"Examples/intermediate/global_state/#author","title":"Author","text":"<p>Araldhafeeri</p>"},{"location":"Examples/intermediate/global_state/#example-link","title":"Example link :","text":"<p>Example source code</p>"},{"location":"Examples/intermediate/handling_forms/","title":"Simple form","text":""},{"location":"Examples/intermediate/handling_forms/#about","title":"About","text":"<p>The following simple example show case how to handle forms with zenaura application </p>"},{"location":"Examples/intermediate/handling_forms/#author","title":"Author","text":"<p>Araldhafeeri</p>"},{"location":"Examples/intermediate/handling_forms/#example-link","title":"Example link :","text":"<p>Example source code</p>"},{"location":"advanced/data_binding/","title":"Zenaura Data Binding Model Guide","text":"<p> Data binding is a powerful technique that allows seamless synchronization between the user interface and the underlying data model. In Zenaura, data binding facilitates automatic updates to the UI when the state changes, enabling a reactive and efficient user experience. This guide will walk you through the fundamentals of data binding in Zenaura components.</p>"},{"location":"advanced/data_binding/#understanding-data-binding-in-components","title":"Understanding Data Binding in Components","text":"<p>Data binding in Zenaura involves creating a connection between the component's state and the UI elements, ensuring that changes in the state are reflected in the UI and vice versa.</p> <p>The way zenaura implement synchronization between the user interface and the underlying data model is through dispacher and mutations. Mutations are event handlers decorated with mutator. Use mutator over an event handler if and only if we want the component to re-render. The data can still be synced if we set the state within event handler, without re-rendering the component.</p> <p>Dispacher allows you to bind mutation to document, window, element by id events, such when button clicked submit the form and re-render to show a message.</p>"},{"location":"advanced/data_binding/#example-of-a-simple-data-binding-component","title":"Example of a Simple Data Binding Component","text":"<p>Let's create a simple form component to demonstrate how data binding works in Zenaura.</p> <pre><code>from zenaura.client.component import Component\nfrom zenaura.ui import div, input_, p\nfrom zenaura.client.dispatcher import dispatcher\n\nclass SimpleForm(Component):\n    def __init__(self):\n        super().__init__()\n        self.set_state({\"inputValue\": \"\"})\n\n    # Note: We are not triggering re-render; we only capture the user input value\n    async def update_input(self, event):\n        new_value = event.target.value\n        self.set_state({\"inputValue\": new_value})\n\n    def render(self):\n        input_value = self.get_state()[\"inputValue\"]\n        return div(\n            input_(\n                value=input_value,\n                py_change=f\"{self.instance_name}.update_input\",\n                id=\"my-input\"\n            ),\n            p(f\"Current input: {input_value}\")\n        )\n\nsimple_form = SimpleForm()\n\n# Bind dispatcher\ndispatcher.bind(\"my-input\", \"change\", simple_form.update_input)\n</code></pre>"},{"location":"advanced/data_binding/#explanation","title":"Explanation","text":"<ol> <li>Initialization: The <code>SimpleForm</code> component initializes its state with an <code>inputValue</code> key, set to an empty string.</li> <li>Mutator: The <code>update_input</code> method updates the <code>inputValue</code> state based on the user's input.</li> <li>Rendering: The <code>render</code> method constructs the UI using the <code>Builder</code> interface. It creates an input field bound to <code>inputValue</code> and a paragraph element to display the current input value.</li> <li>dispacher: The 'dispatcher.bind\" will add event listener on the input using the input id, with event change, whenever the user enter data, the data will be sent to the callback via the event argument.</li> </ol>"},{"location":"advanced/data_binding/#two-way-data-binding","title":"Two-Way Data Binding","text":"<p>Two-way data binding ensures that changes in the UI update the component's state and that changes in the state update the UI. This is essential for creating interactive forms and inputs.</p> <p>Make sure to use text, node via builder <code>.with_text</code> for state variables zenaura will sanitize the data for you.</p>"},{"location":"advanced/fetch_data/","title":"Fetching Data and Integrating APIs with Zenaura","text":"<p>Zenaura simplifies the process of fetching data from APIs and integrating it into your Python-based web applications.</p>"},{"location":"advanced/fetch_data/#key-concepts","title":"Key Concepts","text":"<ol> <li> <p>Async/Await: Zenaura embraces asynchronous programming for efficient data fetching. <code>async def</code> functions allow your application to perform other tasks while waiting for API responses.</p> </li> <li> <p><code>mutator</code>: The <code>mutator</code> decorator is used to mark functions that modify component state. This ensures the component automatically re-renders to reflect the updated data.</p> </li> </ol> <p>Example Client-Side Component (<code>DataFetcher</code>)</p>"},{"location":"advanced/fetch_data/#create-zenaura-application","title":"Create zenaura application","text":"<pre><code>zenaura init\n</code></pre>"},{"location":"advanced/fetch_data/#add-requests-to-configjson","title":"Add requests to config.json","text":"<pre><code># stays same\n    \"packages\": [\n      \"zenaura==0.9.94\",\n      \"requests\"\n    ],\n# stays same\n</code></pre>"},{"location":"advanced/fetch_data/#presentational-components","title":"Presentational components","text":"<pre><code>from zenaura.ui import div, img, h1, p\n\ndef Div(class_name, children):\n    return div(*children, class_=class_name)\n\ndef Image(src, alt, width, height, classname=\"\"):\n    return img(\n        src=src,\n        alt=alt,\n        width=width,\n        height=height,\n        class_=classname\n    )\n\ndef Header1(text):\n    return h1(text)\n\ndef Paragraph(text):\n    return p(text)\n\ndef Spinner(text):\n    return Div(\"spinner-container\", [\n        Header1(text),\n    ])\n\ndef LoadingComponent():\n    \"\"\"Displays a loading indicator while data is being fetched.\"\"\"\n    return Div(\"loading\", [\n        Spinner(\"spinner\"),  # Replace 'Spinner' with your actual spinner component\n        Paragraph(\"Loading data...\")\n    ])\n\ndef ErrorComponent(error):\n    \"\"\"Displays an error message when data fetching fails.\"\"\"\n    return Div(\"error\", [\n        Image(\"./public/error.png\", \"error\", \"45\", \"45\"),\n        Header1(\"Error Fetching Data\"),\n        Paragraph(error)\n    ])\n</code></pre>"},{"location":"advanced/fetch_data/#main-component","title":"main component","text":"<pre><code>from zenaura.client.component import Component\nfrom zenaura.client.mutator import mutator\nfrom public.presentational import *\nimport requests\ndef DataDisplayComponent(data):\n    return Div(\"data-dict\", [\n            Div(\"item\", [Paragraph(key), Paragraph(str(value))])\n            for key, value in data.items()\n        ])\n\nclass DataFetcher(Component):\n    def __init__(self):\n        super().__init__()\n        self.state = {\"data\": None, \"error\": None}  # Initial state\n\n    async def fetch_data(self):\n        try:\n            api_url = 'https://randomuser.me/api/'  # Your API endpoint\n            response = requests.get(api_url)\n            if response.ok:\n                self.state[\"data\"] = response.json()\n            else:\n                self.state[\"error\"] = \"API request failed\"\n        except Exception as e:\n            self.state[\"error\"] = str(e)\n\n    @mutator\n    async def attached(self):\n        await self.fetch_data()\n        print(self.state[\"data\"])\n\n\n    def render(self):\n        if self.state[\"error\"]:\n            return ErrorComponent(error=self.state[\"error\"])\n        elif self.state[\"data\"]:\n            return DataDisplayComponent(data=self.state[\"data\"])\n        else:\n            return LoadingComponent()\n</code></pre>"},{"location":"advanced/fetch_data/#build-and-run-zenaura-app","title":"Build and run zenaura app","text":"<pre><code>zenaura build\nzenaura run\n</code></pre> <p>now if we went to http://localhost:5000, and open the console we will see this</p> <pre><code>{\n  \"results\": [\n    {\n      \"gender\": \"male\",\n      \"name\": {\n        \"title\": \"Mr\",\n        \"first\": \"Charles\",\n        \"last\": \"Clark\"\n      },\n      \"location\": {\n        \"street\": {\n          \"number\": 5328,\n          \"name\": \"Vimy St\"\n        },\n        \"city\": \"Grand Falls\",\n        \"state\": \"Nunavut\",\n        \"country\": \"Canada\",\n        \"postcode\": \"Z1S 2U2\",\n        \"coordinates\": {\n          \"latitude\": \"-69.8976\",\n          \"longitude\": \"-134.5780\"\n        },\n        \"timezone\": {\n          \"offset\": \"-6:00\",\n          \"description\": \"Central Time (US &amp; Canada), Mexico City\"\n        }\n      },\n      \"email\": \"charles.clark@example.com\",\n      \"login\": {\n        \"uuid\": \"3338f687-3461-4a72-88e9-33eb19c9077d\",\n        \"username\": \"tinymeercat320\",\n        \"password\": \"kang\",\n        \"salt\": \"mrAgPCkY\",\n        \"md5\": \"1e1006b14c2e083026c86c129be8c0b8\",\n        \"sha1\": \"e29949ab4b75c8fa07b79312098e28edb7e10e27\",\n        \"sha256\": \"e3f3e1ffcf4e73ece750f437f70ac840a941b154e002a5d7327ee84111f59230\"\n      },\n      \"dob\": {\n        \"date\": \"1957-01-26T13:12:12.937Z\",\n        \"age\": 67\n      },\n      \"registered\": {\n        \"date\": \"2020-10-19T19:29:09.124Z\",\n        \"age\": 3\n      },\n      \"phone\": \"C57 P04-4851\",\n      \"cell\": \"R98 P02-7749\",\n      \"id\": {\n        \"name\": \"SIN\",\n        \"value\": \"389514100\"\n      },\n      \"picture\": {\n        \"large\": \"https://randomuser.me/api/portraits/men/70.jpg\",\n        \"medium\": \"https://randomuser.me/api/portraits/med/men/70.jpg\",\n        \"thumbnail\": \"https://randomuser.me/api/portraits/thumb/men/70.jpg\"\n      },\n      \"nat\": \"CA\"\n    }\n  ],\n  \"info\": {\n    \"seed\": \"61b28009e82e3240\",\n    \"results\": 1,\n    \"page\": 1,\n    \"version\": \"1.4\"\n  }\n}\n</code></pre>"},{"location":"advanced/fetch_data/#explanation","title":"Explanation","text":"<ul> <li>State: The <code>state</code> dictionary holds the fetched data (<code>data</code>) and any potential error messages (<code>error</code>).</li> <li><code>fetch_data</code>: This <code>async</code> function handles the API request using <code>requests</code>.</li> <li><code>data</code> &amp; <code>error</code>: update the state based on the API response or error.</li> <li><code>attached</code>: Automatically fetches data when the component is added to the DOM, and re-render the component with the data.</li> </ul> <p>In all, this component will set data to data state, error to error if error exists, it uses python requests library to fetch requests, and on success renders an error or data.</p>"},{"location":"advanced/fetch_data/#key-improvements","title":"Key Improvements","text":"<ul> <li>Clearer structure and separation of concerns.</li> <li>Error handling mechanism.</li> <li>Flexibility to use different state management approaches.</li> </ul>"},{"location":"advanced/lifecycle/","title":"Component Lifecycle","text":""},{"location":"advanced/lifecycle/#lifecycle-methods-a-deep-dive-into-zenauras-virtual-dom-component-management","title":"Lifecycle Methods: A Deep Dive into Zenaura's Virtual DOM Component Management","text":"<p> Zenaura's component lifecycle management, facilitated by its virtual DOM (VDOM), offers a structured approach to handling component interactions within a web application's UI. Understanding these lifecycle methods is crucial for developers seeking to optimize component behavior and create seamless user experiences. Note the component lifecycle start with attached and until the last lifecycle which is on_settled. Within every transition even inside a lifecycle, on_error is there to gracefully handle errors.</p>"},{"location":"advanced/lifecycle/#mount-lifecycles-initializing-component-presence","title":"Mount LifeCycles: Initializing Component Presence","text":"<p>The <code>MountLifeCycles</code> class, extending <code>HydratorVirtualDomAdapter</code>, focuses on the initial stages of a component's lifecycle when it's integrated into the DOM:</p> <ul> <li><code>attached(comp)</code> (async): This method is triggered immediately after a component is mounted onto the DOM. It serves as the ideal space for essential setup tasks:<ul> <li>State Initialization: Establish the component's internal data and variables.</li> <li>Event Listener Setup: Attach handlers to respond to user interactions or other events.</li> <li>API Calls: Fetch external data to populate or update the component.</li> <li>Animations: Initiate visual transitions or effects upon mounting.</li> </ul> </li> </ul> <pre><code>async def attached(self, comp):\n    if hasattr(comp, 'attached'):\n        await comp.attached()\n</code></pre> <p>Key Point: The <code>attached</code> method only executes if the component itself defines an <code>attached</code> method. This flexibility allows developers to customize component behavior as needed.</p>"},{"location":"advanced/lifecycle/#render-lifecycle-managing-component-updates","title":"Render LifeCycle: Managing Component Updates","text":"<p>The <code>RenderLifeCycle</code> class focuses on the dynamic aspects of a component's existence, particularly when updates and re-renders occur:</p> <ul> <li><code>on_mutation(comp)</code> (async): This method is invoked before the actual DOM update takes place. It's designed for tasks that need to be executed right before the component's visual representation is altered:<ul> <li>State Updates Based on Props: Modify the component's internal state based on changes in its props (data passed from parent components).</li> <li>Pre-Update API Calls or Logic: Perform any necessary calculations or data fetching before the UI is refreshed.</li> </ul> </li> </ul> <pre><code>async def on_mutation(self, comp):\n    if hasattr(comp, 'on_mutation'):\n        await comp.on_mutation()\n</code></pre> <ul> <li><code>on_settled(comp)</code> (async): This method is activated after the DOM update is complete and the component has settled into its new state. It's ideal for post-render actions:<ul> <li>Focusing Elements: Automatically place the user's cursor in an input field.</li> <li>Scrolling: Programmatically scroll the page to a specific section or element.</li> <li>Custom Events: Trigger events to notify other parts of your application about the update.</li> </ul> </li> </ul> <pre><code>async def on_settled(self, comp):\n    if hasattr(comp, 'on_settled'):\n        await comp.on_settled()\n</code></pre> <p>Absolutely! Let's add the <code>on_error</code> lifecycle method to our deep dive guide:</p>"},{"location":"advanced/lifecycle/#error-handling-with-on_error","title":"Error Handling with <code>on_error</code>","text":"<p>In addition to the standard lifecycle methods, Zenaura provides the <code>on_error</code> lifecycle method to gracefully handle errors that might occur during the rendering process.</p> <ul> <li><code>on_error(comp, error)</code> (async): This method is triggered if an error is raised while a component is being rendered or updated. It receives two arguments:<ul> <li><code>comp</code>: The component instance where the error occurred.</li> <li><code>error</code>: The exception object representing the error.</li> </ul> </li> </ul> <pre><code>async def on_error(self, comp, error):\n    if hasattr(comp, 'on_error'):\n        await comp.on_error(error)\n</code></pre> <p>Purpose: The primary purpose of <code>on_error</code> is to allow you to:</p> <ul> <li>Log the Error:  Record details about the error for debugging and analysis.</li> <li>Display User-Friendly Messages:  Present a clear and informative error message to the user, rather than a technical stack trace.</li> <li>Fallback UI:  Render alternative content or a simplified version of the component to maintain some level of functionality.</li> <li>State Recovery:  Attempt to recover from the error by resetting the component's state or taking other corrective actions.</li> </ul>"},{"location":"advanced/lifecycle/#example-usage","title":"Example Usage","text":"<pre><code>class MyComponent:\n    # ... other lifecycle methods ...\n\n    async def on_error(self, error):\n        print(f\"Error in MyComponent: {error}\")  # Log the error\n        self.state['error_message'] = \"An error occurred while loading data.\"  # Update UI with error message\n</code></pre> <p>In this example, the <code>on_error</code> method logs the error to the console and updates the component's state to display an error message to the user.</p>"},{"location":"advanced/lifecycle/#best-practices","title":"Best Practices","text":"<ul> <li>Always Define <code>on_error</code>:  Include the <code>on_error</code> method in your components, even if you initially just log the error. It's better to have a basic error handler in place than to let errors crash your application silently.</li> <li>Be Specific:  Tailor your error handling to the specific types of errors that might occur in each component.</li> <li>Prioritize User Experience:  Focus on providing clear and helpful error messages to guide the user.</li> <li>Logging: Use logging to record error details for later analysis.</li> </ul> <p>By incorporating the <code>on_error</code> lifecycle method and following these best practices, you can create more robust and user-friendly Zenaura components that can gracefully recover from unexpected errors.</p>"},{"location":"advanced/lifecycle/#why-lifecycle-methods-matter","title":"Why Lifecycle Methods Matter","text":"<p>Understanding and utilizing lifecycle methods in Zenaura's VDOM system empowers developers to:</p> <ul> <li>Organize Logic: Break down complex component behavior into well-defined stages.</li> <li>Optimize Performance: Execute tasks precisely when needed, avoiding unnecessary computations.</li> <li>Enhance User Experience:  Create smooth, visually appealing updates and transitions.</li> <li>Customize Behavior: Tailor each component's lifecycle to suit specific requirements.</li> </ul>"},{"location":"advanced/lifecycle/#example-usage_1","title":"Example Usage","text":"<pre><code>class MyComponent:\n    async def attached(self):\n        # Fetch initial data from API\n        self.data = await fetch_data()\n\n    async def on_mutation(self):\n        # Update state based on props if needed\n        if self.props['filter'] != self.state['filter']:\n            self.state['filter'] = self.props['filter']\n            self.data = await fetch_filtered_data(self.state['filter'])\n\n    async def on_settled(self):\n        # Highlight the selected item in a list after re-render\n        highlight_selected_item()\n</code></pre> <p>In this example, the <code>attached</code> method fetches initial data, <code>on_mutation</code> handles state updates and subsequent data filtering, and <code>on_settled</code> manages UI interactions after the update.</p>"},{"location":"advanced/pydide/","title":"Pyodide: Python Scientific Stack in the Browser","text":"<p>Pyodide is a remarkable project that brings the full power of the Python scientific stack to your web browser. It enables you to run Python code, including popular libraries like NumPy, SciPy, Matplotlib, Pandas, and more, directly within the browser environment.</p>"},{"location":"advanced/pydide/#key-features-and-advantages","title":"Key Features and Advantages","text":"<ul> <li>WebAssembly (Wasm): Pyodide leverages the performance and portability of WebAssembly to execute Python code efficiently.</li> <li>Scientific Stack: Access a vast array of scientific computing libraries, making it ideal for data analysis, visualization, machine learning, and other computational tasks.</li> <li>REPL (Interactive Shell): Experiment with Python code interactively in your browser using Pyodide's built-in REPL.</li> <li>Notebook Environments: Integrate Pyodide with popular notebook interfaces like JupyterLite for a familiar interactive development experience.</li> <li>Flexibility: Use Pyodide as a standalone library or as part of larger frameworks like PyScript.</li> </ul>"},{"location":"advanced/pydide/#how-pyodide-works","title":"How Pyodide Works","text":"<ol> <li>Emscripten: Pyodide uses Emscripten, a powerful compiler toolchain, to translate the CPython interpreter (the standard Python implementation) and its associated libraries into WebAssembly modules.</li> <li>WebAssembly Runtime: These WebAssembly modules are then loaded and executed within the browser's WebAssembly runtime.</li> <li>JavaScript Bridge: Pyodide provides a bridge between Python and JavaScript, allowing you to call JavaScript functions from Python and vice versa.</li> </ol>"},{"location":"advanced/pydide/#getting-started-with-pyodide","title":"Getting Started with Pyodide","text":"<ol> <li>Include Pyodide: Add the following <code>&lt;script&gt;</code> tag in your HTML file's <code>&lt;head&gt;</code> section:</li> </ol> <pre><code>&lt;script src=\"https://cdn.jsdelivr.net/pyodide/v0.23.4/full/pyodide.js\"&gt;&lt;/script&gt;\n</code></pre> <ol> <li>Load Packages: Use Pyodide's <code>loadPackage</code> function to import the necessary libraries:</li> </ol> <pre><code>async function main() {\n  let pyodide = await loadPyodide();\n  await pyodide.loadPackage([\"numpy\", \"matplotlib\"]);\n\n  // ... your Python code here\n}\n</code></pre> <ol> <li>Execute Python Code: Use Pyodide's <code>runPython</code> function to execute your Python code strings:</li> </ol> <pre><code>pyodide.runPython(`\n  import numpy as np\n  import matplotlib.pyplot as plt\n\n  x = np.arange(0, 2 * np.pi, 0.1)\n  y = np.sin(x)\n\n  plt.plot(x, y)\n  plt.show()\n`);\n</code></pre> <p>Example: Interactive Plot</p> <p>The above code snippet demonstrates how to create an interactive sine wave plot directly in your web page using Pyodide and Matplotlib.</p> <p>Advanced Pyodide Concepts</p> <ul> <li>Custom Packages:  Package and load your own Python modules into Pyodide.</li> <li>File System Access: Use Pyodide's virtual file system to interact with files.</li> <li>Web Workers: Run Pyodide in a background thread (Web Worker) for improved performance.</li> </ul> <p>Documentation and Resources</p> <ul> <li>Pyodide Documentation: https://pyodide.org/en/stable/</li> <li>Pyodide GitHub Repository: https://github.com/pyodide/pyodide</li> </ul>"},{"location":"advanced/pyscript/","title":"PyScript: Python in the Browser","text":"<p>PyScript is a framework that allows you to run Python code directly in your web browser. This opens up a wealth of possibilities, from creating interactive data visualizations and educational tools to building full-fledged web applications using your Python skills.</p>"},{"location":"advanced/pyscript/#key-features-and-advantages","title":"Key Features and Advantages","text":"<ul> <li>Ease of Use: PyScript eliminates the need for complex server setups or installations. Your Python code runs seamlessly within the browser environment.</li> <li>Expressiveness: Leverage the full power and readability of Python, a language known for its simplicity and versatility.</li> <li>Scalability: Your applications can run on any device with a modern web browser, from desktops to tablets and mobile phones.</li> <li>Shareability: PyScript applications are easily shared via URLs, making them accessible to a wide audience.</li> <li>Security: PyScript runs in the sandboxed environment of the browser, offering inherent security benefits.</li> </ul>"},{"location":"advanced/pyscript/#how-pyscript-works","title":"How PyScript Works","text":"<ol> <li>Pyodide:  At the core of PyScript is Pyodide, a port of CPython (the reference implementation of Python) to WebAssembly. This allows Python code to be interpreted and executed within the browser.</li> <li>DOM Interaction: PyScript provides mechanisms to interact with the Document Object Model (DOM), the structure of a web page. You can manipulate HTML elements, handle events, and dynamically update content using Python.</li> <li>FFI (Foreign Function Interface): PyScript enables seamless communication between Python and JavaScript through the FFI. This means you can access web APIs, utilize JavaScript libraries, and even call Python functions from JavaScript code.</li> </ol>"},{"location":"advanced/pyscript/#getting-started-with-pyscript","title":"Getting Started with PyScript","text":"<ol> <li>Include PyScript: Add the following lines within the <code>&lt;head&gt;</code> section of your HTML file:</li> </ol> <pre><code>&lt;link rel=\"stylesheet\" href=\"https://pyscript.net/alpha/pyscript.css\" /&gt;\n&lt;script defer src=\"https://pyscript.net/alpha/pyscript.js\"&gt;&lt;/script&gt;\n</code></pre> <ol> <li>Write Python Code: Embed your Python code within <code>&lt;py-script&gt;</code> tags:</li> </ol> <pre><code>&lt;py-script&gt;\n  print(\"Hello from PyScript!\")\n&lt;/py-script&gt;\n</code></pre> <p>Example: Interactive Plot</p> <pre><code>&lt;py-script&gt;\nimport matplotlib.pyplot as plt\n\nx = [1, 2, 3, 4]\ny = [1, 4, 9, 16]\nplt.plot(x, y)\nplt.show()\n&lt;/py-script&gt;\n</code></pre> <p>This code will render a simple line plot directly in your web page.</p>"},{"location":"advanced/pyscript/#advanced-pyscript-concepts","title":"Advanced PyScript Concepts","text":"<ul> <li>Components: Create reusable UI elements (e.g., buttons, input fields) with custom logic.</li> <li>Plugins: Extend PyScript's functionality with plugins for tasks like code formatting and REPL (interactive shell) integration.</li> <li>Offline Mode: Cache PyScript resources for offline use.</li> </ul>"},{"location":"advanced/pyscript/#documentation-and-resources","title":"Documentation and Resources","text":"<p>The official PyScript documentation is your best resource for in-depth information and examples:</p> <ul> <li>PyScript Documentation: https://docs.pyscript.net/</li> </ul>"},{"location":"advanced/virtual_dom/","title":"Zenaura Virtual DOM: A Conceptual Deep Dive","text":"<p>  Zenaura's Virtual DOM revolutionizes how you build dynamic web interfaces. It introduces a layer of abstraction between your UI components and the browser's actual DOM, enabling faster updates and a smoother user experience.</p>"},{"location":"advanced/virtual_dom/#1-the-power-of-the-virtual-dom","title":"1. The Power of the Virtual DOM","text":"<ul> <li> <p>What is it?  The VDOM is a lightweight in-memory representation of your web page's structure, similar to a JavaScript object. It mirrors the real DOM but is much faster to manipulate.</p> </li> <li> <p>Why use it? Directly updating the actual DOM can be slow and inefficient. The VDOM allows Zenaura to intelligently determine the minimal set of changes needed and apply them efficiently, resulting in improved performance.</p> </li> </ul>"},{"location":"advanced/virtual_dom/#2-how-zenaura-vdom-works","title":"2. How Zenaura VDOM Works","text":"<ol> <li>Initial Render: When your Zenaura components render, they create a VDOM tree. This tree represents the initial state of your UI.</li> <li>State Changes: Data within your components are linked to mutators which are user events that when changed (e.g., through user interactions or API calls), the associated components re-render, creating a new VDOM tree.</li> <li>Diffing (Reconciliation): Zenaura compares the old VDOM tree with the new one to identify the differences. This process is called \"diffing\" or \"reconciliation.\"</li> <li>Efficient Updates: Zenaura applies only the necessary changes to the real DOM, updating elements, attributes, or text content as needed. It gather all the updates, intelligently determine the minimal set of operations, patch and schedule the update to the real DOM in asyncrounous non-blocking way. This insure smooth user experience, and very low latency, and fast app rendering.</li> </ol>"},{"location":"advanced/virtual_dom/#3-the-role-of-zenaura-components","title":"3. The Role of Zenaura Components","text":"<ul> <li> <p>Building Blocks: Your UI is composed of Zenaura <code>Component</code> classes. Each component defines its structure (<code>render</code> method) and how it reacts to data changes.</p> </li> <li> <p>Data-Driven: Components are data-driven. They render their structure based on their internal <code>state</code>. When state changes, the <code>render</code> method is called again, generating a new VDOM.</p> </li> <li> <p>Mutators (Optional): Zenaura provides the <code>@mutator</code> decorator for methods that modify component state. This ensures the VDOM is efficiently re-render the component intentionally, minimizing poor UI/UX resulting from developers re-rendering the component unintentionally.</p> </li> <li> <p>Lifecycle methods: Components can define lifecycle methods that extend the functionality of the component, you might want to do something before the component renders so you use <code>attached</code> lifecycle method, you might want to do something before the component re-renders so you use <code>on_mutation</code> lifecycle method, you might want to do something after the component re-renders so you use <code>on_seatled</code>, finally you might want to catch errors in the component so you use <code>on_error</code> lifecycle method. There is dedicated guides in advanced concepts section for lifecycle methods and handling errors.</p> </li> </ul>"},{"location":"advanced/virtual_dom/#4-zenaura-vdom-in-action-code-snippet","title":"4. Zenaura VDOM in Action: Code Snippet","text":"<pre><code>@Reuseable  # Marks the component as potentially having multiple instances\nclass Counter(Component):\n    # ... (state, mutators)\n\n    def render(self) -&gt; Node:\n        # Create VDOM nodes (div, button, etc.) based on component state\n        # ...\n</code></pre> <p>In this example:</p> <ul> <li><code>Counter</code> is a reusable component representing a counter widget.</li> <li>The <code>render</code> method constructs a VDOM tree describing the component's structure.</li> <li>User actions (like clicking buttons) trigger mutators that update the state, causing <code>render</code> to be called again, and the VDOM to be refreshed.</li> </ul>"},{"location":"advanced/virtual_dom/#benefits-of-zenaura-vdom","title":"Benefits of Zenaura VDOM","text":"<ul> <li>Performance: Minimizes expensive DOM manipulations, resulting in smoother UI updates.</li> <li>Declarative UI: Focus on describing what your UI should look like, not how to update it step by step.</li> <li>Component Reusability: Build modular components that encapsulate their own logic and state.</li> </ul>"},{"location":"advanced/virtual_dom/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Zenaura VDOM is a powerful tool for building high-performance, interactive web applications.</li> <li>Understanding the VDOM concept is key to mastering Zenaura development.</li> <li>Leverage the VDOM's capabilities to create efficient and maintainable UIs.</li> </ul>"},{"location":"api/client/app/","title":"Router","text":""},{"location":"api/client/app/#zenaura.client.app.App","title":"<code>App</code>","text":"<p>Represents a router for managing routes and navigation.</p> <p>This class provides methods for adding routes, navigating between pages, and handling the current location.</p> <p>Attributes:</p> Name Type Description <code>routes</code> <code>dict</code> <p>A dictionary mapping paths to their associated pages and titles.</p> <code>paths</code> <code>list</code> <p>A list of paths registered in the router.</p> <code>history</code> <code>PageHistory</code> <p>An object that manages the history of visited pages.</p> Source code in <code>zenaura/client/app.py</code> <pre><code>class App:\n    \"\"\"\n    Represents a router for managing routes and navigation.\n\n    This class provides methods for adding routes, navigating between pages, and handling the current location.\n\n    Attributes:\n        routes (dict): A dictionary mapping paths to their associated pages and titles.\n        paths (list): A list of paths registered in the router.\n        history (PageHistory): An object that manages the history of visited pages.\n\n    Methods:\n        __init__()\n            Initializes the App with empty routes and paths, and sets up the initial route handling.\n        navigate(path)\n            Navigates to the specified path by mounting the associated page and updating the document title and browser history.\n        handle_location()\n            Handles the current location by mounting the associated page and updating the document title.\n        add_route(route)\n            Adds a route to the router's configuration.\n        back()\n            Navigates back to the previous Page in the history stack.\n        forward()\n            Navigates forward to the next Page in the history stack.\n        get_current_route()\n            Get the page and title of the current route, or None if not found.\n    \"\"\"\n    def __init__(self, layout=None):\n        \"\"\"\n            Initializes the App with empty routes and paths, and sets up the initial route handling.\n        \"\"\"\n        # key -&gt; path , value -&gt; [page, document.title]\n        self.routes = defaultdict(str)\n        self.paths = []\n        self.history = PageHistory()\n        self._layout = layout\n\n    @property\n    def layout(self):\n        return self._layout\n\n    @layout.setter\n    def layout(self, new_layout):\n        self._layout = new_layout \n\n    async def not_found(self):\n        document.title = \"Page Not Found\"\n        page = Page([notFound])\n        await zenaura_dom.mount(page)\n        self.history.visit(page)\n\n    async def mount_layout(self) -&gt; None:\n        \"\"\"\n            Trigger mount method for layout components if layout is defined\n        \"\"\"\n        if self._layout:\n            # mount  global components \n            comps = self._layout.top + self._layout.bottom\n            for comp in comps:\n                if hasattr(comp, \"attached\"):\n                    await comp.attached()\n\n\n    async def navigate(self, path) -&gt; None:\n        \"\"\"\n        Navigates to the specified path by mounting the associated pageonent and updating the document title and browser history.\n\n        Parameters\n        ----------\n        path : str\n            The path to navigate to.\n        \"\"\"\n        # handle route\n        matched_route, params = self._match_route(path)\n        if not matched_route:\n            await self.not_found()\n            return\n\n        [page, title, middleware, ssr] = matched_route\n\n        if callable(middleware):\n            middleware()\n\n        if ssr:  # Ignore mount step for server side rendering pages.\n            await zenaura_dom.mount(page)\n            self.history.visit(page)\n            document.title = title\n            return\n\n        if not self.history.current.page:  # self.history.current is initially None\n            pass\n        else:\n            # set document.title here\n            document.title = title\n            self.hyd_rdom_toggle_pages_visibilty(self.history.current.page, page)\n\n        window.history.pushState(path, title, path)  # Update browser history\n\n        # trigger layout components mount if layout is defined, after \n        # the reason after pushState, middleware\n        # global components may be be coupled to a state of route path or middleware\n        await self.mount_layout()\n        # mount page\n        await zenaura_dom.mount(page)\n        self.history.visit(page)\n\n    def run(self):\n        \"\"\"\n            facade interface mounts the app on \"/\" location\n            e.g. \n            app = App()\n            app.add_route(\n                Route(\n                    \"Home\", \n                    \"/\",\n                    Page(\n                        [counter1, counter2, counter3, counter4]\n                ) \n                )\n            )\n            app.run()\n\n        \"\"\"\n        dispatcher.dispatch(self.handle_location)\n\n    def hyd_rdom_toggle_pages_visibilty(self, previous_page: Page, current_page: Page):\n        p_page = document.querySelector(f'[data-zenaura=\"{previous_page.id}\"]')\n        if p_page:\n            p_page.hidden = True  # Hide the previous page\n        curr_page = document.querySelector(f'[data-zenaura=\"{current_page.id}\"]')\n        if curr_page:\n            curr_page.hidden = False  # Show the current page\n\n    async def handle_location(self) -&gt; None:\n        \"\"\"\n        Handles the current location by mounting the associated page and updating the document title.\n        \"\"\"\n        # handle home route\n        path = window.location.pathname\n        matched_route, params = self._match_route(path)\n        if not matched_route:\n            await self.not_found()\n            return\n        [page, title, middleware, ssr] = self.routes[path]\n        window.history.pushState(path, title, path)  # Update browser history\n\n        if callable(middleware):\n            middleware()\n\n        # trigger layout components mount if layout is defined, after \n        # the reason after pushState, middleware\n        # global components may be be coupled to a state of route path or middleware\n        await self.mount_layout()\n        if ssr:  # Ignore mount step for server side rendering pages.\n            await zenaura_dom.mount(page)\n            self.history.visit(page)\n            document.title = title\n            return\n        if not self.history.current.page:  # self.history.current is initially None\n           pass\n        else:\n            document.title = title # overwrite document.title \n            self.hyd_rdom_toggle_pages_visibilty(self.history.current.page, page)\n\n        # visit page\n        self.history.visit(page)\n        await zenaura_dom.mount(page)  # Trigger attached lifecycle for each component within the page.\n\n\n    def add_route(self, route : Route) -&gt; None:\n        \"\"\"\n        Adds a route to the router's configuration.\n\n        Parameters\n        ----------\n        route : Route\n            The route to be added to the router's configuration.\n        \"\"\"\n        self.routes[route.path] = [route.page, route.title, route.middleware, route.ssr]\n        self.paths.append(route.path)\n\n    async def back(self) -&gt; None:\n        \"\"\"\n        Navigates back to the previous Page in the history stack.\n        \"\"\"\n        previous_page = self.history.current.page\n        curr_page = self.history.back()\n        rdom_hyd.hyd_rdom_toggle_pages_visibilty(previous_page, curr_page)\n        await zenaura_dom.mount(curr_page)  # trigger attached lifecycle for each component within the page.\n\n\n    async def forward(self) -&gt; None:\n        \"\"\"\n        Navigates forward to the next Page in the history stack.\n        \"\"\"\n        previous_page = self.history.current.page\n        curr_page = self.history.forward()\n        rdom_hyd.hyd_rdom_toggle_pages_visibilty(previous_page, curr_page)\n        await zenaura_dom.mount(curr_page)  # trigger attached lifecycle for each component within the page.\n\n\n    def get_current_route(self) -&gt; Optional[Tuple[Page, str]]:\n        \"\"\"\n        Get the page and title of the current route, or None if not found.\n        \"\"\"\n        path = window.location.pathname\n        matched_route, info = self._match_route(path)\n        return matched_route, info\n\n    # TODO still needs a lot of work\n    def _match_route(self, path: str) -&gt; Tuple[Optional[Tuple[Page, str, Dict[str, Any]]], Dict[str, str]]:\n        \"\"\"\n        Matches the given path to a registered route and extracts parameters.\n\n        Args:\n            path (str): The path to match.\n\n        Returns:\n            Tuple[Optional[Tuple[Page, str, Dict[str, Any]]], Dict[str, str]]:\n                A tuple containing the matched route information (if any) and extracted parameters.\n        \"\"\"\n        for route_path, (page, title, middleware, ssr) in self.routes.items():\n            if \"*\" in route_path:  # Wildcard route\n                route_parts = route_path.split(\"*\")\n                if path.startswith(route_parts[0]):\n                    params = path[len(route_parts[0]):]\n                    query = defaultdict(str)\n                    if \"?\" in params: # get all queries\n                        newq = \"\".join(params).split(\"?\")\n                        params = newq[0]\n                        newq = newq[1]\n                        for q in newq.split(\"&amp;\"):\n                            k,v = q.split(\"=\")\n                            query[k] = v\n                    if \"/\" in params: # get all params\n                        params = params.split(\"/\")\n\n                    params = {\"wildcard\": {\"params\" : params, \"query\" : query} }\n\n                    return (page, title, middleware, ssr), params\n            elif \":\" in route_path:  # Parameterized route\n                route_parts = route_path.split(\"/\")\n                path_parts = path.split(\"/\")\n                if len(route_parts) == len(path_parts):\n                    params = {}\n                    for i, part in enumerate(route_parts):\n                        if part.startswith(\":\"):\n                            param_name = part[1:]\n                            params[param_name] = path_parts[i]\n                    return (page, title, middleware, ssr), params\n            elif route_path == path:  # Exact match\n                return (page, title, middleware, ssr), {}\n        return None, {}  # No match found\n</code></pre>"},{"location":"api/client/app/#zenaura.client.app.App.__init__","title":"<code>__init__(layout=None)</code>","text":"<p>Initializes the App with empty routes and paths, and sets up the initial route handling.</p> Source code in <code>zenaura/client/app.py</code> <pre><code>def __init__(self, layout=None):\n    \"\"\"\n        Initializes the App with empty routes and paths, and sets up the initial route handling.\n    \"\"\"\n    # key -&gt; path , value -&gt; [page, document.title]\n    self.routes = defaultdict(str)\n    self.paths = []\n    self.history = PageHistory()\n    self._layout = layout\n</code></pre>"},{"location":"api/client/app/#zenaura.client.app.App.add_route","title":"<code>add_route(route)</code>","text":"<p>Adds a route to the router's configuration.</p>"},{"location":"api/client/app/#zenaura.client.app.App.add_route--parameters","title":"Parameters","text":"<p>route : Route     The route to be added to the router's configuration.</p> Source code in <code>zenaura/client/app.py</code> <pre><code>def add_route(self, route : Route) -&gt; None:\n    \"\"\"\n    Adds a route to the router's configuration.\n\n    Parameters\n    ----------\n    route : Route\n        The route to be added to the router's configuration.\n    \"\"\"\n    self.routes[route.path] = [route.page, route.title, route.middleware, route.ssr]\n    self.paths.append(route.path)\n</code></pre>"},{"location":"api/client/app/#zenaura.client.app.App.back","title":"<code>back()</code>  <code>async</code>","text":"<p>Navigates back to the previous Page in the history stack.</p> Source code in <code>zenaura/client/app.py</code> <pre><code>async def back(self) -&gt; None:\n    \"\"\"\n    Navigates back to the previous Page in the history stack.\n    \"\"\"\n    previous_page = self.history.current.page\n    curr_page = self.history.back()\n    rdom_hyd.hyd_rdom_toggle_pages_visibilty(previous_page, curr_page)\n    await zenaura_dom.mount(curr_page)  # trigger attached lifecycle for each component within the page.\n</code></pre>"},{"location":"api/client/app/#zenaura.client.app.App.forward","title":"<code>forward()</code>  <code>async</code>","text":"<p>Navigates forward to the next Page in the history stack.</p> Source code in <code>zenaura/client/app.py</code> <pre><code>async def forward(self) -&gt; None:\n    \"\"\"\n    Navigates forward to the next Page in the history stack.\n    \"\"\"\n    previous_page = self.history.current.page\n    curr_page = self.history.forward()\n    rdom_hyd.hyd_rdom_toggle_pages_visibilty(previous_page, curr_page)\n    await zenaura_dom.mount(curr_page)  # trigger attached lifecycle for each component within the page.\n</code></pre>"},{"location":"api/client/app/#zenaura.client.app.App.get_current_route","title":"<code>get_current_route()</code>","text":"<p>Get the page and title of the current route, or None if not found.</p> Source code in <code>zenaura/client/app.py</code> <pre><code>def get_current_route(self) -&gt; Optional[Tuple[Page, str]]:\n    \"\"\"\n    Get the page and title of the current route, or None if not found.\n    \"\"\"\n    path = window.location.pathname\n    matched_route, info = self._match_route(path)\n    return matched_route, info\n</code></pre>"},{"location":"api/client/app/#zenaura.client.app.App.handle_location","title":"<code>handle_location()</code>  <code>async</code>","text":"<p>Handles the current location by mounting the associated page and updating the document title.</p> Source code in <code>zenaura/client/app.py</code> <pre><code>async def handle_location(self) -&gt; None:\n    \"\"\"\n    Handles the current location by mounting the associated page and updating the document title.\n    \"\"\"\n    # handle home route\n    path = window.location.pathname\n    matched_route, params = self._match_route(path)\n    if not matched_route:\n        await self.not_found()\n        return\n    [page, title, middleware, ssr] = self.routes[path]\n    window.history.pushState(path, title, path)  # Update browser history\n\n    if callable(middleware):\n        middleware()\n\n    # trigger layout components mount if layout is defined, after \n    # the reason after pushState, middleware\n    # global components may be be coupled to a state of route path or middleware\n    await self.mount_layout()\n    if ssr:  # Ignore mount step for server side rendering pages.\n        await zenaura_dom.mount(page)\n        self.history.visit(page)\n        document.title = title\n        return\n    if not self.history.current.page:  # self.history.current is initially None\n       pass\n    else:\n        document.title = title # overwrite document.title \n        self.hyd_rdom_toggle_pages_visibilty(self.history.current.page, page)\n\n    # visit page\n    self.history.visit(page)\n    await zenaura_dom.mount(page)  # Trigger attached lifecycle for each component within the page.\n</code></pre>"},{"location":"api/client/app/#zenaura.client.app.App.mount_layout","title":"<code>mount_layout()</code>  <code>async</code>","text":"<p>Trigger mount method for layout components if layout is defined</p> Source code in <code>zenaura/client/app.py</code> <pre><code>async def mount_layout(self) -&gt; None:\n    \"\"\"\n        Trigger mount method for layout components if layout is defined\n    \"\"\"\n    if self._layout:\n        # mount  global components \n        comps = self._layout.top + self._layout.bottom\n        for comp in comps:\n            if hasattr(comp, \"attached\"):\n                await comp.attached()\n</code></pre>"},{"location":"api/client/app/#zenaura.client.app.App.navigate","title":"<code>navigate(path)</code>  <code>async</code>","text":"<p>Navigates to the specified path by mounting the associated pageonent and updating the document title and browser history.</p>"},{"location":"api/client/app/#zenaura.client.app.App.navigate--parameters","title":"Parameters","text":"<p>path : str     The path to navigate to.</p> Source code in <code>zenaura/client/app.py</code> <pre><code>async def navigate(self, path) -&gt; None:\n    \"\"\"\n    Navigates to the specified path by mounting the associated pageonent and updating the document title and browser history.\n\n    Parameters\n    ----------\n    path : str\n        The path to navigate to.\n    \"\"\"\n    # handle route\n    matched_route, params = self._match_route(path)\n    if not matched_route:\n        await self.not_found()\n        return\n\n    [page, title, middleware, ssr] = matched_route\n\n    if callable(middleware):\n        middleware()\n\n    if ssr:  # Ignore mount step for server side rendering pages.\n        await zenaura_dom.mount(page)\n        self.history.visit(page)\n        document.title = title\n        return\n\n    if not self.history.current.page:  # self.history.current is initially None\n        pass\n    else:\n        # set document.title here\n        document.title = title\n        self.hyd_rdom_toggle_pages_visibilty(self.history.current.page, page)\n\n    window.history.pushState(path, title, path)  # Update browser history\n\n    # trigger layout components mount if layout is defined, after \n    # the reason after pushState, middleware\n    # global components may be be coupled to a state of route path or middleware\n    await self.mount_layout()\n    # mount page\n    await zenaura_dom.mount(page)\n    self.history.visit(page)\n</code></pre>"},{"location":"api/client/app/#zenaura.client.app.App.run","title":"<code>run()</code>","text":"<p>facade interface mounts the app on \"/\" location e.g.  app = App() app.add_route(     Route(         \"Home\",          \"/\",         Page(             [counter1, counter2, counter3, counter4]     )      ) ) app.run()</p> Source code in <code>zenaura/client/app.py</code> <pre><code>def run(self):\n    \"\"\"\n        facade interface mounts the app on \"/\" location\n        e.g. \n        app = App()\n        app.add_route(\n            Route(\n                \"Home\", \n                \"/\",\n                Page(\n                    [counter1, counter2, counter3, counter4]\n            ) \n            )\n        )\n        app.run()\n\n    \"\"\"\n    dispatcher.dispatch(self.handle_location)\n</code></pre>"},{"location":"api/client/app/#zenaura.client.app.NotFound","title":"<code>NotFound</code>","text":"<p>               Bases: <code>Component</code></p> <p>Represents a page for displaying a \"page not found\" message.</p>"},{"location":"api/client/app/#zenaura.client.app.NotFound--methods","title":"Methods","text":"<p>render()     Returns a Node representing the \"page not found\" message.</p> Source code in <code>zenaura/client/app.py</code> <pre><code>@Reuseable\nclass NotFound(Component):\n    \"\"\"\n    Represents a page for displaying a \"page not found\" message.\n\n    Methods\n    -------\n    render()\n        Returns a Node representing the \"page not found\" message.\n    \"\"\"\n    def render(self):\n        em = Node(\"div\")\n        em.append_child(Node(name=\"text\", children=[\"page not found\"]))\n        return em\n</code></pre>"},{"location":"api/client/app/#zenaura.client.app.Route","title":"<code>Route</code>","text":"<p>Represents a route configuration for the App.</p> Source code in <code>zenaura/client/app.py</code> <pre><code>class Route:\n    \"\"\"\n        Represents a route configuration for the App.\n    \"\"\"\n    def __init__(self, title, path, page, middleware=None, ssr=False):\n        \"\"\"\n        Initializes a Route with the specified title, path, and pageonent.\n        Attributes\n        ----------\n        title : str\n            The title of the route.\n        path : str\n            The path of the route.\n        page : Page\n            A page of pageonents.\n        handler : Optional[Callable]\n            Optional route-specific logic handler.\n        middleware : Optional[Callable]\n            Optional route-specific logic handler.\n        ssr : bool\n            Whether the route is server-side rendered.\n        \"\"\"\n        self.title = title\n        self.path = path\n        self.page = page\n        self.ssr=ssr\n\n        if not isinstance(page, Page):\n            raise TypeError(\"Only a Page can be mounted on a route\")\n        self.middleware: Optional[Callable] = middleware  # For optional route-specific logic\n</code></pre>"},{"location":"api/client/app/#zenaura.client.app.Route.__init__","title":"<code>__init__(title, path, page, middleware=None, ssr=False)</code>","text":"<p>Initializes a Route with the specified title, path, and pageonent. Attributes</p> <p>title : str     The title of the route. path : str     The path of the route. page : Page     A page of pageonents. handler : Optional[Callable]     Optional route-specific logic handler. middleware : Optional[Callable]     Optional route-specific logic handler. ssr : bool     Whether the route is server-side rendered.</p> Source code in <code>zenaura/client/app.py</code> <pre><code>def __init__(self, title, path, page, middleware=None, ssr=False):\n    \"\"\"\n    Initializes a Route with the specified title, path, and pageonent.\n    Attributes\n    ----------\n    title : str\n        The title of the route.\n    path : str\n        The path of the route.\n    page : Page\n        A page of pageonents.\n    handler : Optional[Callable]\n        Optional route-specific logic handler.\n    middleware : Optional[Callable]\n        Optional route-specific logic handler.\n    ssr : bool\n        Whether the route is server-side rendered.\n    \"\"\"\n    self.title = title\n    self.path = path\n    self.page = page\n    self.ssr=ssr\n\n    if not isinstance(page, Page):\n        raise TypeError(\"Only a Page can be mounted on a route\")\n    self.middleware: Optional[Callable] = middleware  # For optional route-specific logic\n</code></pre>"},{"location":"api/client/component/","title":"component","text":"Source code in <code>zenaura/client/component.py</code> <pre><code>class UUIDManager:\n    @staticmethod\n    def generate_uuid(cls_name, count):\n        # Combine class name and count to create a unique string\n        unique_string = f\"{cls_name}{count}\"\n        # Hash the unique string to produce a 32-bit UUID\n        uuid_hash = hashlib.md5(unique_string.encode()).hexdigest()[:8]\n        return uuid_hash\n</code></pre> <p>Decorator to mark a component as reusable.</p> <p>Reusable components can be instantiated multiple times and will maintain their own state.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type</code> <p>The component class to be decorated.</p> required <p>Returns:</p> Name Type Description <code>type</code> <p>The decorated component class.</p> Source code in <code>zenaura/client/component.py</code> <pre><code>def Reuseable(cls):\n    \"\"\"\n    Decorator to mark a component as reusable.\n\n    Reusable components can be instantiated multiple times and will maintain their own state.\n\n    Args:\n        cls (type): The component class to be decorated.\n\n    Returns:\n        type: The decorated component class.\n    \"\"\"\n\n    original_init = cls.__init__\n\n    def new_init(self, *args, **kwargs):\n        original_init(self, *args, **kwargs)\n        cls.count = next(cls._component_count)\n        self.id = UUIDManager.generate_uuid(cls.__name__, self.count)\n        _is_reuseable[cls.__name__] = True\n\n    cls.__init__ = new_init\n    return cls\n</code></pre>"},{"location":"api/client/component/#zenaura.client.component.Component","title":"<code>Component</code>","text":"<p>Base class for all Zenaura components.</p> <p>Components are the building blocks of Zenaura applications. They represent reusable units of functionality that can be composed to create complex user interfaces.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>A unique identifier for the component.</p> <code>state</code> <code>dict</code> <p>The state of the component.</p> <code>_state</code> <code>dict</code> <p>The internal state of the component.</p> <code>_track_instances</code> <code>dict</code> <p>A dictionary tracking the number of instances created for each component class.</p> <code>_component_count</code> <code>count</code> <p>An iterator that generates unique counts for each component instance.</p> <p>Methods:</p> Name Description <code>__init_subclass__</code> <p>Initializes the subclass and sets the initial count for the component class.</p> <code>__init__</code> <p>Initializes the component instance and sets the unique identifier.</p> <code>get_state</code> <p>Returns the state of the component.</p> <code>set_state</code> <p>Sets the state of the component.</p> <code>render</code> <p>Abstract method that must be implemented by subclasses to define the behavior of the component.</p> Source code in <code>zenaura/client/component.py</code> <pre><code>class Component:\n    \"\"\"\n    Base class for all Zenaura components.\n\n    Components are the building blocks of Zenaura applications. They represent reusable units of functionality that can be composed to create complex user interfaces.\n\n    Attributes:\n        id (str): A unique identifier for the component.\n        state (dict): The state of the component.\n        _state (dict): The internal state of the component.\n        _track_instances (dict): A dictionary tracking the number of instances created for each component class.\n        _component_count (itertools.count): An iterator that generates unique counts for each component instance.\n\n    Methods:\n        __init_subclass__(cls, **kwargs):\n            Initializes the subclass and sets the initial count for the component class.\n        __init__(self):\n            Initializes the component instance and sets the unique identifier.\n        get_state(self):\n            Returns the state of the component.\n        set_state(self, state):\n            Sets the state of the component.\n        render(self):\n            Abstract method that must be implemented by subclasses to define the behavior of the component.\n    \"\"\"\n\n    _state = defaultdict(str)\n    _track_instances = defaultdict(int)\n    _component_count = itertools.count(0)\n\n    def __init_subclass__(cls, **kwargs):\n        \"\"\"\n        Initializes the subclass and sets the initial count for the component class.\n        \"\"\"\n        cls.count = next(cls._component_count)\n        cls.id = UUIDManager.generate_uuid(cls.__name__, cls.count)\n        super().__init_subclass__(**kwargs)\n\n    def __init__(self):\n        \"\"\"\n        Initializes the component instance and sets the unique identifier.\n        \"\"\"\n        cls = self.__class__\n        Component._track_instances[cls.__name__] += 1\n        if Component._track_instances[cls.__name__] &gt; 1 and not _is_reuseable[cls.__name__]:\n            raise TypeError(\n\"\"\"\n    Zenaura class component are limted by design. \\n\n    Decorate component with @Reuseable to implicitly  \\n\n    state the component is meant to be reused:  \\n\n    example :  \\n\n        class ThisIsLimited(Component):  \\n\n            pass\n        c1 = ThisIsLimited() // no error  \\n\n        c2 = ThisIsLimited() // throws error  \\n\n\n        @Reuseable  \\n\n        class ThisIsReuseable(Component):  \\n\n        c1 = ThisIsReuseable() // no error  \\n\n        c2 = ThisIsReuseable() // no error  \\n\n\"\"\"\n            )\n\n\n        # print(Component._track_instances[cls.__name__], cls.__name__, is_decorated_with_reuseable(cls))\n\n    @property\n    def state(self):\n        \"\"\"\n        Get the state of the component.\n\n        Returns:\n        dict: The state of the component.\n        \"\"\"\n\n        return self.get_state()\n\n    @state.setter\n    def state(self, value):\n        \"\"\"\n        Set the state of the component.\n\n        Args:\n        value (dict): The new state of the component.\n\n        Returns:\n        None\n        \"\"\"\n\n        self.set_state(value)\n\n    def get_state(self):\n        \"\"\"\n        Get the state of the component.\n\n        Returns:\n        dict: The state of the component.\n        \"\"\"\n\n        return self._state\n\n    def set_state(self, state):\n        \"\"\"\n        Set the state of the component.\n\n        Args:\n        state (dict): The new state of the component.\n\n        Returns:\n        None\n        \"\"\"\n\n        self._state = state  # Update the internal state\n\n    @abstractmethod\n    def render():\n        \"\"\"\n        Abstract method to be implemented by subclasses.\n\n        This method should be implemented by subclasses to define the behavior of the component.\n\n        Returns:\n        None\n        \"\"\"\n</code></pre>"},{"location":"api/client/component/#zenaura.client.component.Component.state","title":"<code>state</code>  <code>property</code> <code>writable</code>","text":"<p>Get the state of the component.</p> <p>Returns: dict: The state of the component.</p>"},{"location":"api/client/component/#zenaura.client.component.Component.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the component instance and sets the unique identifier.</p> Source code in <code>zenaura/client/component.py</code> <pre><code>    def __init__(self):\n        \"\"\"\n        Initializes the component instance and sets the unique identifier.\n        \"\"\"\n        cls = self.__class__\n        Component._track_instances[cls.__name__] += 1\n        if Component._track_instances[cls.__name__] &gt; 1 and not _is_reuseable[cls.__name__]:\n            raise TypeError(\n\"\"\"\n    Zenaura class component are limted by design. \\n\n    Decorate component with @Reuseable to implicitly  \\n\n    state the component is meant to be reused:  \\n\n    example :  \\n\n        class ThisIsLimited(Component):  \\n\n            pass\n        c1 = ThisIsLimited() // no error  \\n\n        c2 = ThisIsLimited() // throws error  \\n\n\n        @Reuseable  \\n\n        class ThisIsReuseable(Component):  \\n\n        c1 = ThisIsReuseable() // no error  \\n\n        c2 = ThisIsReuseable() // no error  \\n\n\"\"\"\n            )\n</code></pre>"},{"location":"api/client/component/#zenaura.client.component.Component.__init_subclass__","title":"<code>__init_subclass__(**kwargs)</code>","text":"<p>Initializes the subclass and sets the initial count for the component class.</p> Source code in <code>zenaura/client/component.py</code> <pre><code>def __init_subclass__(cls, **kwargs):\n    \"\"\"\n    Initializes the subclass and sets the initial count for the component class.\n    \"\"\"\n    cls.count = next(cls._component_count)\n    cls.id = UUIDManager.generate_uuid(cls.__name__, cls.count)\n    super().__init_subclass__(**kwargs)\n</code></pre>"},{"location":"api/client/component/#zenaura.client.component.Component.get_state","title":"<code>get_state()</code>","text":"<p>Get the state of the component.</p> <p>Returns: dict: The state of the component.</p> Source code in <code>zenaura/client/component.py</code> <pre><code>def get_state(self):\n    \"\"\"\n    Get the state of the component.\n\n    Returns:\n    dict: The state of the component.\n    \"\"\"\n\n    return self._state\n</code></pre>"},{"location":"api/client/component/#zenaura.client.component.Component.render","title":"<code>render()</code>  <code>abstractmethod</code>","text":"<p>Abstract method to be implemented by subclasses.</p> <p>This method should be implemented by subclasses to define the behavior of the component.</p> <p>Returns: None</p> Source code in <code>zenaura/client/component.py</code> <pre><code>@abstractmethod\ndef render():\n    \"\"\"\n    Abstract method to be implemented by subclasses.\n\n    This method should be implemented by subclasses to define the behavior of the component.\n\n    Returns:\n    None\n    \"\"\"\n</code></pre>"},{"location":"api/client/component/#zenaura.client.component.Component.set_state","title":"<code>set_state(state)</code>","text":"<p>Set the state of the component.</p> <p>Args: state (dict): The new state of the component.</p> <p>Returns: None</p> Source code in <code>zenaura/client/component.py</code> <pre><code>def set_state(self, state):\n    \"\"\"\n    Set the state of the component.\n\n    Args:\n    state (dict): The new state of the component.\n\n    Returns:\n    None\n    \"\"\"\n\n    self._state = state  # Update the internal state\n</code></pre>"},{"location":"api/client/component/#zenaura.client.component.Reuseable","title":"<code>Reuseable(cls)</code>","text":"<p>Decorator to mark a component as reusable.</p> <p>Reusable components can be instantiated multiple times and will maintain their own state.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type</code> <p>The component class to be decorated.</p> required <p>Returns:</p> Name Type Description <code>type</code> <p>The decorated component class.</p> Source code in <code>zenaura/client/component.py</code> <pre><code>def Reuseable(cls):\n    \"\"\"\n    Decorator to mark a component as reusable.\n\n    Reusable components can be instantiated multiple times and will maintain their own state.\n\n    Args:\n        cls (type): The component class to be decorated.\n\n    Returns:\n        type: The decorated component class.\n    \"\"\"\n\n    original_init = cls.__init__\n\n    def new_init(self, *args, **kwargs):\n        original_init(self, *args, **kwargs)\n        cls.count = next(cls._component_count)\n        self.id = UUIDManager.generate_uuid(cls.__name__, self.count)\n        _is_reuseable[cls.__name__] = True\n\n    cls.__init__ = new_init\n    return cls\n</code></pre>"},{"location":"api/client/dispatcher/","title":"Dispacher","text":"Source code in <code>zenaura/client/dispatcher.py</code> <pre><code>class AsyncDispatcher:\n    def __init__(self):\n        self.loop = None\n\n    def dispatch(self, coro_func, *args, **kwargs):\n        \"\"\"\n        Wrap asyncio.run to schedule and run the given coroutine.\n\n        :param coro_func: The coroutine function to execute.\n        :param args: Positional arguments for the coroutine.\n        :param kwargs: Keyword arguments for the coroutine.\n        \"\"\"\n        if in_browser:\n            asyncio.get_running_loop().run_until_complete(coro_func(*args, **kwargs))\n\n    def bind(self, id, event, maybe_awaitable):\n        \"\"\"\n        Subscribe an event to an element, window, or document and dispatch a sync or async callback.\n        Ensures the provided function has the correct signature.\n\n        :param id: ID attached to the component, or 'window'/'document' for global bindings.\n        :param event: Event name (e.g., \"click\", \"resize\", \"keydown\").\n        :param coroutine: Callback coroutine function.\n        :return: None if binding succeeds; raises an exception otherwise.\n        \"\"\"\n\n        if not callable(maybe_awaitable):\n            raise TypeError(\"The callback must be callable.\")\n\n        target = None\n\n        # Determine the target based on id\n        if id == \"window\":\n            target = window\n        elif id == \"document\":\n            target = document\n        else:\n            target = document.getElementById(id)\n\n        # Bind the event listener\n        try:\n            print(target, )\n            if  asyncio.iscoroutine(maybe_awaitable) and  asyncio.iscoroutinefunction(maybe_awaitable):\n                target.addEventListener(event, create_proxy(lambda e: self.dispatch(maybe_awaitable, e)))\n            else:\n                target.addEventListener(event, create_proxy(lambda e: maybe_awaitable(e)))\n        except Exception as e:\n            print(f\"WARNING:  ignoring to bind in build '{maybe_awaitable.__name__}' to '{event}' on target '{id}'\")\n</code></pre>"},{"location":"api/client/dispatcher/#zenaura.client.dispatcher.AsyncDispatcher.bind","title":"<code>bind(id, event, maybe_awaitable)</code>","text":"<p>Subscribe an event to an element, window, or document and dispatch a sync or async callback. Ensures the provided function has the correct signature.</p> <p>:param id: ID attached to the component, or 'window'/'document' for global bindings. :param event: Event name (e.g., \"click\", \"resize\", \"keydown\"). :param coroutine: Callback coroutine function. :return: None if binding succeeds; raises an exception otherwise.</p> Source code in <code>zenaura/client/dispatcher.py</code> <pre><code>def bind(self, id, event, maybe_awaitable):\n    \"\"\"\n    Subscribe an event to an element, window, or document and dispatch a sync or async callback.\n    Ensures the provided function has the correct signature.\n\n    :param id: ID attached to the component, or 'window'/'document' for global bindings.\n    :param event: Event name (e.g., \"click\", \"resize\", \"keydown\").\n    :param coroutine: Callback coroutine function.\n    :return: None if binding succeeds; raises an exception otherwise.\n    \"\"\"\n\n    if not callable(maybe_awaitable):\n        raise TypeError(\"The callback must be callable.\")\n\n    target = None\n\n    # Determine the target based on id\n    if id == \"window\":\n        target = window\n    elif id == \"document\":\n        target = document\n    else:\n        target = document.getElementById(id)\n\n    # Bind the event listener\n    try:\n        print(target, )\n        if  asyncio.iscoroutine(maybe_awaitable) and  asyncio.iscoroutinefunction(maybe_awaitable):\n            target.addEventListener(event, create_proxy(lambda e: self.dispatch(maybe_awaitable, e)))\n        else:\n            target.addEventListener(event, create_proxy(lambda e: maybe_awaitable(e)))\n    except Exception as e:\n        print(f\"WARNING:  ignoring to bind in build '{maybe_awaitable.__name__}' to '{event}' on target '{id}'\")\n</code></pre>"},{"location":"api/client/dispatcher/#zenaura.client.dispatcher.AsyncDispatcher.dispatch","title":"<code>dispatch(coro_func, *args, **kwargs)</code>","text":"<p>Wrap asyncio.run to schedule and run the given coroutine.</p> <p>:param coro_func: The coroutine function to execute. :param args: Positional arguments for the coroutine. :param kwargs: Keyword arguments for the coroutine.</p> Source code in <code>zenaura/client/dispatcher.py</code> <pre><code>def dispatch(self, coro_func, *args, **kwargs):\n    \"\"\"\n    Wrap asyncio.run to schedule and run the given coroutine.\n\n    :param coro_func: The coroutine function to execute.\n    :param args: Positional arguments for the coroutine.\n    :param kwargs: Keyword arguments for the coroutine.\n    \"\"\"\n    if in_browser:\n        asyncio.get_running_loop().run_until_complete(coro_func(*args, **kwargs))\n</code></pre>"},{"location":"api/client/page/","title":"page","text":""},{"location":"api/client/page/#zenaura.client.page.Page","title":"<code>Page</code>","text":"<p>Represents a page in a Zenaura application.</p> <p>A Page is a container for components that are displayed together. It manages the lifecycle of its child components and handles rendering them to the DOM.</p> <p>Attributes:</p> Name Type Description <code>count</code> <code>int</code> <p>A unique identifier for the page.</p> <code>id</code> <code>str</code> <p>A unique UUID for the page.</p> <code>children</code> <code>List[Component]</code> <p>The list of components that belong to this page.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>children</code> is not a list or if any child is not a <code>Component</code>.</p> Source code in <code>zenaura/client/page.py</code> <pre><code>class Page:\n    \"\"\"\n    Represents a page in a Zenaura application.\n\n    A Page is a container for components that are displayed together. It manages the\n    lifecycle of its child components and handles rendering them to the DOM.\n\n    Attributes:\n        count (int): A unique identifier for the page.\n        id (str): A unique UUID for the page.\n        children (List[Component]): The list of components that belong to this page.\n\n    Raises:\n        TypeError: If `children` is not a list or if any child is not a `Component`.\n    \"\"\"\n\n    _page_count = itertools.count(0)\n\n    def __init__(self, children: List[Component], attributes: Dict = None):\n        \"\"\"\n        Initializes a new Page instance.\n\n        Args:\n            children (List[Component]): The list of components to be added to the page.\n            attributes Dict : list of attributes for the page wrapper div\n        \"\"\"\n\n        self.count = next(self._page_count)\n        self.id = UUIDManager.generate_uuid(self.__class__.__name__, self.count)\n        self.children = children\n        self.attributes ={} if not attributes else attributes\n\n        if not isinstance(self.children, list):\n            raise TypeError(\"children must be a list\")\n\n        for child in self.children:\n            if not isinstance(child, Component):\n                raise TypeError(\"page children must be a Component\")\n</code></pre>"},{"location":"api/client/page/#zenaura.client.page.Page.__init__","title":"<code>__init__(children, attributes=None)</code>","text":"<p>Initializes a new Page instance.</p> <p>Parameters:</p> Name Type Description Default <code>children</code> <code>List[Component]</code> <p>The list of components to be added to the page.</p> required <code>attributes</code> <code>Dict</code> <p>list of attributes for the page wrapper div</p> <code>None</code> Source code in <code>zenaura/client/page.py</code> <pre><code>def __init__(self, children: List[Component], attributes: Dict = None):\n    \"\"\"\n    Initializes a new Page instance.\n\n    Args:\n        children (List[Component]): The list of components to be added to the page.\n        attributes Dict : list of attributes for the page wrapper div\n    \"\"\"\n\n    self.count = next(self._page_count)\n    self.id = UUIDManager.generate_uuid(self.__class__.__name__, self.count)\n    self.children = children\n    self.attributes ={} if not attributes else attributes\n\n    if not isinstance(self.children, list):\n        raise TypeError(\"children must be a list\")\n\n    for child in self.children:\n        if not isinstance(child, Component):\n            raise TypeError(\"page children must be a Component\")\n</code></pre>"},{"location":"api/client/algorithm/operations/","title":"Operations","text":""},{"location":"api/client/algorithm/operations/#zenaura.client.algorithm.operations.ADD_ATTRIBUTE","title":"<code>ADD_ATTRIBUTE = 'ADD_ATTRIBUTE'</code>  <code>module-attribute</code>","text":"<p>{     name : \"ADD_ATTRIBUTE\",     context: {         \"attr_name\" : \"attr-name\",         \"attr_value\" : \"attr-value\",     } }</p>"},{"location":"api/client/algorithm/operations/#zenaura.client.algorithm.operations.ADD_NODE","title":"<code>ADD_NODE = 'ADD_NODE'</code>  <code>module-attribute</code>","text":"<p>{     name : \"ADD_NODE\",     context: {         \"children\" : child-node,     } }</p>"},{"location":"api/client/algorithm/operations/#zenaura.client.algorithm.operations.NODE_INNER_TEXT","title":"<code>NODE_INNER_TEXT = 'NODE_INNER_TEXT'</code>  <code>module-attribute</code>","text":"<p>{     name : \"NODE_INNER_TEXT\",     context: {         \"text\" : \"sanitized-text\",     } }</p>"},{"location":"api/client/algorithm/operations/#zenaura.client.algorithm.operations.REMOVE_ATTRIBUTE","title":"<code>REMOVE_ATTRIBUTE = 'REMOVE_ATTRIBUTE'</code>  <code>module-attribute</code>","text":"<p>{     name : \"REMOVE_ATTRIBUTE\",     context: {         \"attr_name\" : \"attr-name\",     } }</p>"},{"location":"api/client/algorithm/operations/#zenaura.client.algorithm.operations.REMOVE_NODE","title":"<code>REMOVE_NODE = 'REMOVE_NODE'</code>  <code>module-attribute</code>","text":"<p>{     name : \"REMOVE_NODE\",     context: {         \"children\" : child-node,     } }</p>"},{"location":"api/client/algorithm/operations/#zenaura.client.algorithm.operations.REPLACE_ATTRIBUTE","title":"<code>REPLACE_ATTRIBUTE = 'REPLACE_ATTRIBUTE'</code>  <code>module-attribute</code>","text":"<p>{     name : \"REPLACE_ATTRIBUTE\",     context: {         \"attr_name\" : \"attr-name\",         \"attr_value\" : \"attr-value\",     } }</p>"},{"location":"api/client/algorithm/overview/","title":"Overview","text":""},{"location":"api/client/algorithm/overview/#zenaura.client.algorithm.algorithm.DiffingAlgorithm","title":"<code>DiffingAlgorithm</code>","text":"<p>               Bases: <code>Searcher</code>, <code>Updater</code></p> <p>The diffing algorithm in Zenaura virtual DOM.</p> <p>This class is responsible for comparing the old and new virtual DOM trees and generating a list of changes that need to be applied to the real DOM.</p> <p>The diffing algorithm is implemented in two steps:</p> <ol> <li>Search: The <code>Searcher</code> class traverses the old and new virtual DOM trees and identifies the nodes that have changed.</li> <li>Update: The <code>Updater</code> class applies the changes to the real DOM.</li> </ol> <p>The diffing algorithm is designed to be efficient and performant. It uses a number of techniques to minimize the number of changes that need to be applied to the real DOM.</p> <p>Attributes:</p> <ul> <li><code>Searcher</code>: An instance of the <code>Searcher</code> class.</li> <li><code>Updater</code>: An instance of the <code>Updater</code> class.</li> </ul> <p>Methods:</p> <ul> <li><code>diff(old_tree, new_tree)</code>: Compares the old and new virtual DOM trees and generates a list of changes that need to be applied to the real DOM.</li> </ul> <p>Example:</p> <pre><code># Create an instance of the DiffingAlgorithm class.\ndiffing_algorithm = DiffingAlgorithm()\n\n# Compare the old and new virtual DOM trees.\nchanges = diffing_algorithm.diff(old_tree, new_tree)\n\n# Apply the changes to the real DOM.\ndiffing_algorithm.update(changes)\n</code></pre> Source code in <code>zenaura/client/algorithm/algorithm.py</code> <pre><code>class DiffingAlgorithm(\n    Searcher,\n    Updater\n):\n    \"\"\"\n        The diffing algorithm in Zenaura virtual DOM.\n\n        This class is responsible for comparing the old and new virtual DOM trees and generating a list of changes that need to be applied to the real DOM.\n\n        The diffing algorithm is implemented in two steps:\n\n        1. **Search:** The `Searcher` class traverses the old and new virtual DOM trees and identifies the nodes that have changed.\n        2. **Update:** The `Updater` class applies the changes to the real DOM.\n\n        The diffing algorithm is designed to be efficient and performant. It uses a number of techniques to minimize the number of changes that need to be applied to the real DOM.\n\n        **Attributes:**\n\n        * `Searcher`: An instance of the `Searcher` class.\n        * `Updater`: An instance of the `Updater` class.\n\n        **Methods:**\n\n        * `diff(old_tree, new_tree)`: Compares the old and new virtual DOM trees and generates a list of changes that need to be applied to the real DOM.\n\n        **Example:**\n\n        ```python\n        # Create an instance of the DiffingAlgorithm class.\n        diffing_algorithm = DiffingAlgorithm()\n\n        # Compare the old and new virtual DOM trees.\n        changes = diffing_algorithm.diff(old_tree, new_tree)\n\n        # Apply the changes to the real DOM.\n        diffing_algorithm.update(changes)\n        ```\n    \"\"\"\n</code></pre>"},{"location":"api/client/algorithm/searcher/","title":"Searcher","text":""},{"location":"api/client/algorithm/searcher/#zenaura.client.algorithm.searcher.Searcher","title":"<code>Searcher</code>","text":"<p>               Bases: <code>HydratorCompilerAdapter</code></p> <p>This class implements the searching step of the Zenaura virtual DOM algorithm.</p> <p>It takes two virtual DOM trees, the previous and the new one, and identifies the differences between them. These differences are then used to update the real DOM efficiently.</p> Source code in <code>zenaura/client/algorithm/searcher.py</code> <pre><code>class Searcher(\n    HydratorCompilerAdapter\n):\n    \"\"\"\n    This class implements the searching step of the Zenaura virtual DOM algorithm.\n\n    It takes two virtual DOM trees, the previous and the new one, and identifies the differences between them.\n    These differences are then used to update the real DOM efficiently.\n\n    Attributes:\n        None\n    \"\"\"\n\n    def updater_context_builder(self, name: str, context: dict) -&gt; dict:\n        \"\"\"\n        Builds the context for the updater.\n\n        This method takes the name of the operation and its context and returns a dictionary that will be used by the updater.\n\n        Args:\n            name: The name of the operation.\n            context: The context of the operation.\n\n        Returns:\n            A dictionary containing the name and context of the operation.\n        \"\"\"\n\n        return {\n            \"name\": name,\n            \"context\": context\n        }\n\n    def patches_builder(self, prev_child_node, new_child_node, id, child_id):\n        \"\"\"\n        Builds the patches for the updater.\n\n        This method takes the previous and new child nodes, the component ID, and the child ID, and returns a list of patches that will be used by the updater.\n\n        Args:\n            prev_child_node: The previous child node.\n            new_child_node: The new child node.\n            id: The ID of the component.\n            child_id: The ID of the child.\n\n        Returns:\n            A list of patches containing the operation name, the new child node, the child ID, and the context for the updater.\n        \"\"\"\n\n        return [\n            self.hyd_comp_get_keyed_uuid(\n                id=id,\n                child_id=child_id\n            ),\n            new_child_node,\n            child_id,\n            self.updater_context_builder(\n                name=REMOVE_NODE,\n                context={\"children\": prev_child_node}\n            )\n        ]\n\n    def search(self, prevNode: Node, newNode: Node, id: str) -&gt; List[List[any]]:\n        \"\"\"\n        Searches for the differences between the previous and new virtual DOM trees.\n\n        This method takes the previous and new virtual DOM trees and the component ID, and returns a list of lists of differences. Each difference is represented as a list containing the operation name, the new child node, the path of the child, and the context for the updater.\n\n        Args:\n            prevNode: The previous virtual DOM tree.\n            newNode: The new virtual DOM tree.\n            id: The ID of the component.\n\n        Returns:\n            A list of lists of differences.\n        \"\"\"\n\n        # Error handling:\n        if not prevNode and not newNode:\n            return []\n        if not isinstance(prevNode, Node) or not isinstance(newNode, Node):\n            return []\n\n        differences = []\n\n        def helper(prev_child_node: Node, new_child_node: Node, id, prev_child_path: str, new_child_path) -&gt; None:\n            \"\"\"\n            Helper method for the search method.\n\n            This method recursively compares the previous and new child nodes and their attributes and children, and adds the differences to the `differences` list.\n\n            Args:\n                prev_child_node: The previous child node.\n                new_child_node: The new child node.\n                id: The ID of the component.\n                prev_child_path: The path of the previous child node.\n                new_child_path: The path of the new child node.\n            \"\"\"\n\n            nonlocal differences\n\n            # Added node\n            if not prev_child_node and new_child_node:\n                differences.append([\n                    self.hyd_comp_get_keyed_uuid(\n                        id=id,\n                        key=prev_child_path\n                    ),\n                    new_child_node,\n                    prev_child_path,\n                    self.updater_context_builder(\n                        name=ADD_NODE,\n                        context={\"children\": new_child_node}\n                    )\n                ])\n                return\n\n            # Removed node\n            if prev_child_node and not new_child_node:\n                differences.append([\n                    self.hyd_comp_get_keyed_uuid(\n                        id=id,\n                        key=prev_child_path\n                    ),\n                    prev_child_node,\n                    prev_child_path,\n                    self.updater_context_builder(\n                        name=REMOVE_NODE,\n                        context={\"children\": prev_child_node}\n                    )\n                ])\n                return\n\n            # Changed child by name\n            if prev_child_node.name != new_child_node.name:\n                differences.append([\n                    self.hyd_comp_get_keyed_uuid(\n                        id=id,\n                        key=prev_child_path\n                    ),\n                    prev_child_node,\n                    prev_child_path,\n                    self.updater_context_builder(\n                        name=REMOVE_NODE,\n                        context={\"children\": prev_child_node}\n                    )\n                ])\n                differences.append([\n                    self.hyd_comp_get_keyed_uuid(\n                        id=id,\n                        key=new_child_path\n                    ),\n                    new_child_node,\n                    new_child_path,\n                    self.updater_context_builder(\n                        name=ADD_NODE,\n                        context={\"children\": new_child_node}\n                    )\n                ])\n                return\n\n            # Compare attributes\n            for [prev_attr, new_attr] in zip_longest(prev_child_node.attributes, new_child_node.attributes):\n\n                # Removed attribute\n                if prev_attr and not new_attr:\n                    differences.append([\n                        self.hyd_comp_get_keyed_uuid(\n                            id=id,\n                            key=prev_child_path\n                        ),\n                        new_child_node,\n                        prev_child_path,\n                        self.updater_context_builder(\n                            name=REMOVE_ATTRIBUTE,\n                            context={\"attr_name\": prev_attr.key}\n                        )\n                    ])\n                    continue\n\n                # Added attribute\n                if not prev_attr and new_attr:\n                    differences.append([\n                        self.hyd_comp_get_keyed_uuid(\n                            id=id,\n                            key=new_child_path\n                        ),\n                        new_child_node,\n                        new_child_path,\n                        self.updater_context_builder(\n                            name=ADD_ATTRIBUTE,\n                            context={\"attr_name\": new_attr.key, \"attr_value\": new_attr.value}\n                        )\n                    ])\n                    continue\n\n                # Replaced value attribute\n                if prev_attr and new_attr:\n                    if prev_attr.value != new_attr.value:\n                        differences.append([\n                            self.hyd_comp_get_keyed_uuid(\n                                id=id,\n                                key=prev_child_path\n                            ),\n                            new_child_node,\n                            prev_child_path,\n                            self.updater_context_builder(\n                                name=ADD_ATTRIBUTE,\n                                context={\"attr_name\": new_attr.key, \"attr_value\": new_attr.value}\n                            )\n                        ])\n\n            # Compare children\n            for idx, (prev_child, new_child) in enumerate(zip_longest(prev_child_node.children, new_child_node.children)):\n                # Leaf text nodes\n                if prev_child and new_child:\n                    if prev_child.is_text_node and new_child.is_text_node and (prev_child.text != new_child.text):\n                        differences.append([\n                            self.hyd_comp_get_keyed_uuid(\n                                id=id,\n                                key=prev_child_path\n                            ),\n                            new_child_node,\n                            prev_child_path,\n                            self.updater_context_builder(\n                                name=NODE_INNER_TEXT,\n                                context={\"text\": new_child.text}\n                            )\n                        ])\n                        continue\n\n                new_child_path = new_child.path if isinstance(new_child, Node) else \"\"\n                prev_child_path = prev_child.path if isinstance(prev_child, Node) else \"\"\n                helper(prev_child, new_child, id, prev_child_path=prev_child_path, new_child_path=new_child_path)\n\n        helper(prevNode, newNode, id, 0, 0)\n        return differences\n</code></pre>"},{"location":"api/client/algorithm/searcher/#zenaura.client.algorithm.searcher.Searcher.patches_builder","title":"<code>patches_builder(prev_child_node, new_child_node, id, child_id)</code>","text":"<p>Builds the patches for the updater.</p> <p>This method takes the previous and new child nodes, the component ID, and the child ID, and returns a list of patches that will be used by the updater.</p> <p>Parameters:</p> Name Type Description Default <code>prev_child_node</code> <p>The previous child node.</p> required <code>new_child_node</code> <p>The new child node.</p> required <code>id</code> <p>The ID of the component.</p> required <code>child_id</code> <p>The ID of the child.</p> required <p>Returns:</p> Type Description <p>A list of patches containing the operation name, the new child node, the child ID, and the context for the updater.</p> Source code in <code>zenaura/client/algorithm/searcher.py</code> <pre><code>def patches_builder(self, prev_child_node, new_child_node, id, child_id):\n    \"\"\"\n    Builds the patches for the updater.\n\n    This method takes the previous and new child nodes, the component ID, and the child ID, and returns a list of patches that will be used by the updater.\n\n    Args:\n        prev_child_node: The previous child node.\n        new_child_node: The new child node.\n        id: The ID of the component.\n        child_id: The ID of the child.\n\n    Returns:\n        A list of patches containing the operation name, the new child node, the child ID, and the context for the updater.\n    \"\"\"\n\n    return [\n        self.hyd_comp_get_keyed_uuid(\n            id=id,\n            child_id=child_id\n        ),\n        new_child_node,\n        child_id,\n        self.updater_context_builder(\n            name=REMOVE_NODE,\n            context={\"children\": prev_child_node}\n        )\n    ]\n</code></pre>"},{"location":"api/client/algorithm/searcher/#zenaura.client.algorithm.searcher.Searcher.search","title":"<code>search(prevNode, newNode, id)</code>","text":"<p>Searches for the differences between the previous and new virtual DOM trees.</p> <p>This method takes the previous and new virtual DOM trees and the component ID, and returns a list of lists of differences. Each difference is represented as a list containing the operation name, the new child node, the path of the child, and the context for the updater.</p> <p>Parameters:</p> Name Type Description Default <code>prevNode</code> <code>Node</code> <p>The previous virtual DOM tree.</p> required <code>newNode</code> <code>Node</code> <p>The new virtual DOM tree.</p> required <code>id</code> <code>str</code> <p>The ID of the component.</p> required <p>Returns:</p> Type Description <code>List[List[any]]</code> <p>A list of lists of differences.</p> Source code in <code>zenaura/client/algorithm/searcher.py</code> <pre><code>def search(self, prevNode: Node, newNode: Node, id: str) -&gt; List[List[any]]:\n    \"\"\"\n    Searches for the differences between the previous and new virtual DOM trees.\n\n    This method takes the previous and new virtual DOM trees and the component ID, and returns a list of lists of differences. Each difference is represented as a list containing the operation name, the new child node, the path of the child, and the context for the updater.\n\n    Args:\n        prevNode: The previous virtual DOM tree.\n        newNode: The new virtual DOM tree.\n        id: The ID of the component.\n\n    Returns:\n        A list of lists of differences.\n    \"\"\"\n\n    # Error handling:\n    if not prevNode and not newNode:\n        return []\n    if not isinstance(prevNode, Node) or not isinstance(newNode, Node):\n        return []\n\n    differences = []\n\n    def helper(prev_child_node: Node, new_child_node: Node, id, prev_child_path: str, new_child_path) -&gt; None:\n        \"\"\"\n        Helper method for the search method.\n\n        This method recursively compares the previous and new child nodes and their attributes and children, and adds the differences to the `differences` list.\n\n        Args:\n            prev_child_node: The previous child node.\n            new_child_node: The new child node.\n            id: The ID of the component.\n            prev_child_path: The path of the previous child node.\n            new_child_path: The path of the new child node.\n        \"\"\"\n\n        nonlocal differences\n\n        # Added node\n        if not prev_child_node and new_child_node:\n            differences.append([\n                self.hyd_comp_get_keyed_uuid(\n                    id=id,\n                    key=prev_child_path\n                ),\n                new_child_node,\n                prev_child_path,\n                self.updater_context_builder(\n                    name=ADD_NODE,\n                    context={\"children\": new_child_node}\n                )\n            ])\n            return\n\n        # Removed node\n        if prev_child_node and not new_child_node:\n            differences.append([\n                self.hyd_comp_get_keyed_uuid(\n                    id=id,\n                    key=prev_child_path\n                ),\n                prev_child_node,\n                prev_child_path,\n                self.updater_context_builder(\n                    name=REMOVE_NODE,\n                    context={\"children\": prev_child_node}\n                )\n            ])\n            return\n\n        # Changed child by name\n        if prev_child_node.name != new_child_node.name:\n            differences.append([\n                self.hyd_comp_get_keyed_uuid(\n                    id=id,\n                    key=prev_child_path\n                ),\n                prev_child_node,\n                prev_child_path,\n                self.updater_context_builder(\n                    name=REMOVE_NODE,\n                    context={\"children\": prev_child_node}\n                )\n            ])\n            differences.append([\n                self.hyd_comp_get_keyed_uuid(\n                    id=id,\n                    key=new_child_path\n                ),\n                new_child_node,\n                new_child_path,\n                self.updater_context_builder(\n                    name=ADD_NODE,\n                    context={\"children\": new_child_node}\n                )\n            ])\n            return\n\n        # Compare attributes\n        for [prev_attr, new_attr] in zip_longest(prev_child_node.attributes, new_child_node.attributes):\n\n            # Removed attribute\n            if prev_attr and not new_attr:\n                differences.append([\n                    self.hyd_comp_get_keyed_uuid(\n                        id=id,\n                        key=prev_child_path\n                    ),\n                    new_child_node,\n                    prev_child_path,\n                    self.updater_context_builder(\n                        name=REMOVE_ATTRIBUTE,\n                        context={\"attr_name\": prev_attr.key}\n                    )\n                ])\n                continue\n\n            # Added attribute\n            if not prev_attr and new_attr:\n                differences.append([\n                    self.hyd_comp_get_keyed_uuid(\n                        id=id,\n                        key=new_child_path\n                    ),\n                    new_child_node,\n                    new_child_path,\n                    self.updater_context_builder(\n                        name=ADD_ATTRIBUTE,\n                        context={\"attr_name\": new_attr.key, \"attr_value\": new_attr.value}\n                    )\n                ])\n                continue\n\n            # Replaced value attribute\n            if prev_attr and new_attr:\n                if prev_attr.value != new_attr.value:\n                    differences.append([\n                        self.hyd_comp_get_keyed_uuid(\n                            id=id,\n                            key=prev_child_path\n                        ),\n                        new_child_node,\n                        prev_child_path,\n                        self.updater_context_builder(\n                            name=ADD_ATTRIBUTE,\n                            context={\"attr_name\": new_attr.key, \"attr_value\": new_attr.value}\n                        )\n                    ])\n\n        # Compare children\n        for idx, (prev_child, new_child) in enumerate(zip_longest(prev_child_node.children, new_child_node.children)):\n            # Leaf text nodes\n            if prev_child and new_child:\n                if prev_child.is_text_node and new_child.is_text_node and (prev_child.text != new_child.text):\n                    differences.append([\n                        self.hyd_comp_get_keyed_uuid(\n                            id=id,\n                            key=prev_child_path\n                        ),\n                        new_child_node,\n                        prev_child_path,\n                        self.updater_context_builder(\n                            name=NODE_INNER_TEXT,\n                            context={\"text\": new_child.text}\n                        )\n                    ])\n                    continue\n\n            new_child_path = new_child.path if isinstance(new_child, Node) else \"\"\n            prev_child_path = prev_child.path if isinstance(prev_child, Node) else \"\"\n            helper(prev_child, new_child, id, prev_child_path=prev_child_path, new_child_path=new_child_path)\n\n    helper(prevNode, newNode, id, 0, 0)\n    return differences\n</code></pre>"},{"location":"api/client/algorithm/searcher/#zenaura.client.algorithm.searcher.Searcher.updater_context_builder","title":"<code>updater_context_builder(name, context)</code>","text":"<p>Builds the context for the updater.</p> <p>This method takes the name of the operation and its context and returns a dictionary that will be used by the updater.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the operation.</p> required <code>context</code> <code>dict</code> <p>The context of the operation.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the name and context of the operation.</p> Source code in <code>zenaura/client/algorithm/searcher.py</code> <pre><code>def updater_context_builder(self, name: str, context: dict) -&gt; dict:\n    \"\"\"\n    Builds the context for the updater.\n\n    This method takes the name of the operation and its context and returns a dictionary that will be used by the updater.\n\n    Args:\n        name: The name of the operation.\n        context: The context of the operation.\n\n    Returns:\n        A dictionary containing the name and context of the operation.\n    \"\"\"\n\n    return {\n        \"name\": name,\n        \"context\": context\n    }\n</code></pre>"},{"location":"api/client/algorithm/updater/","title":"Updater","text":""},{"location":"api/client/algorithm/updater/#zenaura.client.algorithm.updater.Updater","title":"<code>Updater</code>","text":"<p>               Bases: <code>Hydrator</code></p> <p>This class is responsible for updating the real DOM based on the differences identified by the Searcher.</p> <p>It receives a list of patches from the Searcher and creates corresponding tasks for each patch. These tasks are then enqueued for execution by the Hydrator's tasker.</p> Source code in <code>zenaura/client/algorithm/updater.py</code> <pre><code>class Updater(\n    Hydrator\n    ):\n    \"\"\"\n    This class is responsible for updating the real DOM based on the differences identified by the Searcher.\n\n    It receives a list of patches from the Searcher and creates corresponding tasks for each patch. These tasks are then enqueued for execution by the Hydrator's tasker.\n\n    Attributes:\n        None\n    \"\"\"\n\n    async def update(self, patches: List, id: str) -&gt; None:\n        \"\"\"\n        Updates the real DOM based on the provided patches.\n\n        Args:\n            patches: A list of patches containing the operation name, the new child node, the path of the child, and the context for the updater.\n            id: The ID of the component to be updated.\n        \"\"\"\n\n        while patches:\n            prev_node_id, diffed_node, path, op = patches.pop(0)\n            # print(\"operation\", op, prev_node_id)\n\n            if op[\"name\"] == ADD_NODE:\n                async def task(dn=diffed_node, ci=id):\n                    \"\"\"\n                    Adds a new node to the real DOM.\n\n                    Args:\n                        dn: The new child node to be added.\n                        ci: The ID of the component to which the node should be added.\n                    \"\"\"\n                    compiled_html = self.hyd_comp_compile_children(dn, ci, True)\n                    parent_id = id + dn.path[0:-2]  # last two digit in keyed uid is always level, index, so parent lives at the before\n                    child_id = id + dn.path\n                    self.hyd_rdom_append_child_after(parent_id, child_id, compiled_html)\n                self.hyd_tsk_enqueue_task(id, task)\n\n            if op[\"name\"] == REMOVE_NODE:\n                async def task(d=diffed_node, c=prev_node_id):\n                    \"\"\"\n                    Removes a node from the real DOM.\n\n                    Args:\n                        d: The node to be removed.\n                        c: The ID of the component containing the node.\n                    \"\"\"\n                    compiled_html = self.hyd_comp_compile_children(d, c, True)\n                    # print(\"ADD_NODE compiled html\", compiled_html)\n                    self.hyd_rdom_remove_child(prev_node_id)\n                self.hyd_tsk_enqueue_task(id, task)\n\n            if op[\"name\"] == NODE_INNER_TEXT:\n                # avoid late binding\n                async def task(id=prev_node_id, c=op[\"context\"][\"text\"]):\n                    \"\"\"\n                    Updates the inner text of a node in the real DOM.\n\n                    Args:\n                        id: The ID of the node to be updated.\n                        c: The new inner text.\n                    \"\"\"\n                    self.hyd_rdom_replace_inner_text(id, c)\n                self.hyd_tsk_enqueue_task(id, task)\n\n            if op[\"name\"] == ADD_ATTRIBUTE:\n                async def task(id=prev_node_id, op1=Attribute(op[\"context\"][\"attr_name\"], op[\"context\"][\"attr_value\"])):\n                    \"\"\"\n                    Adds an attribute to a node in the real DOM.\n\n                    Args:\n                        id: The ID of the node to be updated.\n                        op1: The attribute to be added.\n                    \"\"\"\n                    self.hyd_rdom_set_attribute(id, op1)\n                self.hyd_tsk_enqueue_task(id, task)\n\n            if op[\"name\"] == REMOVE_ATTRIBUTE:\n                async def task(id=prev_node_id, op1=op[\"context\"][\"attr_name\"]):\n                    \"\"\"\n                    Removes an attribute from a node in the real DOM.\n\n                    Args:\n                        id: The ID of the node to be updated.\n                        op1: The name of the attribute to be removed.\n                    \"\"\"\n                    self.hyd_rdom_remove_attribute(id, op1)\n                self.hyd_tsk_enqueue_task(id, task)\n\n            if op[\"name\"] == REPLACE_ATTRIBUTE:\n                async def task(id=prev_node_id, op1=op[\"context\"][\"attr_name\"]):\n                    \"\"\"\n                    Replaces an attribute on a node in the real DOM.\n\n                    Args:\n                        id: The ID of the node to be updated.\n                        op1: The name of the attribute to be replaced.\n                    \"\"\"\n                    self.hyd_rdom_remove_attribute(id, op1)\n                self.hyd_tsk_enqueue_task(id, task)\n</code></pre>"},{"location":"api/client/algorithm/updater/#zenaura.client.algorithm.updater.Updater.update","title":"<code>update(patches, id)</code>  <code>async</code>","text":"<p>Updates the real DOM based on the provided patches.</p> <p>Parameters:</p> Name Type Description Default <code>patches</code> <code>List</code> <p>A list of patches containing the operation name, the new child node, the path of the child, and the context for the updater.</p> required <code>id</code> <code>str</code> <p>The ID of the component to be updated.</p> required Source code in <code>zenaura/client/algorithm/updater.py</code> <pre><code>async def update(self, patches: List, id: str) -&gt; None:\n    \"\"\"\n    Updates the real DOM based on the provided patches.\n\n    Args:\n        patches: A list of patches containing the operation name, the new child node, the path of the child, and the context for the updater.\n        id: The ID of the component to be updated.\n    \"\"\"\n\n    while patches:\n        prev_node_id, diffed_node, path, op = patches.pop(0)\n        # print(\"operation\", op, prev_node_id)\n\n        if op[\"name\"] == ADD_NODE:\n            async def task(dn=diffed_node, ci=id):\n                \"\"\"\n                Adds a new node to the real DOM.\n\n                Args:\n                    dn: The new child node to be added.\n                    ci: The ID of the component to which the node should be added.\n                \"\"\"\n                compiled_html = self.hyd_comp_compile_children(dn, ci, True)\n                parent_id = id + dn.path[0:-2]  # last two digit in keyed uid is always level, index, so parent lives at the before\n                child_id = id + dn.path\n                self.hyd_rdom_append_child_after(parent_id, child_id, compiled_html)\n            self.hyd_tsk_enqueue_task(id, task)\n\n        if op[\"name\"] == REMOVE_NODE:\n            async def task(d=diffed_node, c=prev_node_id):\n                \"\"\"\n                Removes a node from the real DOM.\n\n                Args:\n                    d: The node to be removed.\n                    c: The ID of the component containing the node.\n                \"\"\"\n                compiled_html = self.hyd_comp_compile_children(d, c, True)\n                # print(\"ADD_NODE compiled html\", compiled_html)\n                self.hyd_rdom_remove_child(prev_node_id)\n            self.hyd_tsk_enqueue_task(id, task)\n\n        if op[\"name\"] == NODE_INNER_TEXT:\n            # avoid late binding\n            async def task(id=prev_node_id, c=op[\"context\"][\"text\"]):\n                \"\"\"\n                Updates the inner text of a node in the real DOM.\n\n                Args:\n                    id: The ID of the node to be updated.\n                    c: The new inner text.\n                \"\"\"\n                self.hyd_rdom_replace_inner_text(id, c)\n            self.hyd_tsk_enqueue_task(id, task)\n\n        if op[\"name\"] == ADD_ATTRIBUTE:\n            async def task(id=prev_node_id, op1=Attribute(op[\"context\"][\"attr_name\"], op[\"context\"][\"attr_value\"])):\n                \"\"\"\n                Adds an attribute to a node in the real DOM.\n\n                Args:\n                    id: The ID of the node to be updated.\n                    op1: The attribute to be added.\n                \"\"\"\n                self.hyd_rdom_set_attribute(id, op1)\n            self.hyd_tsk_enqueue_task(id, task)\n\n        if op[\"name\"] == REMOVE_ATTRIBUTE:\n            async def task(id=prev_node_id, op1=op[\"context\"][\"attr_name\"]):\n                \"\"\"\n                Removes an attribute from a node in the real DOM.\n\n                Args:\n                    id: The ID of the node to be updated.\n                    op1: The name of the attribute to be removed.\n                \"\"\"\n                self.hyd_rdom_remove_attribute(id, op1)\n            self.hyd_tsk_enqueue_task(id, task)\n\n        if op[\"name\"] == REPLACE_ATTRIBUTE:\n            async def task(id=prev_node_id, op1=op[\"context\"][\"attr_name\"]):\n                \"\"\"\n                Replaces an attribute on a node in the real DOM.\n\n                Args:\n                    id: The ID of the node to be updated.\n                    op1: The name of the attribute to be replaced.\n                \"\"\"\n                self.hyd_rdom_remove_attribute(id, op1)\n            self.hyd_tsk_enqueue_task(id, task)\n</code></pre>"},{"location":"api/client/compiler/attribute/","title":"Attribute","text":""},{"location":"api/client/compiler/attribute/#zenaura.client.compiler.attribute.AttributeProccessor","title":"<code>AttributeProccessor</code>","text":"<p>Processes a list of <code>Attribute</code> objects and converts them into HTML-formatted attributes.</p> <p>Attributes:</p> Name Type Description <code>attrKeyWords</code> <code>dict</code> <p>Maps Python keywords to HTML attribute names. - \"styles\": Translates to \"class\". - \"class_\": Translates to \"class\" (avoids conflict with Python's <code>class</code> keyword). - \"for_\": Translates to \"for\". - \"name_\": Translates to \"name\". - \"type_\": Translates to \"type\".</p> <code>attrValueWords</code> <code>dict</code> <p>Maps Python boolean values to HTML-compliant strings. - \"True\": Translates to \"true\". - \"False\": Translates to \"false\".</p> Source code in <code>zenaura/client/compiler/attribute.py</code> <pre><code>class AttributeProccessor():\n    \"\"\"\n        Processes a list of `Attribute` objects and converts them into HTML-formatted attributes.\n\n        Attributes:\n            attrKeyWords (dict): Maps Python keywords to HTML attribute names.\n                - \"styles\": Translates to \"class\".\n                - \"class_\": Translates to \"class\" (avoids conflict with Python's `class` keyword).\n                - \"for_\": Translates to \"for\".\n                - \"name_\": Translates to \"name\".\n                - \"type_\": Translates to \"type\".\n\n            attrValueWords (dict): Maps Python boolean values to HTML-compliant strings.\n                - \"True\": Translates to \"true\".\n                - \"False\": Translates to \"false\".\n\n        Methods:\n            None\n    \"\"\"\n    def __init__(self):\n        self.attrKeyWords = {\n            \"styles\": \"class\",\n            \"class_\": \"class\",\n            \"for_\": \"for\",\n            \"name_\": \"name\",\n            \"type_\": \"type\"\n        }\n        self.attrValueWords = {\n            \"True\": \"true\",\n            \"False\": \"false\"\n        }\n    def process_attributes(\n                self, \n                attrs: List[Attribute]\n                ) -&gt; str:\n        \"\"\"\n        Processes a list of `Attribute` objects, converting them to HTML-formatted attributes.\n\n        Args:\n            attrs (List[Attribute]): A list of `Attribute` objects representing the attributes to be processed.\n\n        Returns:\n            str: A string containing the HTML-formatted attributes, ready to be included in a tag.\n\n        Raises:\n            TypeError: If the input `attrs` is not a list.\n            ValueError: If any element in `attrs` is not an `Attribute` object.\n        \"\"\"\n\n        if not isinstance(attrs, list):\n            raise TypeError(\"`attrs` must be a list of Attribute objects.\")\n\n        for attr in attrs:\n            if not isinstance(attr, Attribute):\n                raise ValueError(\"Each element in `attrs` must be an Attribute object.\")\n\n        s = io.StringIO()  # Create a string buffer for building the output\n\n        for i, attr in enumerate(attrs):\n            attrKey = attr.key\n            attrValue = attr.value\n            if attrKey in self.attrKeyWords.keys():\n                attrKey = self.attrKeyWords[attrKey]  # Apply keyword mapping\n            if str(attrValue) in self.attrValueWords.keys():\n                attrValue = self.attrValueWords[str(attrValue)]\n\n            # Add space only if it's not the first or last attribute\n            if i == 0 or i == len(attrs) - 1:\n                s.write(f' {attrKey}=\"{sanitizer.sanitize(attrValue)}\"')\n            else:\n                s.write(f'{attrKey}=\"{sanitizer.sanitize(attrValue)}\" ')\n\n        res = s.getvalue()\n        s.close()\n        return res\n</code></pre>"},{"location":"api/client/compiler/attribute/#zenaura.client.compiler.attribute.AttributeProccessor.process_attributes","title":"<code>process_attributes(attrs)</code>","text":"<p>Processes a list of <code>Attribute</code> objects, converting them to HTML-formatted attributes.</p> <p>Parameters:</p> Name Type Description Default <code>attrs</code> <code>List[Attribute]</code> <p>A list of <code>Attribute</code> objects representing the attributes to be processed.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string containing the HTML-formatted attributes, ready to be included in a tag.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the input <code>attrs</code> is not a list.</p> <code>ValueError</code> <p>If any element in <code>attrs</code> is not an <code>Attribute</code> object.</p> Source code in <code>zenaura/client/compiler/attribute.py</code> <pre><code>def process_attributes(\n            self, \n            attrs: List[Attribute]\n            ) -&gt; str:\n    \"\"\"\n    Processes a list of `Attribute` objects, converting them to HTML-formatted attributes.\n\n    Args:\n        attrs (List[Attribute]): A list of `Attribute` objects representing the attributes to be processed.\n\n    Returns:\n        str: A string containing the HTML-formatted attributes, ready to be included in a tag.\n\n    Raises:\n        TypeError: If the input `attrs` is not a list.\n        ValueError: If any element in `attrs` is not an `Attribute` object.\n    \"\"\"\n\n    if not isinstance(attrs, list):\n        raise TypeError(\"`attrs` must be a list of Attribute objects.\")\n\n    for attr in attrs:\n        if not isinstance(attr, Attribute):\n            raise ValueError(\"Each element in `attrs` must be an Attribute object.\")\n\n    s = io.StringIO()  # Create a string buffer for building the output\n\n    for i, attr in enumerate(attrs):\n        attrKey = attr.key\n        attrValue = attr.value\n        if attrKey in self.attrKeyWords.keys():\n            attrKey = self.attrKeyWords[attrKey]  # Apply keyword mapping\n        if str(attrValue) in self.attrValueWords.keys():\n            attrValue = self.attrValueWords[str(attrValue)]\n\n        # Add space only if it's not the first or last attribute\n        if i == 0 or i == len(attrs) - 1:\n            s.write(f' {attrKey}=\"{sanitizer.sanitize(attrValue)}\"')\n        else:\n            s.write(f'{attrKey}=\"{sanitizer.sanitize(attrValue)}\" ')\n\n    res = s.getvalue()\n    s.close()\n    return res\n</code></pre>"},{"location":"api/client/compiler/compiler/","title":"Compiler","text":""},{"location":"api/client/compiler/compiler/#zenaura.client.compiler.compiler.Compiler","title":"<code>Compiler</code>","text":"<p>               Bases: <code>CompilerSanitizer</code>, <code>AttributeProccessor</code></p> <p>Compiles Zenui Nodes into their corresponding HTML representation.</p> <p>This class provides methods for:</p> <ul> <li>Generating unique keyed UUIDs for each child within a component tree.</li> <li>Compiling Zenui Nodes into HTML strings.</li> <li>Sanitizing HTML content to prevent XSS vulnerabilities.</li> <li>Processing attributes for HTML elements.</li> </ul> <p>Attributes:</p> Name Type Description <code>attrKeyWords</code> <code>dict</code> <p>A dictionary mapping attribute keywords to their corresponding HTML attribute names.</p> Source code in <code>zenaura/client/compiler/compiler.py</code> <pre><code>class Compiler(\n    CompilerSanitizer,\n    AttributeProccessor,\n):\n    \"\"\"\n    Compiles Zenui Nodes into their corresponding HTML representation.\n\n    This class provides methods for:\n\n    - Generating unique keyed UUIDs for each child within a component tree.\n    - Compiling Zenui Nodes into HTML strings.\n    - Sanitizing HTML content to prevent XSS vulnerabilities.\n    - Processing attributes for HTML elements.\n\n    Attributes:\n        attrKeyWords (dict): A dictionary mapping attribute keywords to their corresponding HTML attribute names.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the Compiler instance with sanitizer and attribute processor\n\n        \"\"\"\n        AttributeProccessor.__init__(self)\n        self.special_tags = {\n            \"input_\": \"input\"\n        }\n\n    def getKeyedUID(self, id, withAttribut=False, key=None):\n        \"\"\"\n        Generates a unique keyed UUID for a child element within a component tree.\n\n        This UUID is used to create a unique `ZENAURA_DOM_ATTRIBUTE` attribute for the element.\n\n        Args:\n            id (str): The unique ID of the parent component.\n            withAttribut (bool, optional): Whether to include the `ZENAURA_DOM_ATTRIBUTE` attribute. Defaults to False.\n            key (str or list, optional): The key or path of the child element. Defaults to None.\n\n        Returns:\n            str: The generated keyed UUID.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; compiler = Compiler()\n            &gt;&gt;&gt; compiler.getKeyedUID(\"my-component\", key=\"child1\")\n            'my-componentchild1'\n            &gt;&gt;&gt; compiler.getKeyedUID(\"my-component\", withAttribut=True, key=[0, 1])\n            ' ZENAURA_DOM_ATTRIBUTE=\"my-component01\"'\n            ```\n        \"\"\"\n        if isinstance(key, list):\n            key = \"\".join(str(i) for i in key)  # Convert list to string\n\n        if withAttribut:\n            return f' {ZENAURA_DOM_ATTRIBUTE}=\"{id}{key}\"'\n        return f\"{id}{key}\"\n\n    def compile(self, elm: Node, id=None, zenaura_dom_mode=False):\n        \"\"\"\n        Compiles a Zenui Node into its corresponding HTML representation.\n\n        Args:\n            elm (Node): The Zenui Node object to compile.\n            id (str, optional): The unique ID of the parent component. Used to generate keyed UUIDs.\n            zenaura_dom_mode (bool, optional): Whether to add the `ZENAURA_DOM_ATTRIBUTE` attribute to the compiled HTML. Defaults to False.\n\n        Returns:\n            str: The compiled HTML string.\n\n        Examples:\n            ```python\n            &gt;&gt;&gt; compiler = Compiler()\n            &gt;&gt;&gt; node = Node(\"div\", attributes=[Attribute(\"class\", \"my-class\")], children=[Node(\"p\", text=\"Hello, world!\")])\n            &gt;&gt;&gt; compiler.compile(node)\n            '&lt;div class=\"my-class\"&gt;&lt;p&gt;Hello, world!&lt;/p&gt;&lt;/div&gt;'\n            &gt;&gt;&gt; compiler.compile(node, zenaura_dom_mode=True)\n            '&lt;div class=\"my-class\" ZENAURA_DOM_ATTRIBUTE=\"div0\"&gt; &lt;p ZENAURA_DOM_ATTRIBUTE=\"div00\"&gt;Hello, world!&lt;/p&gt;&lt;/div&gt;'\n            ```\n        \"\"\"\n        if elm.is_text_node or isinstance(elm, str):\n            return self.sanitize(elm.text)\n\n        tag = elm.name\n\n        zenui_id = \"\"\n\n        # Assign unique ID for Zenui DOM\n        if isinstance(elm, Node) and zenaura_dom_mode:\n            zenui_id = self.getKeyedUID(id, withAttribut=True, key=elm.path)\n\n        # Get node attributes\n        attributes = self.process_attributes(elm.attributes)\n\n        if tag in self.special_tags.keys():\n            tag = self.special_tags[tag]\n\n        if tag in self_closing_tags:\n            return f\"&lt;{tag}{zenui_id}{attributes} /&gt;\"\n\n        # Start tag\n        html = io.StringIO()\n        html.write(f\"&lt;{tag}{zenui_id}{attributes}&gt;\")\n\n        # Get children\n        for child in elm.children:\n            html.write(self.compile(child, id, zenaura_dom_mode))\n\n        # Finish tag\n        html.write(f\"&lt;/{tag}&gt;\")\n\n        return html.getvalue()\n</code></pre>"},{"location":"api/client/compiler/compiler/#zenaura.client.compiler.compiler.Compiler.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the Compiler instance with sanitizer and attribute processor</p> Source code in <code>zenaura/client/compiler/compiler.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the Compiler instance with sanitizer and attribute processor\n\n    \"\"\"\n    AttributeProccessor.__init__(self)\n    self.special_tags = {\n        \"input_\": \"input\"\n    }\n</code></pre>"},{"location":"api/client/compiler/compiler/#zenaura.client.compiler.compiler.Compiler.compile","title":"<code>compile(elm, id=None, zenaura_dom_mode=False)</code>","text":"<p>Compiles a Zenui Node into its corresponding HTML representation.</p> <p>Parameters:</p> Name Type Description Default <code>elm</code> <code>Node</code> <p>The Zenui Node object to compile.</p> required <code>id</code> <code>str</code> <p>The unique ID of the parent component. Used to generate keyed UUIDs.</p> <code>None</code> <code>zenaura_dom_mode</code> <code>bool</code> <p>Whether to add the <code>ZENAURA_DOM_ATTRIBUTE</code> attribute to the compiled HTML. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <p>The compiled HTML string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; compiler = Compiler()\n&gt;&gt;&gt; node = Node(\"div\", attributes=[Attribute(\"class\", \"my-class\")], children=[Node(\"p\", text=\"Hello, world!\")])\n&gt;&gt;&gt; compiler.compile(node)\n'&lt;div class=\"my-class\"&gt;&lt;p&gt;Hello, world!&lt;/p&gt;&lt;/div&gt;'\n&gt;&gt;&gt; compiler.compile(node, zenaura_dom_mode=True)\n'&lt;div class=\"my-class\" ZENAURA_DOM_ATTRIBUTE=\"div0\"&gt; &lt;p ZENAURA_DOM_ATTRIBUTE=\"div00\"&gt;Hello, world!&lt;/p&gt;&lt;/div&gt;'\n</code></pre> Source code in <code>zenaura/client/compiler/compiler.py</code> <pre><code>def compile(self, elm: Node, id=None, zenaura_dom_mode=False):\n    \"\"\"\n    Compiles a Zenui Node into its corresponding HTML representation.\n\n    Args:\n        elm (Node): The Zenui Node object to compile.\n        id (str, optional): The unique ID of the parent component. Used to generate keyed UUIDs.\n        zenaura_dom_mode (bool, optional): Whether to add the `ZENAURA_DOM_ATTRIBUTE` attribute to the compiled HTML. Defaults to False.\n\n    Returns:\n        str: The compiled HTML string.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; compiler = Compiler()\n        &gt;&gt;&gt; node = Node(\"div\", attributes=[Attribute(\"class\", \"my-class\")], children=[Node(\"p\", text=\"Hello, world!\")])\n        &gt;&gt;&gt; compiler.compile(node)\n        '&lt;div class=\"my-class\"&gt;&lt;p&gt;Hello, world!&lt;/p&gt;&lt;/div&gt;'\n        &gt;&gt;&gt; compiler.compile(node, zenaura_dom_mode=True)\n        '&lt;div class=\"my-class\" ZENAURA_DOM_ATTRIBUTE=\"div0\"&gt; &lt;p ZENAURA_DOM_ATTRIBUTE=\"div00\"&gt;Hello, world!&lt;/p&gt;&lt;/div&gt;'\n        ```\n    \"\"\"\n    if elm.is_text_node or isinstance(elm, str):\n        return self.sanitize(elm.text)\n\n    tag = elm.name\n\n    zenui_id = \"\"\n\n    # Assign unique ID for Zenui DOM\n    if isinstance(elm, Node) and zenaura_dom_mode:\n        zenui_id = self.getKeyedUID(id, withAttribut=True, key=elm.path)\n\n    # Get node attributes\n    attributes = self.process_attributes(elm.attributes)\n\n    if tag in self.special_tags.keys():\n        tag = self.special_tags[tag]\n\n    if tag in self_closing_tags:\n        return f\"&lt;{tag}{zenui_id}{attributes} /&gt;\"\n\n    # Start tag\n    html = io.StringIO()\n    html.write(f\"&lt;{tag}{zenui_id}{attributes}&gt;\")\n\n    # Get children\n    for child in elm.children:\n        html.write(self.compile(child, id, zenaura_dom_mode))\n\n    # Finish tag\n    html.write(f\"&lt;/{tag}&gt;\")\n\n    return html.getvalue()\n</code></pre>"},{"location":"api/client/compiler/compiler/#zenaura.client.compiler.compiler.Compiler.getKeyedUID","title":"<code>getKeyedUID(id, withAttribut=False, key=None)</code>","text":"<p>Generates a unique keyed UUID for a child element within a component tree.</p> <p>This UUID is used to create a unique <code>ZENAURA_DOM_ATTRIBUTE</code> attribute for the element.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The unique ID of the parent component.</p> required <code>withAttribut</code> <code>bool</code> <p>Whether to include the <code>ZENAURA_DOM_ATTRIBUTE</code> attribute. Defaults to False.</p> <code>False</code> <code>key</code> <code>str or list</code> <p>The key or path of the child element. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <p>The generated keyed UUID.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; compiler = Compiler()\n&gt;&gt;&gt; compiler.getKeyedUID(\"my-component\", key=\"child1\")\n'my-componentchild1'\n&gt;&gt;&gt; compiler.getKeyedUID(\"my-component\", withAttribut=True, key=[0, 1])\n' ZENAURA_DOM_ATTRIBUTE=\"my-component01\"'\n</code></pre> Source code in <code>zenaura/client/compiler/compiler.py</code> <pre><code>def getKeyedUID(self, id, withAttribut=False, key=None):\n    \"\"\"\n    Generates a unique keyed UUID for a child element within a component tree.\n\n    This UUID is used to create a unique `ZENAURA_DOM_ATTRIBUTE` attribute for the element.\n\n    Args:\n        id (str): The unique ID of the parent component.\n        withAttribut (bool, optional): Whether to include the `ZENAURA_DOM_ATTRIBUTE` attribute. Defaults to False.\n        key (str or list, optional): The key or path of the child element. Defaults to None.\n\n    Returns:\n        str: The generated keyed UUID.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; compiler = Compiler()\n        &gt;&gt;&gt; compiler.getKeyedUID(\"my-component\", key=\"child1\")\n        'my-componentchild1'\n        &gt;&gt;&gt; compiler.getKeyedUID(\"my-component\", withAttribut=True, key=[0, 1])\n        ' ZENAURA_DOM_ATTRIBUTE=\"my-component01\"'\n        ```\n    \"\"\"\n    if isinstance(key, list):\n        key = \"\".join(str(i) for i in key)  # Convert list to string\n\n    if withAttribut:\n        return f' {ZENAURA_DOM_ATTRIBUTE}=\"{id}{key}\"'\n    return f\"{id}{key}\"\n</code></pre>"},{"location":"api/client/compiler/sanitize/","title":"Sanitize","text":""},{"location":"api/client/compiler/sanitize/#zenaura.client.compiler.sanitize.CompilerSanitizer","title":"<code>CompilerSanitizer</code>","text":"<p>This class provides methods for sanitizing user input to prevent various injection attacks.</p> <p>It uses the <code>bleach</code> library to remove potentially harmful HTML tags and attributes,  and the <code>html</code> library to escape special characters.</p> Source code in <code>zenaura/client/compiler/sanitize.py</code> <pre><code>class CompilerSanitizer:\n    \"\"\"\n    This class provides methods for sanitizing user input to prevent various injection attacks.\n\n    It uses the `bleach` library to remove potentially harmful HTML tags and attributes, \n    and the `html` library to escape special characters.\n\n    Attributes:\n        None\n    \"\"\"\n\n    def sanitize(\n        self, \n        user_input: str, \n    ) -&gt; str:\n        \"\"\"\n        Sanitizes user input to prevent various injection attacks.\n\n        This method takes the raw user input as a string and returns a sanitized version of the input.\n\n        Args:\n            user_input (str): The raw user input to sanitize.\n            allowed_tags (list, optional): A list of allowed HTML tags (e.g., ['p', 'br', 'strong']). \n                Defaults to `allowed_tags` from the `zenaura.client.config` module.\n            allowed_attributes (dict, optional): A dictionary mapping allowed tags to their allowed \n                attributes (e.g., {'img': ['src', 'alt']}). Defaults to `allowed_attributes` from the \n                `zenaura.client.config` module.\n\n        Returns:\n            str: The sanitized input.\n        \"\"\"\n        user_input = str(user_input)\n        # Use bleach to remove potentially harmful HTML tags and attributes\n        safe_html = bleach.clean(\n            user_input, tags=allowed_tags, attributes=allowed_attributes\n        )\n\n        return safe_html\n</code></pre>"},{"location":"api/client/compiler/sanitize/#zenaura.client.compiler.sanitize.CompilerSanitizer.sanitize","title":"<code>sanitize(user_input)</code>","text":"<p>Sanitizes user input to prevent various injection attacks.</p> <p>This method takes the raw user input as a string and returns a sanitized version of the input.</p> <p>Parameters:</p> Name Type Description Default <code>user_input</code> <code>str</code> <p>The raw user input to sanitize.</p> required <code>allowed_tags</code> <code>list</code> <p>A list of allowed HTML tags (e.g., ['p', 'br', 'strong']).  Defaults to <code>allowed_tags</code> from the <code>zenaura.client.config</code> module.</p> required <code>allowed_attributes</code> <code>dict</code> <p>A dictionary mapping allowed tags to their allowed  attributes (e.g., {'img': ['src', 'alt']}). Defaults to <code>allowed_attributes</code> from the  <code>zenaura.client.config</code> module.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The sanitized input.</p> Source code in <code>zenaura/client/compiler/sanitize.py</code> <pre><code>def sanitize(\n    self, \n    user_input: str, \n) -&gt; str:\n    \"\"\"\n    Sanitizes user input to prevent various injection attacks.\n\n    This method takes the raw user input as a string and returns a sanitized version of the input.\n\n    Args:\n        user_input (str): The raw user input to sanitize.\n        allowed_tags (list, optional): A list of allowed HTML tags (e.g., ['p', 'br', 'strong']). \n            Defaults to `allowed_tags` from the `zenaura.client.config` module.\n        allowed_attributes (dict, optional): A dictionary mapping allowed tags to their allowed \n            attributes (e.g., {'img': ['src', 'alt']}). Defaults to `allowed_attributes` from the \n            `zenaura.client.config` module.\n\n    Returns:\n        str: The sanitized input.\n    \"\"\"\n    user_input = str(user_input)\n    # Use bleach to remove potentially harmful HTML tags and attributes\n    safe_html = bleach.clean(\n        user_input, tags=allowed_tags, attributes=allowed_attributes\n    )\n\n    return safe_html\n</code></pre>"},{"location":"api/client/dom/dom/","title":"Dom","text":""},{"location":"api/client/dom/dom/#zenaura.client.dom.dom.Dom","title":"<code>Dom</code>","text":"<p>               Bases: <code>Mount</code>, <code>Render</code></p> <p>Zenaura virtual DOM.</p> <p>This class combines the functionalities of <code>Mount</code> and <code>Render</code> classes to provide a comprehensive virtual DOM implementation.</p> <p>Attributes:</p> <ul> <li>Mount: Inherits all attributes and methods from the <code>Mount</code> class, which handles the mounting lifecycle of components.</li> <li>Render: Inherits all attributes and methods from the <code>Render</code> class, which handles the rendering lifecycle of components.</li> </ul> <p>Methods:</p> <ul> <li>mount(comp, container): Mounts the component to the specified container element in the real DOM.</li> <li>render(comp): Renders the component to a virtual DOM tree.</li> <li>update(prev_comp, new_comp): Updates the real DOM based on the differences between the previous and new virtual DOM trees.</li> </ul> <p>Usage:</p> <pre><code># Create a Dom instance\ndom = Dom()\n\n# Create a component\ncomp = MyComponent()\n\n# Mount the component to a container element\ndom.mount(comp, container)\n\n# Render the component\ndom.render(comp)\n\n# Update the component\ndom.update(prev_comp, new_comp)\n</code></pre> Source code in <code>zenaura/client/dom/dom.py</code> <pre><code>class Dom(\n    Mount,\n    Render\n):\n    \"\"\"\n    Zenaura virtual DOM.\n\n    This class combines the functionalities of `Mount` and `Render` classes to provide a comprehensive virtual DOM implementation.\n\n    **Attributes:**\n\n    * **Mount:** Inherits all attributes and methods from the `Mount` class, which handles the mounting lifecycle of components.\n    * **Render:** Inherits all attributes and methods from the `Render` class, which handles the rendering lifecycle of components.\n\n    **Methods:**\n\n    * **mount(comp, container):** Mounts the component to the specified container element in the real DOM.\n    * **render(comp):** Renders the component to a virtual DOM tree.\n    * **update(prev_comp, new_comp):** Updates the real DOM based on the differences between the previous and new virtual DOM trees.\n\n    **Usage:**\n\n    ```python\n    # Create a Dom instance\n    dom = Dom()\n\n    # Create a component\n    comp = MyComponent()\n\n    # Mount the component to a container element\n    dom.mount(comp, container)\n\n    # Render the component\n    dom.render(comp)\n\n    # Update the component\n    dom.update(prev_comp, new_comp)\n    ```\n    \"\"\"\n</code></pre>"},{"location":"api/client/dom/error/","title":"Error","text":""},{"location":"api/client/dom/error/#zenaura.client.dom.error.DefaultDomErrorComponent","title":"<code>DefaultDomErrorComponent</code>","text":"<p>               Bases: <code>Component</code></p> <p>Displays a default error message component.</p> <p>Attributes:</p> Name Type Description <code>error_message</code> <code>str</code> <p>The error message to display.</p> <p>Methods:</p> Name Description <code>render</code> <p>Returns a Node representing the error message.</p> Source code in <code>zenaura/client/dom/error.py</code> <pre><code>@Reuseable\nclass DefaultDomErrorComponent(Component):\n    \"\"\"\n    Displays a default error message component.\n\n    Attributes:\n        error_message (str): The error message to display.\n\n    Methods:\n        render(): Returns a Node representing the error message.\n    \"\"\"\n\n    def __init__(self, error_message):\n        super().__init__()\n        self.error_message = error_message\n\n    def render(self):\n        return Node(\"div\", children=[Node(text=str(self.error_message))])\n</code></pre>"},{"location":"api/client/dom/error/#zenaura.client.dom.error.GracefulDegenerationLifeCycleWrapper","title":"<code>GracefulDegenerationLifeCycleWrapper</code>","text":"<p>               Bases: <code>Hydrator</code></p> <p>Wraps components to handle errors gracefully.</p> <p>This class provides a <code>on_error</code> method that allows components to handle errors gracefully. If a component throws an error, the <code>on_error</code> method will be called with the error message. The component can then return a new component to display in place of the original component.</p> <p>If the component does not have a <code>on_error</code> method, a default error message component will be displayed.</p> Source code in <code>zenaura/client/dom/error.py</code> <pre><code>class GracefulDegenerationLifeCycleWrapper(\n    Hydrator\n):\n    \"\"\"\n    Wraps components to handle errors gracefully.\n\n    This class provides a `on_error` method that allows components\n    to handle errors gracefully. If a component throws an error, the\n    `on_error` method will be called with the error message. The\n    component can then return a new component to display in place of the original\n    component.\n\n    If the component does not have a `on_error` method, a default\n    error message component will be displayed.\n    \"\"\"\n\n    def on_error(self, comp, error) -&gt; None:\n        \"\"\"\n        Handles errors gracefully.\n\n        This method is called when a component throws an error. It allows the\n        component to handle the error gracefully by returning a new component to\n        display in place of the original component.\n\n        Args:\n            comp (Component): The component that threw the error.\n            error (Exception): The error that was thrown.\n        \"\"\"\n\n        # Cleanup the Zen DOM table.\n        self.zen_dom_table.clear()\n\n        if hasattr(comp, \"on_error\"):\n            # Call the component's `on_error` method.\n            error_comp = comp.on_error(str(error))\n\n            # Compile and render the error component.\n            compiled_comp = self.hyd_comp_compile_render(error_comp)\n\n            # Attach the compiled component to the real DOM.\n            self.hyd_rdom_attach_to_root(compiled_comp)\n\n            # Update the virtual DOM with the new render.\n            self.hyd_vdom_update_with_new_render(comp, error_comp.render())\n\n        else:\n            # Create a default error message component.\n            error_comp = DefaultDomErrorComponent(error_message=str(error))\n\n            # Compile and render the default error component.\n            compiled_comp = self.hyd_comp_compile_render(error_comp)\n\n            # Attach the compiled component to the real DOM.\n            self.hyd_rdom_attach_to_root(compiled_comp)\n\n            # Update the virtual DOM with the new render.\n            self.hyd_vdom_update_with_new_render(comp, error_comp.render())\n</code></pre>"},{"location":"api/client/dom/error/#zenaura.client.dom.error.GracefulDegenerationLifeCycleWrapper.on_error","title":"<code>on_error(comp, error)</code>","text":"<p>Handles errors gracefully.</p> <p>This method is called when a component throws an error. It allows the component to handle the error gracefully by returning a new component to display in place of the original component.</p> <p>Parameters:</p> Name Type Description Default <code>comp</code> <code>Component</code> <p>The component that threw the error.</p> required <code>error</code> <code>Exception</code> <p>The error that was thrown.</p> required Source code in <code>zenaura/client/dom/error.py</code> <pre><code>def on_error(self, comp, error) -&gt; None:\n    \"\"\"\n    Handles errors gracefully.\n\n    This method is called when a component throws an error. It allows the\n    component to handle the error gracefully by returning a new component to\n    display in place of the original component.\n\n    Args:\n        comp (Component): The component that threw the error.\n        error (Exception): The error that was thrown.\n    \"\"\"\n\n    # Cleanup the Zen DOM table.\n    self.zen_dom_table.clear()\n\n    if hasattr(comp, \"on_error\"):\n        # Call the component's `on_error` method.\n        error_comp = comp.on_error(str(error))\n\n        # Compile and render the error component.\n        compiled_comp = self.hyd_comp_compile_render(error_comp)\n\n        # Attach the compiled component to the real DOM.\n        self.hyd_rdom_attach_to_root(compiled_comp)\n\n        # Update the virtual DOM with the new render.\n        self.hyd_vdom_update_with_new_render(comp, error_comp.render())\n\n    else:\n        # Create a default error message component.\n        error_comp = DefaultDomErrorComponent(error_message=str(error))\n\n        # Compile and render the default error component.\n        compiled_comp = self.hyd_comp_compile_render(error_comp)\n\n        # Attach the compiled component to the real DOM.\n        self.hyd_rdom_attach_to_root(compiled_comp)\n\n        # Update the virtual DOM with the new render.\n        self.hyd_vdom_update_with_new_render(comp, error_comp.render())\n</code></pre>"},{"location":"api/client/dom/lifecycles/","title":"Lifecycles","text":""},{"location":"api/client/dom/lifecycles/#zenaura.client.dom.lifecycles.mount.MountLifeCycles","title":"<code>MountLifeCycles</code>","text":"<p>               Bases: <code>HydratorVirtualDomAdapter</code></p> <p>This class provides lifecycle methods for components that are mounted to the DOM.</p> <p>It inherits from the <code>HydratorVirtualDomAdapter</code> class, which provides methods for interacting with the virtual DOM.</p> Source code in <code>zenaura/client/dom/lifecycles/mount.py</code> <pre><code>class MountLifeCycles(\n    HydratorVirtualDomAdapter\n):\n    \"\"\"\n    This class provides lifecycle methods for components that are mounted to the DOM.\n\n    It inherits from the `HydratorVirtualDomAdapter` class, which provides methods for interacting with the virtual DOM.\n    \"\"\"\n\n    async def attached(self, comp) -&gt; None:\n        \"\"\"\n        This method is called after the component is mounted to the DOM.\n\n        It allows the component to perform any necessary actions after it has been added to the DOM, such as:\n\n        - Initializing state\n        - Setting up event listeners\n        - Making API calls\n        - Performing animations\n\n        Args:\n            comp: An instance of the Component class.\n\n        Returns:\n            None\n        \"\"\"\n\n        if hasattr(comp, 'attached'):\n            await comp.attached()\n</code></pre>"},{"location":"api/client/dom/lifecycles/#zenaura.client.dom.lifecycles.mount.MountLifeCycles.attached","title":"<code>attached(comp)</code>  <code>async</code>","text":"<p>This method is called after the component is mounted to the DOM.</p> <p>It allows the component to perform any necessary actions after it has been added to the DOM, such as:</p> <ul> <li>Initializing state</li> <li>Setting up event listeners</li> <li>Making API calls</li> <li>Performing animations</li> </ul> <p>Parameters:</p> Name Type Description Default <code>comp</code> <p>An instance of the Component class.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>zenaura/client/dom/lifecycles/mount.py</code> <pre><code>async def attached(self, comp) -&gt; None:\n    \"\"\"\n    This method is called after the component is mounted to the DOM.\n\n    It allows the component to perform any necessary actions after it has been added to the DOM, such as:\n\n    - Initializing state\n    - Setting up event listeners\n    - Making API calls\n    - Performing animations\n\n    Args:\n        comp: An instance of the Component class.\n\n    Returns:\n        None\n    \"\"\"\n\n    if hasattr(comp, 'attached'):\n        await comp.attached()\n</code></pre>"},{"location":"api/client/dom/lifecycles/#zenaura.client.dom.lifecycles.render.RenderLifeCycle","title":"<code>RenderLifeCycle</code>","text":"<p>This class provides lifecycle methods for components that are rendered to the DOM.</p> <p>It allows components to perform actions before and after they are updated and re-rendered in the DOM.</p> Source code in <code>zenaura/client/dom/lifecycles/render.py</code> <pre><code>class RenderLifeCycle:\n    \"\"\"\n    This class provides lifecycle methods for components that are rendered to the DOM.\n\n    It allows components to perform actions before and after they are updated and re-rendered in the DOM.\n\n    Attributes:\n        None\n    \"\"\"\n\n    async def on_mutation(self, comp) -&gt; None:\n        \"\"\"\n        This method is called after the component is updated in the DOM and re-rendered.\n\n        It allows the component to perform any necessary actions before the update is applied, such as:\n\n        - Updating state based on new props\n        - Setting up event listeners\n        - Making API calls\n        - Performing animations\n\n        Args:\n            comp: An instance of the Component class.\n\n        Returns:\n            None\n        \"\"\"\n\n        # Perform operations before updating\n        if hasattr(comp, 'on_mutation'):\n            await comp.on_mutation()\n\n    async def on_settled(self, comp) -&gt; None:\n        \"\"\"\n        This method is called after the component is updated in the DOM and re-rendered.\n\n        It allows the component to perform any necessary actions after the update is applied, such as:\n\n        - Focusing on an input element\n        - Scrolling to a specific position\n        - Triggering custom events\n\n        Args:\n            comp: An instance of the Component class.\n\n        Returns:\n            None\n        \"\"\"\n\n        # Perform operations after updating\n        if hasattr(comp, 'on_settled'):\n            await comp.on_settled()\n</code></pre>"},{"location":"api/client/dom/lifecycles/#zenaura.client.dom.lifecycles.render.RenderLifeCycle.on_mutation","title":"<code>on_mutation(comp)</code>  <code>async</code>","text":"<p>This method is called after the component is updated in the DOM and re-rendered.</p> <p>It allows the component to perform any necessary actions before the update is applied, such as:</p> <ul> <li>Updating state based on new props</li> <li>Setting up event listeners</li> <li>Making API calls</li> <li>Performing animations</li> </ul> <p>Parameters:</p> Name Type Description Default <code>comp</code> <p>An instance of the Component class.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>zenaura/client/dom/lifecycles/render.py</code> <pre><code>async def on_mutation(self, comp) -&gt; None:\n    \"\"\"\n    This method is called after the component is updated in the DOM and re-rendered.\n\n    It allows the component to perform any necessary actions before the update is applied, such as:\n\n    - Updating state based on new props\n    - Setting up event listeners\n    - Making API calls\n    - Performing animations\n\n    Args:\n        comp: An instance of the Component class.\n\n    Returns:\n        None\n    \"\"\"\n\n    # Perform operations before updating\n    if hasattr(comp, 'on_mutation'):\n        await comp.on_mutation()\n</code></pre>"},{"location":"api/client/dom/lifecycles/#zenaura.client.dom.lifecycles.render.RenderLifeCycle.on_settled","title":"<code>on_settled(comp)</code>  <code>async</code>","text":"<p>This method is called after the component is updated in the DOM and re-rendered.</p> <p>It allows the component to perform any necessary actions after the update is applied, such as:</p> <ul> <li>Focusing on an input element</li> <li>Scrolling to a specific position</li> <li>Triggering custom events</li> </ul> <p>Parameters:</p> Name Type Description Default <code>comp</code> <p>An instance of the Component class.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>zenaura/client/dom/lifecycles/render.py</code> <pre><code>async def on_settled(self, comp) -&gt; None:\n    \"\"\"\n    This method is called after the component is updated in the DOM and re-rendered.\n\n    It allows the component to perform any necessary actions after the update is applied, such as:\n\n    - Focusing on an input element\n    - Scrolling to a specific position\n    - Triggering custom events\n\n    Args:\n        comp: An instance of the Component class.\n\n    Returns:\n        None\n    \"\"\"\n\n    # Perform operations after updating\n    if hasattr(comp, 'on_settled'):\n        await comp.on_settled()\n</code></pre>"},{"location":"api/client/dom/mount/","title":"Mount","text":""},{"location":"api/client/dom/mount/#zenaura.client.dom.mount.Mount","title":"<code>Mount</code>","text":"<p>               Bases: <code>GracefulDegenerationLifeCycleWrapper</code>, <code>MountLifeCycles</code></p> <p>Mounts a single <code>Page</code> instance to the DOM.</p> <p>This class handles the mounting of a single <code>Page</code> instance to the DOM. It ensures that only one page is mounted at a time and provides lifecycle methods for handling the mounting process.</p> <p>Lifecycle:</p> <ol> <li>Server-side:<ul> <li>The server hydrates all app pages and overwrites the <code>index.html</code> file.</li> <li>The <code>App</code> class toggles the visibility of the mounted page.</li> </ul> </li> <li>Client-side:<ul> <li>The <code>Mount</code> class triggers the <code>attached</code> lifecycle method for the page components.</li> </ul> </li> </ol> <p>Error Handling:</p> <ul> <li>If an error occurs during mounting, the <code>on_error</code> method is called with the error message.</li> <li>This method allows components to handle errors gracefully by returning a new component to display in place of the original component.</li> <li>If the component does not have a <code>on_error</code> method, a default error message component is displayed.</li> </ul> <p>Parameters:</p> <ul> <li><code>page</code>: An instance of the <code>Page</code> class.</li> </ul> <p>Returns:</p> <p>None</p> Source code in <code>zenaura/client/dom/mount.py</code> <pre><code>class Mount(\n    GracefulDegenerationLifeCycleWrapper,\n    MountLifeCycles,\n    ):\n    \"\"\"\n    Mounts a single `Page` instance to the DOM.\n\n    This class handles the mounting of a single `Page` instance to the DOM. It ensures that only one page is mounted at a time and provides lifecycle methods for handling the mounting process.\n\n    **Lifecycle:**\n\n    1. **Server-side:**\n        - The server hydrates all app pages and overwrites the `index.html` file.\n        - The `App` class toggles the visibility of the mounted page.\n    2. **Client-side:**\n        - The `Mount` class triggers the `attached` lifecycle method for the page components.\n\n    **Error Handling:**\n\n    - If an error occurs during mounting, the `on_error` method is called with the error message.\n    - This method allows components to handle errors gracefully by returning a new component to display in place of the original component.\n    - If the component does not have a `on_error` method, a default error message component is displayed.\n\n    **Parameters:**\n\n    - `page`: An instance of the `Page` class.\n\n    **Returns:**\n\n    None\n    \"\"\"\n\n    async def mount(self, page: Page) -&gt; None:\n        \"\"\"\n        Mounts the given `Page` instance to the DOM.\n\n        This method attempts to mount the provided `Page` instance to the DOM. It iterates through the page's children, updating their state in the virtual DOM and triggering the `attached` lifecycle method for each component.\n\n        **Error Handling:**\n\n        - If an error occurs during mounting, the `on_error` method is called with the error message.\n        - This method allows components to handle errors gracefully by returning a new component to display in place of the original component.\n        - If the component does not have a `on_error` method, a default error message component is displayed.\n\n        **Parameters:**\n\n        - `page`: An instance of the `Page` class.\n\n        **Returns:**\n\n        None\n        \"\"\"\n\n        try:\n            for comp in page.children:\n                # Update state in vdom\n                self.hyd_vdom_update(comp)\n                # Trigger attached for page components\n                await self.attached(comp)\n\n        except Exception as e:\n            self.on_error(page.children[0], traceback.format_exc())\n</code></pre>"},{"location":"api/client/dom/mount/#zenaura.client.dom.mount.Mount.mount","title":"<code>mount(page)</code>  <code>async</code>","text":"<p>Mounts the given <code>Page</code> instance to the DOM.</p> <p>This method attempts to mount the provided <code>Page</code> instance to the DOM. It iterates through the page's children, updating their state in the virtual DOM and triggering the <code>attached</code> lifecycle method for each component.</p> <p>Error Handling:</p> <ul> <li>If an error occurs during mounting, the <code>on_error</code> method is called with the error message.</li> <li>This method allows components to handle errors gracefully by returning a new component to display in place of the original component.</li> <li>If the component does not have a <code>on_error</code> method, a default error message component is displayed.</li> </ul> <p>Parameters:</p> <ul> <li><code>page</code>: An instance of the <code>Page</code> class.</li> </ul> <p>Returns:</p> <p>None</p> Source code in <code>zenaura/client/dom/mount.py</code> <pre><code>async def mount(self, page: Page) -&gt; None:\n    \"\"\"\n    Mounts the given `Page` instance to the DOM.\n\n    This method attempts to mount the provided `Page` instance to the DOM. It iterates through the page's children, updating their state in the virtual DOM and triggering the `attached` lifecycle method for each component.\n\n    **Error Handling:**\n\n    - If an error occurs during mounting, the `on_error` method is called with the error message.\n    - This method allows components to handle errors gracefully by returning a new component to display in place of the original component.\n    - If the component does not have a `on_error` method, a default error message component is displayed.\n\n    **Parameters:**\n\n    - `page`: An instance of the `Page` class.\n\n    **Returns:**\n\n    None\n    \"\"\"\n\n    try:\n        for comp in page.children:\n            # Update state in vdom\n            self.hyd_vdom_update(comp)\n            # Trigger attached for page components\n            await self.attached(comp)\n\n    except Exception as e:\n        self.on_error(page.children[0], traceback.format_exc())\n</code></pre>"},{"location":"api/client/dom/render/","title":"Render","text":""},{"location":"api/client/dom/render/#zenaura.client.dom.render.Render","title":"<code>Render</code>","text":"<p>               Bases: <code>GracefulDegenerationLifeCycleWrapper</code>, <code>RenderLifeCycle</code>, <code>DiffingAlgorithm</code>, <code>HydratorTasker</code></p> <p>Renders components by updating the DOM based on the differences between the previous and new component trees.</p> <p>This class provides methods for:</p> <ul> <li>Lifecycle: Calling lifecycle methods for components during rendering.</li> <li>Diffing: Calculating the differences between the previous and new component trees.</li> <li>Updating: Applying the calculated differences to the DOM.</li> <li>Scheduling: Scheduling updates with the browser.</li> <li>Virtual DOM Update: Updating the virtual DOM with the new component tree.</li> <li>Error Handling: Handling errors gracefully and displaying an error message component.</li> </ul> <p>Attributes:</p> <ul> <li><code>zen_dom_table</code>: A dictionary that stores the virtual DOM for each component.</li> <li><code>hyd_tsk_task_queues</code>: A dictionary that stores task queues for each component.</li> </ul> <p>Methods:</p> <ul> <li><code>render(comp)</code>: Renders the given component by updating the DOM.</li> <li><code>on_mutation(comp)</code>: Calls the <code>on_mutation</code> lifecycle method for the component.</li> <li><code>on_settled(comp)</code>: Calls the <code>on_settled</code> lifecycle method for the component.</li> <li><code>search(prev_tree, new_tree, comp_id)</code>: Calculates the differences between the previous and new component trees.</li> <li><code>update(patches, comp_id)</code>: Applies the calculated differences to the DOM.</li> <li><code>hyd_vdom_update(comp)</code>: Updates the virtual DOM with the new component tree.</li> <li><code>on_error(comp, error)</code>: Handles errors gracefully and displays an error message component.</li> </ul> Source code in <code>zenaura/client/dom/render.py</code> <pre><code>class Render(\n    GracefulDegenerationLifeCycleWrapper,\n    RenderLifeCycle, \n    DiffingAlgorithm,\n    HydratorTasker\n):\n    \"\"\"\n    Renders components by updating the DOM based on the differences between the previous and new component trees.\n\n    This class provides methods for:\n\n    - **Lifecycle:** Calling lifecycle methods for components during rendering.\n    - **Diffing:** Calculating the differences between the previous and new component trees.\n    - **Updating:** Applying the calculated differences to the DOM.\n    - **Scheduling:** Scheduling updates with the browser.\n    - **Virtual DOM Update:** Updating the virtual DOM with the new component tree.\n    - **Error Handling:** Handling errors gracefully and displaying an error message component.\n\n    **Attributes:**\n\n    - `zen_dom_table`: A dictionary that stores the virtual DOM for each component.\n    - `hyd_tsk_task_queues`: A dictionary that stores task queues for each component.\n\n    **Methods:**\n\n    - `render(comp)`: Renders the given component by updating the DOM.\n    - `on_mutation(comp)`: Calls the `on_mutation` lifecycle method for the component.\n    - `on_settled(comp)`: Calls the `on_settled` lifecycle method for the component.\n    - `search(prev_tree, new_tree, comp_id)`: Calculates the differences between the previous and new component trees.\n    - `update(patches, comp_id)`: Applies the calculated differences to the DOM.\n    - `hyd_vdom_update(comp)`: Updates the virtual DOM with the new component tree.\n    - `on_error(comp, error)`: Handles errors gracefully and displays an error message component.\n    \"\"\"\n    async def render(self, comp ) -&gt; None:\n        \"\"\"\n        Renders the component by updating the DOM based on the differences between the previous and new component trees.\n\n        This method performs the following steps:\n\n        1. **Lifecycle:** Calls the `on_mutation` lifecycle method for the component.\n        2. **Diffing:** Calculates the differences between the previous and new component trees using the `search` method.\n        3. **Update:** Applies the calculated differences to the DOM using the `update` method.\n        4. **Scheduling:** Schedules the updates with the browser using the `hyd_rdom_is_complete` and `hyd_tsk_dequeue_task` methods.\n        5. **Virtual DOM Update:** Updates the virtual DOM with the new component tree using the `hyd_vdom_update` method.\n        6. **Lifecycle:** Calls the `on_settled` lifecycle method for the component.\n\n        **Error Handling:**\n\n        - If an error occurs during rendering, the `on_error` method is called with the error message.\n        - This method allows components to handle errors gracefully by returning a new component to display in place of the original component.\n        - If the component does not have a `on_error` method, a default error message component is displayed.\n\n        **Parameters:**\n\n        - `comp`: An instance of the `Component` class.\n\n        **Returns:**\n\n        None\n        \"\"\"\n        try:\n\n            # update steps 1-3: on_mutation -&gt; update -&gt; on_settled\n            # update 1: lifecycle method to be called before updating\n            await self.on_mutation(comp)\n            comp_id = comp.id            \n            prev_tree = self.zen_dom_table[comp_id]\n            new_tree = comp.render()\n\n            # create task queue for component\n            task_que = self.hyd_tsk_get_or_create_task_queue(comp_id)\n\n            # run diffing algorithm\n            patches = self.search(prev_tree, new_tree, comp_id)\n            await self.update(patches, comp_id)\n\n            # schedule update with the browser\n            while not task_que.empty():\n                task = self.hyd_tsk_dequeue_task(comp_id)\n                await task()\n\n\n            self.hyd_vdom_update(comp)\n\n            # update 3  : on_settled method to be called after updating\n            await self.on_settled(comp)\n\n        except Exception as e:\n            self.on_error(comp, traceback.format_exc())\n</code></pre>"},{"location":"api/client/dom/render/#zenaura.client.dom.render.Render.render","title":"<code>render(comp)</code>  <code>async</code>","text":"<p>Renders the component by updating the DOM based on the differences between the previous and new component trees.</p> <p>This method performs the following steps:</p> <ol> <li>Lifecycle: Calls the <code>on_mutation</code> lifecycle method for the component.</li> <li>Diffing: Calculates the differences between the previous and new component trees using the <code>search</code> method.</li> <li>Update: Applies the calculated differences to the DOM using the <code>update</code> method.</li> <li>Scheduling: Schedules the updates with the browser using the <code>hyd_rdom_is_complete</code> and <code>hyd_tsk_dequeue_task</code> methods.</li> <li>Virtual DOM Update: Updates the virtual DOM with the new component tree using the <code>hyd_vdom_update</code> method.</li> <li>Lifecycle: Calls the <code>on_settled</code> lifecycle method for the component.</li> </ol> <p>Error Handling:</p> <ul> <li>If an error occurs during rendering, the <code>on_error</code> method is called with the error message.</li> <li>This method allows components to handle errors gracefully by returning a new component to display in place of the original component.</li> <li>If the component does not have a <code>on_error</code> method, a default error message component is displayed.</li> </ul> <p>Parameters:</p> <ul> <li><code>comp</code>: An instance of the <code>Component</code> class.</li> </ul> <p>Returns:</p> <p>None</p> Source code in <code>zenaura/client/dom/render.py</code> <pre><code>async def render(self, comp ) -&gt; None:\n    \"\"\"\n    Renders the component by updating the DOM based on the differences between the previous and new component trees.\n\n    This method performs the following steps:\n\n    1. **Lifecycle:** Calls the `on_mutation` lifecycle method for the component.\n    2. **Diffing:** Calculates the differences between the previous and new component trees using the `search` method.\n    3. **Update:** Applies the calculated differences to the DOM using the `update` method.\n    4. **Scheduling:** Schedules the updates with the browser using the `hyd_rdom_is_complete` and `hyd_tsk_dequeue_task` methods.\n    5. **Virtual DOM Update:** Updates the virtual DOM with the new component tree using the `hyd_vdom_update` method.\n    6. **Lifecycle:** Calls the `on_settled` lifecycle method for the component.\n\n    **Error Handling:**\n\n    - If an error occurs during rendering, the `on_error` method is called with the error message.\n    - This method allows components to handle errors gracefully by returning a new component to display in place of the original component.\n    - If the component does not have a `on_error` method, a default error message component is displayed.\n\n    **Parameters:**\n\n    - `comp`: An instance of the `Component` class.\n\n    **Returns:**\n\n    None\n    \"\"\"\n    try:\n\n        # update steps 1-3: on_mutation -&gt; update -&gt; on_settled\n        # update 1: lifecycle method to be called before updating\n        await self.on_mutation(comp)\n        comp_id = comp.id            \n        prev_tree = self.zen_dom_table[comp_id]\n        new_tree = comp.render()\n\n        # create task queue for component\n        task_que = self.hyd_tsk_get_or_create_task_queue(comp_id)\n\n        # run diffing algorithm\n        patches = self.search(prev_tree, new_tree, comp_id)\n        await self.update(patches, comp_id)\n\n        # schedule update with the browser\n        while not task_que.empty():\n            task = self.hyd_tsk_dequeue_task(comp_id)\n            await task()\n\n\n        self.hyd_vdom_update(comp)\n\n        # update 3  : on_settled method to be called after updating\n        await self.on_settled(comp)\n\n    except Exception as e:\n        self.on_error(comp, traceback.format_exc())\n</code></pre>"},{"location":"api/client/hydrator/hy_comp/","title":"Compiler Adapter","text":""},{"location":"api/client/hydrator/hy_comp/#zenaura.client.hydrator.compiler_adapter.HydratorCompilerAdapter","title":"<code>HydratorCompilerAdapter</code>","text":"<p>hyderator adapter for all real dom operations methods should start with: hyd_comp_</p> Source code in <code>zenaura/client/hydrator/compiler_adapter.py</code> <pre><code>class HydratorCompilerAdapter:\n    \"\"\"\n        hyderator adapter for all real dom operations\n        methods should start with:\n        hyd_comp_\n    \"\"\"        \n    def hyd_comp_get_keyed_uuid(\n        self,\n        id : str, \n        key : str\n    ):\n        \"\"\"\n            compiler operation : wraps compiler.getKeyedUID \n        \"\"\"\n        return compiler.getKeyedUID(\n            id=id, \n            key=key,\n        )\n\n    def hyd_comp_compile_render(\n        self,\n        comp: Component,\n    ):\n        \"\"\"\n            compiler operation : wraps compiler compile, returns str \"HTMLElement\"\n            compile node\n        \"\"\"\n        return compiler.compile(\n                comp.render(), \n                id=comp.id,\n                zenaura_dom_mode=True\n            )\n\n    def hyd_comp_compile_children(\n        self,\n        children: List[Node],\n        id: str,\n        zenaura_dom_mode: bool,\n        key: str=\"\"\n    ):\n        \"\"\"\n            compiler operation : wraps compiler compile, returns str \"HTMLElement\"\n            compiles node children\n        \"\"\"\n        return compiler.compile(\n            children, \n            id=id,\n            zenaura_dom_mode=True,\n        )\n\n    def hyd_comp_compile_page(self, page: Page) -&gt; str:\n        \"\"\"\n            compiler operation : wraps compiler compile, returns str \"HTMLElement\"\n            compiles page children\n        \"\"\"\n        html = io.StringIO()\n        for comp in page.children:\n            html.write(\n                compiler.compile(\n                    comp.render(), \n                    comp.id,\n                    zenaura_dom_mode=True,\n                )\n            )\n        return html.getvalue()\n</code></pre>"},{"location":"api/client/hydrator/hy_comp/#zenaura.client.hydrator.compiler_adapter.HydratorCompilerAdapter.hyd_comp_compile_children","title":"<code>hyd_comp_compile_children(children, id, zenaura_dom_mode, key='')</code>","text":"<p>compiler operation : wraps compiler compile, returns str \"HTMLElement\" compiles node children</p> Source code in <code>zenaura/client/hydrator/compiler_adapter.py</code> <pre><code>def hyd_comp_compile_children(\n    self,\n    children: List[Node],\n    id: str,\n    zenaura_dom_mode: bool,\n    key: str=\"\"\n):\n    \"\"\"\n        compiler operation : wraps compiler compile, returns str \"HTMLElement\"\n        compiles node children\n    \"\"\"\n    return compiler.compile(\n        children, \n        id=id,\n        zenaura_dom_mode=True,\n    )\n</code></pre>"},{"location":"api/client/hydrator/hy_comp/#zenaura.client.hydrator.compiler_adapter.HydratorCompilerAdapter.hyd_comp_compile_page","title":"<code>hyd_comp_compile_page(page)</code>","text":"<p>compiler operation : wraps compiler compile, returns str \"HTMLElement\" compiles page children</p> Source code in <code>zenaura/client/hydrator/compiler_adapter.py</code> <pre><code>def hyd_comp_compile_page(self, page: Page) -&gt; str:\n    \"\"\"\n        compiler operation : wraps compiler compile, returns str \"HTMLElement\"\n        compiles page children\n    \"\"\"\n    html = io.StringIO()\n    for comp in page.children:\n        html.write(\n            compiler.compile(\n                comp.render(), \n                comp.id,\n                zenaura_dom_mode=True,\n            )\n        )\n    return html.getvalue()\n</code></pre>"},{"location":"api/client/hydrator/hy_comp/#zenaura.client.hydrator.compiler_adapter.HydratorCompilerAdapter.hyd_comp_compile_render","title":"<code>hyd_comp_compile_render(comp)</code>","text":"<p>compiler operation : wraps compiler compile, returns str \"HTMLElement\" compile node</p> Source code in <code>zenaura/client/hydrator/compiler_adapter.py</code> <pre><code>def hyd_comp_compile_render(\n    self,\n    comp: Component,\n):\n    \"\"\"\n        compiler operation : wraps compiler compile, returns str \"HTMLElement\"\n        compile node\n    \"\"\"\n    return compiler.compile(\n            comp.render(), \n            id=comp.id,\n            zenaura_dom_mode=True\n        )\n</code></pre>"},{"location":"api/client/hydrator/hy_comp/#zenaura.client.hydrator.compiler_adapter.HydratorCompilerAdapter.hyd_comp_get_keyed_uuid","title":"<code>hyd_comp_get_keyed_uuid(id, key)</code>","text":"<p>compiler operation : wraps compiler.getKeyedUID</p> Source code in <code>zenaura/client/hydrator/compiler_adapter.py</code> <pre><code>def hyd_comp_get_keyed_uuid(\n    self,\n    id : str, \n    key : str\n):\n    \"\"\"\n        compiler operation : wraps compiler.getKeyedUID \n    \"\"\"\n    return compiler.getKeyedUID(\n        id=id, \n        key=key,\n    )\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/","title":"Real DOM Adapter","text":""},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter","title":"<code>HydratorRealDomAdapter</code>","text":"<p>hyderator adapter for all real dom operations methods should start with: hyd_romp_</p> Source code in <code>zenaura/client/hydrator/real_dom_adapter.py</code> <pre><code>class HydratorRealDomAdapter:\n    # for testing \n    \"\"\"\n        hyderator adapter for all real dom operations\n        methods should start with:\n        hyd_romp_\n    \"\"\"\n\n\n    def hyd_rdom_create_element(self, virtual_node: Node) -&gt; HTMLElement:\n        \"\"\"\n        DOM operation: creates html element and returns it as HTMLElement\n\n        Args:\n            virtual_node: Node - the virtual node representing the element to be created\n\n        Returns:\n            HTMLElement - the created HTML element\n        \"\"\"\n        element = document.createElement(virtual_node.name)\n\n        return element\n\n    def hyd_rdom_attach_to_root(self, html : str) -&gt; None:\n        \"\"\"\n        DOM operation: attaches compiled_comp to mounted_comp_id\n\n        Args:\n            html: str - the HTML string to be attached to the root element\n        \"\"\"\n        document.getElementById(\"root\").innerHTML = html\n\n    def hyd_rdom_attach_to_mounted_comp(\n            self,\n            mounted_comp_id: str,\n            html: str\n    ):\n        \"\"\"\n        DOM operation: attaches compiled_comp to mounted_comp_id\n\n        Args:\n            mounted_comp_id: str - the ID of the previously mounted component\n            html: str - the HTML string to be attached to the mounted component\n        \"\"\"\n        foundNode = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{mounted_comp_id}\"]')\n        if foundNode:\n            foundNode.outerHTML = html\n\n    def hyd_rdom_set_attribute(self, mounted_comp_id: str, attribute: Attribute) -&gt; None:\n        \"\"\"\n        DOM operation: Sets attributes on an HTML element.\n\n        Args:\n            mounted_comp_id: The ID of the element to modify.\n            attributes: A dictionary of attribute names and their values.\n        \"\"\"\n        element = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{mounted_comp_id}\"]')\n        if element:\n            element.setAttribute(attribute.key, attribute.value)\n\n\n    def hyd_rdom_remove_attribute(self, mounted_comp_id: str, attribute_name: str) -&gt; None:\n        \"\"\"\n        DOM operation: Removes an attribute from an HTML element.\n\n        Args:\n            mounted_comp_id: The ID of the element.\n            attribute_name: The name of the attribute to remove.\n        \"\"\"\n        element = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{mounted_comp_id}\"]')\n        if element:\n            element.removeAttribute(attribute_name)\n\n    def hyd_rdom_remove_element(self, mounted_comp_id: str) -&gt; None:\n        \"\"\"\n        DOM operation: removes an element from the DOM\n\n        Args:\n            mounted_comp_id: str - the ID of the element to be removed\n        \"\"\"\n        element = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{mounted_comp_id}\"]')\n        if element:\n            element.parentNode.removeChild(element)\n\n\n    def hyd_rdom_append_child(self, mounted_comp_id:str, child_html:str) -&gt; None:\n        \"\"\"\n        DOM operation: appends a child to an element\n\n        Args:\n            mounted_comp_id: str - the ID of the parent element\n            child_html: str - the HTML string of the child element to be appended\n        \"\"\"\n        element = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{mounted_comp_id}\"]')\n        if element:\n            child_node = document.createElement(\"template\")\n            child_node.innerHTML = child_html\n            element.appendChild(child_node.content.firstChild)\n\n    def hyd_rdom_append_child_after(self, parent_node_id, child_node_id, child_html) -&gt; None:\n        \"\"\"\n        DOM operation: appends a child to an element after a specific child\n\n        Args:\n            parent_node_id: str - the ID of the parent element\n            child_node_id: str - the ID of the child element to insert after\n            child_html: str - the HTML string of the child element to be appended\n        \"\"\"\n        element = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{parent_node_id}\"]')\n        if element : # if parent exists\n            child_node = document.createElement(\"template\")\n            child_node.innerHTML = child_html\n            curr_node = child_node.content.firstChild\n            child_index = int( child_node_id[-1])\n            prev_child = child_index - 1 # child on the dom to insert the new child after it\n            prev_child_id = child_node_id[:-1] + str(prev_child) # parent-childIndex\n            prev_child = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{prev_child_id}\"]')\n            if prev_child: # insert after the current child:\n                element.insertBefore(curr_node, prev_child.nextSibling)\n            else: # parent is a leaf no children\n                element.append(curr_node)\n            pass\n\n    def hyd_rdom_remove_child(self, child_id:str) -&gt; None:\n        \"\"\"\n        DOM operation: removes a child of an element\n\n        Args:\n            child_id: str - the ID of the child element to be removed\n        \"\"\"\n        child_node = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{child_id}\"]')\n        if child_node:\n            child_node.outerHTML = \"\"\n\n\n    def hyd_rdom_add_text_render(self, mounted_comp_id: str, text_content: str) -&gt; None:\n        \"\"\"\n        DOM operation: Adds a text node to an element.\n\n        Args:\n            mounted_comp_id: str - the ID of the element to add the text node to\n            text_content: str - the text content of the text node\n        \"\"\"\n        element = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{mounted_comp_id}\"]')\n        if element:\n            text_node = document.createTextNode(text_content)\n            element.appendChild(text_node)\n\n\n    def hyd_rdom_replace_inner_text(self, mounted_comp_id: str, new_text: str) -&gt; None:\n        \"\"\"\n        DOM operation: Replaces the inner text content of an element.\n\n        Args:\n            mounted_comp_id: str - the ID of the element to replace the text content of\n            new_text: str - the new text content\n        \"\"\"\n        element = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{mounted_comp_id}\"]')\n        if element:\n            element.textContent = new_text\n\n    def hyd_rdom_is_interactive(self) -&gt; bool:\n        \"\"\"\n        DOM operation: checks if real dom  is interactive\n\n        Returns:\n            bool - True if the DOM is interactive, False otherwise\n        \"\"\"\n        return document.readyState == \"interactive\"\n\n    def hyd_rdom_is_complete(self) -&gt; bool:\n        \"\"\"\n        DOM operation: checks if real dom  is complete\n\n        Returns:\n            bool - True if the DOM is complete, False otherwise\n        \"\"\"\n        return document.readyState == \"complete\"\n\n    def hyd_rdom_is_loading(self) -&gt; bool:\n        \"\"\"\n        DOM operation: checks if real dom  is complete\n\n        Returns:\n            bool - True if the DOM is complete, False otherwise\n        \"\"\"\n        return document.readyState == \"load\"\n\n    def hyd_rdom_is_content_loaded(self) -&gt; bool:\n        \"\"\"\n        DOM operation: checks if real dom  is content loaded\n\n        Returns:\n            bool - True if the DOM is content loaded, False otherwise\n        \"\"\"\n        return document.readyState == \"DOMContentLoaded\"\n\n\n    def hyd_rdom_toggle_pages_visibilty(self, previous_page : Page, current_page : Page ):\n        \"\"\"\n        Toggles the visibility of the previous and current pages.\n\n        Args:\n            previous_page: Page - the previously mounted page\n            current_page: Page - the currently mounted page\n        \"\"\"\n        p_page = document.querySelector(f'[data-zenaura=\"{previous_page.id}\"]')\n        if p_page:\n            p_page.hidden = True\n        curr_page = document.querySelector(f'[data-zenaura=\"{current_page.id}\"]')\n        if curr_page:\n            curr_page.hidden = False # Update the title\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_add_text_render","title":"<code>hyd_rdom_add_text_render(mounted_comp_id, text_content)</code>","text":"<p>DOM operation: Adds a text node to an element.</p> <p>Parameters:</p> Name Type Description Default <code>mounted_comp_id</code> <code>str</code> <p>str - the ID of the element to add the text node to</p> required <code>text_content</code> <code>str</code> <p>str - the text content of the text node</p> required Source code in <code>zenaura/client/hydrator/real_dom_adapter.py</code> <pre><code>def hyd_rdom_add_text_render(self, mounted_comp_id: str, text_content: str) -&gt; None:\n    \"\"\"\n    DOM operation: Adds a text node to an element.\n\n    Args:\n        mounted_comp_id: str - the ID of the element to add the text node to\n        text_content: str - the text content of the text node\n    \"\"\"\n    element = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{mounted_comp_id}\"]')\n    if element:\n        text_node = document.createTextNode(text_content)\n        element.appendChild(text_node)\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_append_child","title":"<code>hyd_rdom_append_child(mounted_comp_id, child_html)</code>","text":"<p>DOM operation: appends a child to an element</p> <p>Parameters:</p> Name Type Description Default <code>mounted_comp_id</code> <code>str</code> <p>str - the ID of the parent element</p> required <code>child_html</code> <code>str</code> <p>str - the HTML string of the child element to be appended</p> required Source code in <code>zenaura/client/hydrator/real_dom_adapter.py</code> <pre><code>def hyd_rdom_append_child(self, mounted_comp_id:str, child_html:str) -&gt; None:\n    \"\"\"\n    DOM operation: appends a child to an element\n\n    Args:\n        mounted_comp_id: str - the ID of the parent element\n        child_html: str - the HTML string of the child element to be appended\n    \"\"\"\n    element = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{mounted_comp_id}\"]')\n    if element:\n        child_node = document.createElement(\"template\")\n        child_node.innerHTML = child_html\n        element.appendChild(child_node.content.firstChild)\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_append_child_after","title":"<code>hyd_rdom_append_child_after(parent_node_id, child_node_id, child_html)</code>","text":"<p>DOM operation: appends a child to an element after a specific child</p> <p>Parameters:</p> Name Type Description Default <code>parent_node_id</code> <p>str - the ID of the parent element</p> required <code>child_node_id</code> <p>str - the ID of the child element to insert after</p> required <code>child_html</code> <p>str - the HTML string of the child element to be appended</p> required Source code in <code>zenaura/client/hydrator/real_dom_adapter.py</code> <pre><code>def hyd_rdom_append_child_after(self, parent_node_id, child_node_id, child_html) -&gt; None:\n    \"\"\"\n    DOM operation: appends a child to an element after a specific child\n\n    Args:\n        parent_node_id: str - the ID of the parent element\n        child_node_id: str - the ID of the child element to insert after\n        child_html: str - the HTML string of the child element to be appended\n    \"\"\"\n    element = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{parent_node_id}\"]')\n    if element : # if parent exists\n        child_node = document.createElement(\"template\")\n        child_node.innerHTML = child_html\n        curr_node = child_node.content.firstChild\n        child_index = int( child_node_id[-1])\n        prev_child = child_index - 1 # child on the dom to insert the new child after it\n        prev_child_id = child_node_id[:-1] + str(prev_child) # parent-childIndex\n        prev_child = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{prev_child_id}\"]')\n        if prev_child: # insert after the current child:\n            element.insertBefore(curr_node, prev_child.nextSibling)\n        else: # parent is a leaf no children\n            element.append(curr_node)\n        pass\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_attach_to_mounted_comp","title":"<code>hyd_rdom_attach_to_mounted_comp(mounted_comp_id, html)</code>","text":"<p>DOM operation: attaches compiled_comp to mounted_comp_id</p> <p>Parameters:</p> Name Type Description Default <code>mounted_comp_id</code> <code>str</code> <p>str - the ID of the previously mounted component</p> required <code>html</code> <code>str</code> <p>str - the HTML string to be attached to the mounted component</p> required Source code in <code>zenaura/client/hydrator/real_dom_adapter.py</code> <pre><code>def hyd_rdom_attach_to_mounted_comp(\n        self,\n        mounted_comp_id: str,\n        html: str\n):\n    \"\"\"\n    DOM operation: attaches compiled_comp to mounted_comp_id\n\n    Args:\n        mounted_comp_id: str - the ID of the previously mounted component\n        html: str - the HTML string to be attached to the mounted component\n    \"\"\"\n    foundNode = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{mounted_comp_id}\"]')\n    if foundNode:\n        foundNode.outerHTML = html\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_attach_to_root","title":"<code>hyd_rdom_attach_to_root(html)</code>","text":"<p>DOM operation: attaches compiled_comp to mounted_comp_id</p> <p>Parameters:</p> Name Type Description Default <code>html</code> <code>str</code> <p>str - the HTML string to be attached to the root element</p> required Source code in <code>zenaura/client/hydrator/real_dom_adapter.py</code> <pre><code>def hyd_rdom_attach_to_root(self, html : str) -&gt; None:\n    \"\"\"\n    DOM operation: attaches compiled_comp to mounted_comp_id\n\n    Args:\n        html: str - the HTML string to be attached to the root element\n    \"\"\"\n    document.getElementById(\"root\").innerHTML = html\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_create_element","title":"<code>hyd_rdom_create_element(virtual_node)</code>","text":"<p>DOM operation: creates html element and returns it as HTMLElement</p> <p>Parameters:</p> Name Type Description Default <code>virtual_node</code> <code>Node</code> <p>Node - the virtual node representing the element to be created</p> required <p>Returns:</p> Type Description <code>HTMLElement</code> <p>HTMLElement - the created HTML element</p> Source code in <code>zenaura/client/hydrator/real_dom_adapter.py</code> <pre><code>def hyd_rdom_create_element(self, virtual_node: Node) -&gt; HTMLElement:\n    \"\"\"\n    DOM operation: creates html element and returns it as HTMLElement\n\n    Args:\n        virtual_node: Node - the virtual node representing the element to be created\n\n    Returns:\n        HTMLElement - the created HTML element\n    \"\"\"\n    element = document.createElement(virtual_node.name)\n\n    return element\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_is_complete","title":"<code>hyd_rdom_is_complete()</code>","text":"<p>DOM operation: checks if real dom  is complete</p> <p>Returns:</p> Type Description <code>bool</code> <p>bool - True if the DOM is complete, False otherwise</p> Source code in <code>zenaura/client/hydrator/real_dom_adapter.py</code> <pre><code>def hyd_rdom_is_complete(self) -&gt; bool:\n    \"\"\"\n    DOM operation: checks if real dom  is complete\n\n    Returns:\n        bool - True if the DOM is complete, False otherwise\n    \"\"\"\n    return document.readyState == \"complete\"\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_is_content_loaded","title":"<code>hyd_rdom_is_content_loaded()</code>","text":"<p>DOM operation: checks if real dom  is content loaded</p> <p>Returns:</p> Type Description <code>bool</code> <p>bool - True if the DOM is content loaded, False otherwise</p> Source code in <code>zenaura/client/hydrator/real_dom_adapter.py</code> <pre><code>def hyd_rdom_is_content_loaded(self) -&gt; bool:\n    \"\"\"\n    DOM operation: checks if real dom  is content loaded\n\n    Returns:\n        bool - True if the DOM is content loaded, False otherwise\n    \"\"\"\n    return document.readyState == \"DOMContentLoaded\"\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_is_interactive","title":"<code>hyd_rdom_is_interactive()</code>","text":"<p>DOM operation: checks if real dom  is interactive</p> <p>Returns:</p> Type Description <code>bool</code> <p>bool - True if the DOM is interactive, False otherwise</p> Source code in <code>zenaura/client/hydrator/real_dom_adapter.py</code> <pre><code>def hyd_rdom_is_interactive(self) -&gt; bool:\n    \"\"\"\n    DOM operation: checks if real dom  is interactive\n\n    Returns:\n        bool - True if the DOM is interactive, False otherwise\n    \"\"\"\n    return document.readyState == \"interactive\"\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_is_loading","title":"<code>hyd_rdom_is_loading()</code>","text":"<p>DOM operation: checks if real dom  is complete</p> <p>Returns:</p> Type Description <code>bool</code> <p>bool - True if the DOM is complete, False otherwise</p> Source code in <code>zenaura/client/hydrator/real_dom_adapter.py</code> <pre><code>def hyd_rdom_is_loading(self) -&gt; bool:\n    \"\"\"\n    DOM operation: checks if real dom  is complete\n\n    Returns:\n        bool - True if the DOM is complete, False otherwise\n    \"\"\"\n    return document.readyState == \"load\"\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_remove_attribute","title":"<code>hyd_rdom_remove_attribute(mounted_comp_id, attribute_name)</code>","text":"<p>DOM operation: Removes an attribute from an HTML element.</p> <p>Parameters:</p> Name Type Description Default <code>mounted_comp_id</code> <code>str</code> <p>The ID of the element.</p> required <code>attribute_name</code> <code>str</code> <p>The name of the attribute to remove.</p> required Source code in <code>zenaura/client/hydrator/real_dom_adapter.py</code> <pre><code>def hyd_rdom_remove_attribute(self, mounted_comp_id: str, attribute_name: str) -&gt; None:\n    \"\"\"\n    DOM operation: Removes an attribute from an HTML element.\n\n    Args:\n        mounted_comp_id: The ID of the element.\n        attribute_name: The name of the attribute to remove.\n    \"\"\"\n    element = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{mounted_comp_id}\"]')\n    if element:\n        element.removeAttribute(attribute_name)\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_remove_child","title":"<code>hyd_rdom_remove_child(child_id)</code>","text":"<p>DOM operation: removes a child of an element</p> <p>Parameters:</p> Name Type Description Default <code>child_id</code> <code>str</code> <p>str - the ID of the child element to be removed</p> required Source code in <code>zenaura/client/hydrator/real_dom_adapter.py</code> <pre><code>def hyd_rdom_remove_child(self, child_id:str) -&gt; None:\n    \"\"\"\n    DOM operation: removes a child of an element\n\n    Args:\n        child_id: str - the ID of the child element to be removed\n    \"\"\"\n    child_node = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{child_id}\"]')\n    if child_node:\n        child_node.outerHTML = \"\"\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_remove_element","title":"<code>hyd_rdom_remove_element(mounted_comp_id)</code>","text":"<p>DOM operation: removes an element from the DOM</p> <p>Parameters:</p> Name Type Description Default <code>mounted_comp_id</code> <code>str</code> <p>str - the ID of the element to be removed</p> required Source code in <code>zenaura/client/hydrator/real_dom_adapter.py</code> <pre><code>def hyd_rdom_remove_element(self, mounted_comp_id: str) -&gt; None:\n    \"\"\"\n    DOM operation: removes an element from the DOM\n\n    Args:\n        mounted_comp_id: str - the ID of the element to be removed\n    \"\"\"\n    element = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{mounted_comp_id}\"]')\n    if element:\n        element.parentNode.removeChild(element)\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_replace_inner_text","title":"<code>hyd_rdom_replace_inner_text(mounted_comp_id, new_text)</code>","text":"<p>DOM operation: Replaces the inner text content of an element.</p> <p>Parameters:</p> Name Type Description Default <code>mounted_comp_id</code> <code>str</code> <p>str - the ID of the element to replace the text content of</p> required <code>new_text</code> <code>str</code> <p>str - the new text content</p> required Source code in <code>zenaura/client/hydrator/real_dom_adapter.py</code> <pre><code>def hyd_rdom_replace_inner_text(self, mounted_comp_id: str, new_text: str) -&gt; None:\n    \"\"\"\n    DOM operation: Replaces the inner text content of an element.\n\n    Args:\n        mounted_comp_id: str - the ID of the element to replace the text content of\n        new_text: str - the new text content\n    \"\"\"\n    element = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{mounted_comp_id}\"]')\n    if element:\n        element.textContent = new_text\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_set_attribute","title":"<code>hyd_rdom_set_attribute(mounted_comp_id, attribute)</code>","text":"<p>DOM operation: Sets attributes on an HTML element.</p> <p>Parameters:</p> Name Type Description Default <code>mounted_comp_id</code> <code>str</code> <p>The ID of the element to modify.</p> required <code>attributes</code> <p>A dictionary of attribute names and their values.</p> required Source code in <code>zenaura/client/hydrator/real_dom_adapter.py</code> <pre><code>def hyd_rdom_set_attribute(self, mounted_comp_id: str, attribute: Attribute) -&gt; None:\n    \"\"\"\n    DOM operation: Sets attributes on an HTML element.\n\n    Args:\n        mounted_comp_id: The ID of the element to modify.\n        attributes: A dictionary of attribute names and their values.\n    \"\"\"\n    element = document.querySelector(f'[{ZENAURA_DOM_ATTRIBUTE}=\"{mounted_comp_id}\"]')\n    if element:\n        element.setAttribute(attribute.key, attribute.value)\n</code></pre>"},{"location":"api/client/hydrator/hy_rdom/#zenaura.client.hydrator.real_dom_adapter.HydratorRealDomAdapter.hyd_rdom_toggle_pages_visibilty","title":"<code>hyd_rdom_toggle_pages_visibilty(previous_page, current_page)</code>","text":"<p>Toggles the visibility of the previous and current pages.</p> <p>Parameters:</p> Name Type Description Default <code>previous_page</code> <code>Page</code> <p>Page - the previously mounted page</p> required <code>current_page</code> <code>Page</code> <p>Page - the currently mounted page</p> required Source code in <code>zenaura/client/hydrator/real_dom_adapter.py</code> <pre><code>def hyd_rdom_toggle_pages_visibilty(self, previous_page : Page, current_page : Page ):\n    \"\"\"\n    Toggles the visibility of the previous and current pages.\n\n    Args:\n        previous_page: Page - the previously mounted page\n        current_page: Page - the currently mounted page\n    \"\"\"\n    p_page = document.querySelector(f'[data-zenaura=\"{previous_page.id}\"]')\n    if p_page:\n        p_page.hidden = True\n    curr_page = document.querySelector(f'[data-zenaura=\"{current_page.id}\"]')\n    if curr_page:\n        curr_page.hidden = False # Update the title\n</code></pre>"},{"location":"api/client/hydrator/hy_tasker/","title":"Tasker Adapter","text":""},{"location":"api/client/hydrator/hy_tasker/#zenaura.client.hydrator.tasker.HydratorTasker","title":"<code>HydratorTasker</code>","text":"<p>Manages tasks generated by the Zenaura diffing algorithm for updating both the real DOM and the virtual DOM.</p> <p>This class provides methods for:</p> <ul> <li>Creating and retrieving task queues for specific component IDs.</li> <li>Enqueuing tasks for components.</li> <li>Dequeuing tasks for components.</li> </ul> <p>Key Features:</p> <ul> <li>Efficient task management for real and virtual DOM updates.</li> <li>Thread-safe task queue operations.</li> <li>Automatic cleanup of empty task queues.</li> </ul> <p>Usage:</p> <ol> <li>Use <code>hyd_tsk_get_or_create_task_queue</code> to get or create a task queue for a specific component ID.</li> <li>Use <code>hyd_tsk_enqueue_task</code> to enqueue a task for a component.</li> <li>Use <code>hyd_tsk_dequeue_task</code> to dequeue a task for a component.</li> </ol> <p>Example:</p> <pre><code>tasker = HydratorTasker()\n\n# Get or create a task queue for component ID \"my-component\"\ntask_queue = tasker.hyd_tsk_get_or_create_task_queue(\"my-component\")\n\n# Enqueue a task for the component\ntask_queue.put_nowait(my_task)\n\n# Dequeue a task for the component\ntask = task_queue.get_nowait()\n\n# Execute the task\ntask()\n</code></pre> Source code in <code>zenaura/client/hydrator/tasker.py</code> <pre><code>class HydratorTasker:\n    \"\"\"\n    Manages tasks generated by the Zenaura diffing algorithm for updating both the real DOM and the virtual DOM.\n\n    This class provides methods for:\n\n    - Creating and retrieving task queues for specific component IDs.\n    - Enqueuing tasks for components.\n    - Dequeuing tasks for components.\n\n    **Key Features:**\n\n    - Efficient task management for real and virtual DOM updates.\n    - Thread-safe task queue operations.\n    - Automatic cleanup of empty task queues.\n\n    **Usage:**\n\n    1. Use `hyd_tsk_get_or_create_task_queue` to get or create a task queue for a specific component ID.\n    2. Use `hyd_tsk_enqueue_task` to enqueue a task for a component.\n    3. Use `hyd_tsk_dequeue_task` to dequeue a task for a component.\n\n    **Example:**\n\n    ```python\n    tasker = HydratorTasker()\n\n    # Get or create a task queue for component ID \"my-component\"\n    task_queue = tasker.hyd_tsk_get_or_create_task_queue(\"my-component\")\n\n    # Enqueue a task for the component\n    task_queue.put_nowait(my_task)\n\n    # Dequeue a task for the component\n    task = task_queue.get_nowait()\n\n    # Execute the task\n    task()\n    ```\n    \"\"\"\n\n    queue_lookup = defaultdict(lambda: None)\n\n    def __init__(self):\n        \"\"\"\n        Initializes the HydratorTasker instance.\n        \"\"\"\n        pass\n\n    def hyd_tsk_get_or_create_task_queue(self, component_id) -&gt; asyncio.Queue:\n        \"\"\"\n        Gets or creates a task queue for the specified component ID.\n\n        Args:\n            component_id (str): The ID of the component.\n\n        Returns:\n            asyncio.Queue: The task queue for the component.\n        \"\"\"\n        try:\n            if component_id not in self.queue_lookup:\n                self.queue_lookup[component_id] = asyncio.Queue()\n                return self.queue_lookup[component_id]\n            else:\n                return self.queue_lookup[component_id]\n        except KeyError:\n            return False\n\n    def hyd_tsk_enqueue_task(self, component_id, task):\n        \"\"\"\n        Enqueues a task for the specified component ID.\n\n        Args:\n            component_id (str): The ID of the component.\n            task (callable): The task to be enqueued.\n\n        Returns:\n            bool: True if the task was successfully enqueued, False otherwise.\n        \"\"\"\n        comp_queue = self.queue_lookup[component_id]\n        if not comp_queue:\n            return False \n        try:\n            comp_queue.put_nowait(task)\n            return True\n        except asyncio.QueueFull:\n            return False\n\n    async def hyd_tsk_do_nothing(self):\n        \"\"\"\n        A placeholder function used when a task queue is empty.\n        \"\"\"\n        return asyncio.Queue()\n\n    def hyd_tsk_dequeue_task(self, component_id):\n        \"\"\"\n        Dequeues a task for the specified component ID.\n\n        Args:\n            component_id (str): The ID of the component.\n\n        Returns:\n            callable: The dequeued task, or `hyd_tsk_do_nothing` if the queue is empty.\n        \"\"\"\n\n        comp_queue = self.queue_lookup[component_id]\n        if not comp_queue:\n            return self.hyd_tsk_do_nothing\n        try:\n            task = comp_queue.get_nowait()\n            return task\n        except asyncio.QueueEmpty:\n            # Clean up and return the placeholder function\n            self.queue_lookup[component_id] = asyncio.Queue()\n            return self.hyd_tsk_do_nothing\n</code></pre>"},{"location":"api/client/hydrator/hy_tasker/#zenaura.client.hydrator.tasker.HydratorTasker.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the HydratorTasker instance.</p> Source code in <code>zenaura/client/hydrator/tasker.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the HydratorTasker instance.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/client/hydrator/hy_tasker/#zenaura.client.hydrator.tasker.HydratorTasker.hyd_tsk_dequeue_task","title":"<code>hyd_tsk_dequeue_task(component_id)</code>","text":"<p>Dequeues a task for the specified component ID.</p> <p>Parameters:</p> Name Type Description Default <code>component_id</code> <code>str</code> <p>The ID of the component.</p> required <p>Returns:</p> Name Type Description <code>callable</code> <p>The dequeued task, or <code>hyd_tsk_do_nothing</code> if the queue is empty.</p> Source code in <code>zenaura/client/hydrator/tasker.py</code> <pre><code>def hyd_tsk_dequeue_task(self, component_id):\n    \"\"\"\n    Dequeues a task for the specified component ID.\n\n    Args:\n        component_id (str): The ID of the component.\n\n    Returns:\n        callable: The dequeued task, or `hyd_tsk_do_nothing` if the queue is empty.\n    \"\"\"\n\n    comp_queue = self.queue_lookup[component_id]\n    if not comp_queue:\n        return self.hyd_tsk_do_nothing\n    try:\n        task = comp_queue.get_nowait()\n        return task\n    except asyncio.QueueEmpty:\n        # Clean up and return the placeholder function\n        self.queue_lookup[component_id] = asyncio.Queue()\n        return self.hyd_tsk_do_nothing\n</code></pre>"},{"location":"api/client/hydrator/hy_tasker/#zenaura.client.hydrator.tasker.HydratorTasker.hyd_tsk_do_nothing","title":"<code>hyd_tsk_do_nothing()</code>  <code>async</code>","text":"<p>A placeholder function used when a task queue is empty.</p> Source code in <code>zenaura/client/hydrator/tasker.py</code> <pre><code>async def hyd_tsk_do_nothing(self):\n    \"\"\"\n    A placeholder function used when a task queue is empty.\n    \"\"\"\n    return asyncio.Queue()\n</code></pre>"},{"location":"api/client/hydrator/hy_tasker/#zenaura.client.hydrator.tasker.HydratorTasker.hyd_tsk_enqueue_task","title":"<code>hyd_tsk_enqueue_task(component_id, task)</code>","text":"<p>Enqueues a task for the specified component ID.</p> <p>Parameters:</p> Name Type Description Default <code>component_id</code> <code>str</code> <p>The ID of the component.</p> required <code>task</code> <code>callable</code> <p>The task to be enqueued.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the task was successfully enqueued, False otherwise.</p> Source code in <code>zenaura/client/hydrator/tasker.py</code> <pre><code>def hyd_tsk_enqueue_task(self, component_id, task):\n    \"\"\"\n    Enqueues a task for the specified component ID.\n\n    Args:\n        component_id (str): The ID of the component.\n        task (callable): The task to be enqueued.\n\n    Returns:\n        bool: True if the task was successfully enqueued, False otherwise.\n    \"\"\"\n    comp_queue = self.queue_lookup[component_id]\n    if not comp_queue:\n        return False \n    try:\n        comp_queue.put_nowait(task)\n        return True\n    except asyncio.QueueFull:\n        return False\n</code></pre>"},{"location":"api/client/hydrator/hy_tasker/#zenaura.client.hydrator.tasker.HydratorTasker.hyd_tsk_get_or_create_task_queue","title":"<code>hyd_tsk_get_or_create_task_queue(component_id)</code>","text":"<p>Gets or creates a task queue for the specified component ID.</p> <p>Parameters:</p> Name Type Description Default <code>component_id</code> <code>str</code> <p>The ID of the component.</p> required <p>Returns:</p> Type Description <code>Queue</code> <p>asyncio.Queue: The task queue for the component.</p> Source code in <code>zenaura/client/hydrator/tasker.py</code> <pre><code>def hyd_tsk_get_or_create_task_queue(self, component_id) -&gt; asyncio.Queue:\n    \"\"\"\n    Gets or creates a task queue for the specified component ID.\n\n    Args:\n        component_id (str): The ID of the component.\n\n    Returns:\n        asyncio.Queue: The task queue for the component.\n    \"\"\"\n    try:\n        if component_id not in self.queue_lookup:\n            self.queue_lookup[component_id] = asyncio.Queue()\n            return self.queue_lookup[component_id]\n        else:\n            return self.queue_lookup[component_id]\n    except KeyError:\n        return False\n</code></pre>"},{"location":"api/client/hydrator/hy_vdom/","title":"Virtual DOM Adapter","text":""},{"location":"api/client/hydrator/hy_vdom/#zenaura.client.hydrator.virtual_dom_adapter.HydratorVirtualDomAdapter","title":"<code>HydratorVirtualDomAdapter</code>","text":"<p>               Bases: <code>VDomLookupTable</code></p> <p>hyderator adapter for all virtual dom operations methods should start with: hyd_vdom_</p> Source code in <code>zenaura/client/hydrator/virtual_dom_adapter.py</code> <pre><code>class HydratorVirtualDomAdapter(\n    VDomLookupTable\n):\n    \"\"\"\n        hyderator adapter for all virtual dom operations\n        methods should start with:\n        hyd_vdom_\n    \"\"\"\n\n    def hyd_vdom_update(self, comp: Component) -&gt; None:\n        \"\"\"\n            virtual dom operation : updates virtual dom of component\n            args:\n                comp: Component\n        \"\"\"\n        self.zen_dom_table[comp.id] = comp.render()\n\n    def hyd_vdom_delete(self, comp: Component) -&gt; None:\n        \"\"\"\n            virtual dom operation : deletes virtual dom of component\n            args:\n                comp: Component\n        \"\"\"\n        del self.zen_dom_table[comp.id]\n\n    def hyd_vdom_update_with_new_render(self, comp: Component, new_node):\n        \"\"\"\n            update component with new node\n            args:\n                comp: Component\n                new_node: Node\n        \"\"\"\n        self.zen_dom_table[comp.id] = new_node\n</code></pre>"},{"location":"api/client/hydrator/hy_vdom/#zenaura.client.hydrator.virtual_dom_adapter.HydratorVirtualDomAdapter.hyd_vdom_delete","title":"<code>hyd_vdom_delete(comp)</code>","text":"<p>virtual dom operation : deletes virtual dom of component args:     comp: Component</p> Source code in <code>zenaura/client/hydrator/virtual_dom_adapter.py</code> <pre><code>def hyd_vdom_delete(self, comp: Component) -&gt; None:\n    \"\"\"\n        virtual dom operation : deletes virtual dom of component\n        args:\n            comp: Component\n    \"\"\"\n    del self.zen_dom_table[comp.id]\n</code></pre>"},{"location":"api/client/hydrator/hy_vdom/#zenaura.client.hydrator.virtual_dom_adapter.HydratorVirtualDomAdapter.hyd_vdom_update","title":"<code>hyd_vdom_update(comp)</code>","text":"<p>virtual dom operation : updates virtual dom of component args:     comp: Component</p> Source code in <code>zenaura/client/hydrator/virtual_dom_adapter.py</code> <pre><code>def hyd_vdom_update(self, comp: Component) -&gt; None:\n    \"\"\"\n        virtual dom operation : updates virtual dom of component\n        args:\n            comp: Component\n    \"\"\"\n    self.zen_dom_table[comp.id] = comp.render()\n</code></pre>"},{"location":"api/client/hydrator/hy_vdom/#zenaura.client.hydrator.virtual_dom_adapter.HydratorVirtualDomAdapter.hyd_vdom_update_with_new_render","title":"<code>hyd_vdom_update_with_new_render(comp, new_node)</code>","text":"<p>update component with new node args:     comp: Component     new_node: Node</p> Source code in <code>zenaura/client/hydrator/virtual_dom_adapter.py</code> <pre><code>def hyd_vdom_update_with_new_render(self, comp: Component, new_node):\n    \"\"\"\n        update component with new node\n        args:\n            comp: Component\n            new_node: Node\n    \"\"\"\n    self.zen_dom_table[comp.id] = new_node\n</code></pre>"},{"location":"api/client/hydrator/hydrator/","title":"Overview","text":""},{"location":"api/client/hydrator/hydrator/#zenaura.client.hydrator.hydrator.Hydrator","title":"<code>Hydrator</code>","text":"<p>               Bases: <code>HydratorVirtualDomAdapter</code>, <code>HydratorCompilerAdapter</code>, <code>HydratorRealDomAdapter</code>, <code>HydratorTasker</code></p> <p>Hydrator acts as the central communication hub between:</p> <ol> <li>Virtual DOM and Compiler:<ul> <li>Methods interacting with the compiler start with <code>hyd_comp_</code>, e.g., <code>hyd_comp_get_keyed_uuid</code>, <code>hyd_comp_compile_node</code>.</li> </ul> </li> <li>Virtual DOM:<ul> <li>Methods interacting with Zenaura's virtual DOM start with <code>hyd_vdom_</code>, e.g., <code>hyd_vdom_update</code>, <code>hyd_vdom_delete</code>.</li> </ul> </li> <li>DOM:<ul> <li>Methods interacting with the DOM start with <code>hyd_dom_</code>, e.g., <code>hyd_rdom_attach_to_root</code>.</li> </ul> </li> <li>Tasker:<ul> <li>Tasks for updating the DOM are created in the updater and dequeued during the render lifecycle, enabling asynchronous DOM updates.</li> </ul> </li> </ol> <p>Essentially, Hydrator bridges the gap between various components within the Zenaura framework, facilitating seamless communication and efficient DOM manipulation.</p> Source code in <code>zenaura/client/hydrator/hydrator.py</code> <pre><code>class Hydrator(\n    HydratorVirtualDomAdapter,\n    HydratorCompilerAdapter,\n    HydratorRealDomAdapter,\n    HydratorTasker\n):\n    \"\"\"\n    Hydrator acts as the central communication hub between:\n\n    1. **Virtual DOM and Compiler:**\n        - Methods interacting with the compiler start with `hyd_comp_`, e.g., `hyd_comp_get_keyed_uuid`, `hyd_comp_compile_node`.\n    2. **Virtual DOM:**\n        - Methods interacting with Zenaura's virtual DOM start with `hyd_vdom_`, e.g., `hyd_vdom_update`, `hyd_vdom_delete`.\n    3. **DOM:**\n        - Methods interacting with the DOM start with `hyd_dom_`, e.g., `hyd_rdom_attach_to_root`.\n    4. **Tasker:**\n        - Tasks for updating the DOM are created in the updater and dequeued during the render lifecycle, enabling asynchronous DOM updates.\n\n    Essentially, Hydrator bridges the gap between various components within the Zenaura framework, facilitating seamless communication and efficient DOM manipulation.\n    \"\"\"\n</code></pre>"},{"location":"api/client/hydrator/lookup/","title":"Lookup Table","text":""},{"location":"api/client/hydrator/lookup/#zenaura.client.hydrator.lookup.VDomLookupTable","title":"<code>VDomLookupTable</code>","text":"<p>VDomLookupTable:</p> <p>This class manages two lookup tables:</p> <ol> <li> <p>zen_dom_table:</p> <ul> <li>Optimizes general tree structure by storing each component's unique ID and its children with the <code>ZENAURA_DOM_ATTRIBUTE</code>.</li> <li>Provides efficient operations:<ul> <li>Searching for mounted component's previous state: O(1)</li> <li>Deleting unmounted components: O(1)</li> <li>Inserting mounted components: O(1)</li> </ul> </li> <li>Applies the same time complexity to tree structure operations:<ul> <li>Search: O(n)</li> <li>Insert: O(n)</li> <li>Delete: O(n)</li> <li>Update: O(n)</li> </ul> </li> <li>Enables efficient memory management by deleting all components when a page is unmounted.</li> </ul> </li> <li> <p>zenaura_prev_page_instance:</p> <ul> <li>Stores the previously mounted page instance.</li> <li>Leverages Zenaura's single-page mounting (per route path) for efficient memory management.</li> <li>When a new page is mounted:<ul> <li>Retrieves the previous page instance.</li> <li>Iterates over its components and deletes them from <code>zen_dom_table</code>.</li> </ul> </li> </ul> </li> </ol> Source code in <code>zenaura/client/hydrator/lookup.py</code> <pre><code>class VDomLookupTable:\n    \"\"\"\n        VDomLookupTable:\n\n        This class manages two lookup tables:\n\n        1. **zen_dom_table**:\n            - Optimizes general tree structure by storing each component's unique ID and its children with the `ZENAURA_DOM_ATTRIBUTE`.\n            - Provides efficient operations:\n                - Searching for mounted component's previous state: O(1)\n                - Deleting unmounted components: O(1)\n                - Inserting mounted components: O(1)\n            - Applies the same time complexity to tree structure operations:\n                - Search: O(n)\n                - Insert: O(n)\n                - Delete: O(n)\n                - Update: O(n)\n            - Enables efficient memory management by deleting all components when a page is unmounted.\n\n        2. **zenaura_prev_page_instance**:\n            - Stores the previously mounted page instance.\n            - Leverages Zenaura's single-page mounting (per route path) for efficient memory management.\n            - When a new page is mounted:\n                - Retrieves the previous page instance.\n                - Iterates over its components and deletes them from `zen_dom_table`.\n\n    \"\"\"\n    zen_dom_table = defaultdict(str)\n    prev_page_instance = None\n    zen_pre_compiled = defaultdict(str)\n</code></pre>"},{"location":"api/client/observer/observer/","title":"Observer","text":""},{"location":"api/client/observer/observer/#zenaura.client.observer.observer.Observer","title":"<code>Observer</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for observers that listen to changes in subjects.</p> <p>Observers are notified when a subject's state changes, allowing them to react accordingly. This pattern promotes loose coupling between subjects and observers, making the system more flexible and maintainable.</p> <p>Key Features:</p> <ul> <li>Loose Coupling: Observers are not directly dependent on the subject's implementation,    allowing for easier modifications and additions.</li> <li>Flexibility: Observers can be easily added or removed without affecting the subject.</li> <li>Maintainability: The separation of concerns makes the code easier to understand and maintain.</li> </ul> <p>Usage:</p> <ol> <li>Define concrete observer classes that inherit from <code>Observer</code>.</li> <li>Implement the <code>update</code> method in each concrete observer to specify the desired behavior when notified.</li> <li>Attach the observers to the subject using the subject's <code>attach</code> method.</li> <li>When the subject's state changes, it will call the <code>update</code> method of all attached observers.</li> </ol> <p>Example:</p> <pre><code>class Subject:\n    def __init__(self):\n        self._observers = []\n\n    def attach(self, observer):\n        self._observers.append(observer)\n\n    def notify(self, value):\n        for observer in self._observers:\n            observer.update(value)\n\nclass ConcreteObserver(Observer):\n    def update(self, value):\n        print(f\"Observer received value: {value}\")\n\n# Create a subject and an observer\nsubject = Subject()\nobserver = ConcreteObserver()\n\n# Attach the observer to the subject\nsubject.attach(observer)\n\n# Notify the observer with a value\nsubject.notify(\"Hello, world!\")\n</code></pre> <p>Additional Notes:</p> <ul> <li>The <code>update</code> method can receive any type of data, depending on the subject's implementation.</li> <li>Observers can choose to ignore notifications if they are not interested in the updated value.</li> <li>The subject can manage multiple observers and notify them individually or in groups.</li> </ul> Source code in <code>zenaura/client/observer/observer.py</code> <pre><code>class Observer(ABC):\n    \"\"\"\n    Abstract base class for observers that listen to changes in subjects.\n\n    Observers are notified when a subject's state changes, allowing them to react accordingly.\n    This pattern promotes loose coupling between subjects and observers, making the system more flexible and maintainable.\n\n    **Key Features:**\n\n    - **Loose Coupling:** Observers are not directly dependent on the subject's implementation, \n      allowing for easier modifications and additions.\n    - **Flexibility:** Observers can be easily added or removed without affecting the subject.\n    - **Maintainability:** The separation of concerns makes the code easier to understand and maintain.\n\n    **Usage:**\n\n    1. Define concrete observer classes that inherit from `Observer`.\n    2. Implement the `update` method in each concrete observer to specify the desired behavior when notified.\n    3. Attach the observers to the subject using the subject's `attach` method.\n    4. When the subject's state changes, it will call the `update` method of all attached observers.\n\n    **Example:**\n\n    ```python\n    class Subject:\n        def __init__(self):\n            self._observers = []\n\n        def attach(self, observer):\n            self._observers.append(observer)\n\n        def notify(self, value):\n            for observer in self._observers:\n                observer.update(value)\n\n    class ConcreteObserver(Observer):\n        def update(self, value):\n            print(f\"Observer received value: {value}\")\n\n    # Create a subject and an observer\n    subject = Subject()\n    observer = ConcreteObserver()\n\n    # Attach the observer to the subject\n    subject.attach(observer)\n\n    # Notify the observer with a value\n    subject.notify(\"Hello, world!\")\n    ```\n\n    **Additional Notes:**\n\n    - The `update` method can receive any type of data, depending on the subject's implementation.\n    - Observers can choose to ignore notifications if they are not interested in the updated value.\n    - The subject can manage multiple observers and notify them individually or in groups.\n    \"\"\"\n\n    @abstractmethod\n    def update(self, value):\n        \"\"\"\n        Update method to be implemented by concrete observers.\n\n        This method is called by the subject when its state changes. The observer can use the provided value\n        to perform any necessary actions, such as updating its own state or triggering other events.\n\n        Parameters:\n        value (dict): The updated value from the subject.\n\n        Returns:\n        None\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/client/observer/observer/#zenaura.client.observer.observer.Observer.update","title":"<code>update(value)</code>  <code>abstractmethod</code>","text":"<p>Update method to be implemented by concrete observers.</p> <p>This method is called by the subject when its state changes. The observer can use the provided value to perform any necessary actions, such as updating its own state or triggering other events.</p> <p>Parameters: value (dict): The updated value from the subject.</p> <p>Returns: None</p> Source code in <code>zenaura/client/observer/observer.py</code> <pre><code>@abstractmethod\ndef update(self, value):\n    \"\"\"\n    Update method to be implemented by concrete observers.\n\n    This method is called by the subject when its state changes. The observer can use the provided value\n    to perform any necessary actions, such as updating its own state or triggering other events.\n\n    Parameters:\n    value (dict): The updated value from the subject.\n\n    Returns:\n    None\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/client/observer/subject/","title":"Subject","text":""},{"location":"api/client/observer/subject/#zenaura.client.observer.subject.Subject","title":"<code>Subject</code>","text":"<p>Create subjects for components to communicate on.</p> <p>A subject is an entity that maintains a state and notifies its observers when the state changes. Observers can be any object that implements the <code>Observer</code> interface.</p> <p>Key Features:</p> <ul> <li>State Management: Subjects maintain their own state and provide access to it through the <code>state</code> property.</li> <li>Observer Management: Subjects manage a list of attached observers and notify them when the state changes.</li> <li>Loose Coupling: Subjects are not directly dependent on the implementation of their observers,    promoting flexibility and maintainability.</li> </ul> <p>Usage:</p> <ol> <li>Create a subject instance.</li> <li>Attach observers to the subject using the <code>attach</code> method.</li> <li>Modify the subject's state using the <code>state</code> property.</li> <li>The subject will automatically notify all attached observers when the state changes.</li> </ol> <p>Example:</p> <pre><code>class ConcreteSubject(Subject):\n    def __init__(self, initial_state):\n        super().__init__()\n        self._state = initial_state\n\n    def do_something(self):\n        # Modify the subject's state\n        self.state = {\"key\": \"value\"}\n\n# Create a subject and an observer\nsubject = ConcreteSubject({\"initial\": \"value\"})\nobserver = Observer()\n\n# Attach the observer to the subject\nsubject.attach(observer)\n\n# Modify the subject's state\nsubject.do_something()\n</code></pre> <p>Additional Notes:</p> <ul> <li>The <code>state</code> property can be any type of data, depending on the subject's implementation.</li> <li>Observers can choose to ignore notifications if they are not interested in the updated state.</li> <li>The subject can manage multiple observers and notify them individually or in groups.</li> </ul> Source code in <code>zenaura/client/observer/subject.py</code> <pre><code>class Subject:\n    \"\"\"\n    Create subjects for components to communicate on.\n\n    A subject is an entity that maintains a state and notifies its observers when the state changes.\n    Observers can be any object that implements the `Observer` interface.\n\n    **Key Features:**\n\n    - **State Management:** Subjects maintain their own state and provide access to it through the `state` property.\n    - **Observer Management:** Subjects manage a list of attached observers and notify them when the state changes.\n    - **Loose Coupling:** Subjects are not directly dependent on the implementation of their observers, \n      promoting flexibility and maintainability.\n\n    **Usage:**\n\n    1. Create a subject instance.\n    2. Attach observers to the subject using the `attach` method.\n    3. Modify the subject's state using the `state` property.\n    4. The subject will automatically notify all attached observers when the state changes.\n\n    **Example:**\n\n    ```python\n    class ConcreteSubject(Subject):\n        def __init__(self, initial_state):\n            super().__init__()\n            self._state = initial_state\n\n        def do_something(self):\n            # Modify the subject's state\n            self.state = {\"key\": \"value\"}\n\n    # Create a subject and an observer\n    subject = ConcreteSubject({\"initial\": \"value\"})\n    observer = Observer()\n\n    # Attach the observer to the subject\n    subject.attach(observer)\n\n    # Modify the subject's state\n    subject.do_something()\n    ```\n\n    **Additional Notes:**\n\n    - The `state` property can be any type of data, depending on the subject's implementation.\n    - Observers can choose to ignore notifications if they are not interested in the updated state.\n    - The subject can manage multiple observers and notify them individually or in groups.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize a new Subject.\n\n        Parameters:\n        None\n\n        Returns:\n        None\n        \"\"\"\n        self._observers = set()\n        self._state = {}\n\n    def attach(self, observer):\n        \"\"\"\n        Attach an observer to the subject.\n\n        Parameters:\n        observer (Observer): The observer to attach.\n\n        Returns:\n        None\n        \"\"\"\n        self._observers.add(observer)\n\n    def detach(self, observer):\n        \"\"\"\n        Detach an observer from the subject.\n\n        Parameters:\n        observer (Observer): The observer to detach.\n\n        Returns:\n        None\n        \"\"\"\n        self._observers.discard(observer)\n\n    def notify(self):\n        \"\"\"\n        Notify all attached observers.\n\n        Parameters:\n        None\n\n        Returns:\n        None\n        \"\"\"\n        for observer in self._observers:\n            observer.update(self._state)\n\n    @property\n    def state(self):\n        \"\"\"\n        Get the state of the subject.\n\n        Parameters:\n        None\n\n        Returns:\n        dict: The state of the subject.\n        \"\"\"\n        return self._state\n\n    @state.setter\n    def state(self, new_value):\n        \"\"\"\n        Set the state of the subject and notify observers.\n\n        Parameters:\n        new_value (dict): The new state of the subject.\n\n        Returns:\n        None\n        \"\"\"\n        self._state = new_value\n        self.notify()\n</code></pre>"},{"location":"api/client/observer/subject/#zenaura.client.observer.subject.Subject.state","title":"<code>state</code>  <code>property</code> <code>writable</code>","text":"<p>Get the state of the subject.</p> <p>Parameters: None</p> <p>Returns: dict: The state of the subject.</p>"},{"location":"api/client/observer/subject/#zenaura.client.observer.subject.Subject.__init__","title":"<code>__init__()</code>","text":"<p>Initialize a new Subject.</p> <p>Parameters: None</p> <p>Returns: None</p> Source code in <code>zenaura/client/observer/subject.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initialize a new Subject.\n\n    Parameters:\n    None\n\n    Returns:\n    None\n    \"\"\"\n    self._observers = set()\n    self._state = {}\n</code></pre>"},{"location":"api/client/observer/subject/#zenaura.client.observer.subject.Subject.attach","title":"<code>attach(observer)</code>","text":"<p>Attach an observer to the subject.</p> <p>Parameters: observer (Observer): The observer to attach.</p> <p>Returns: None</p> Source code in <code>zenaura/client/observer/subject.py</code> <pre><code>def attach(self, observer):\n    \"\"\"\n    Attach an observer to the subject.\n\n    Parameters:\n    observer (Observer): The observer to attach.\n\n    Returns:\n    None\n    \"\"\"\n    self._observers.add(observer)\n</code></pre>"},{"location":"api/client/observer/subject/#zenaura.client.observer.subject.Subject.detach","title":"<code>detach(observer)</code>","text":"<p>Detach an observer from the subject.</p> <p>Parameters: observer (Observer): The observer to detach.</p> <p>Returns: None</p> Source code in <code>zenaura/client/observer/subject.py</code> <pre><code>def detach(self, observer):\n    \"\"\"\n    Detach an observer from the subject.\n\n    Parameters:\n    observer (Observer): The observer to detach.\n\n    Returns:\n    None\n    \"\"\"\n    self._observers.discard(observer)\n</code></pre>"},{"location":"api/client/observer/subject/#zenaura.client.observer.subject.Subject.notify","title":"<code>notify()</code>","text":"<p>Notify all attached observers.</p> <p>Parameters: None</p> <p>Returns: None</p> Source code in <code>zenaura/client/observer/subject.py</code> <pre><code>def notify(self):\n    \"\"\"\n    Notify all attached observers.\n\n    Parameters:\n    None\n\n    Returns:\n    None\n    \"\"\"\n    for observer in self._observers:\n        observer.update(self._state)\n</code></pre>"},{"location":"api/client/tags/attribute/","title":"Attribute","text":""},{"location":"api/client/tags/attribute/#zenaura.client.tags.attribute.Attribute","title":"<code>Attribute</code>","text":"<p>Represents a key-value pair used for tagging entities.</p> <p>Attributes:</p> Name Type Description <code>key</code> <code>str</code> <p>The key of the attribute.</p> <code>value</code> <code>str</code> <p>The value of the attribute.</p> <p>Methods:</p> Name Description <code>to_dict</code> <p>Converts the attribute to a dictionary representation.</p> Source code in <code>zenaura/client/tags/attribute.py</code> <pre><code>class Attribute:\n    \"\"\"\n    Represents a key-value pair used for tagging entities.\n\n    Attributes:\n        key (str): The key of the attribute.\n        value (str): The value of the attribute.\n\n    Methods:\n        to_dict(): Converts the attribute to a dictionary representation.\n    \"\"\"\n\n    def __init__(self, key, value):\n        \"\"\"\n        Initializes an Attribute object with the given key and value.\n\n        Args:\n            key (str): The key of the attribute.\n            value (str): The value of the attribute.\n        \"\"\"\n        self.key = key\n        self.value = value\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Returns a dictionary representation of the attribute.\n\n        Returns:\n            dict: A dictionary containing the key and value of the attribute.\n        \"\"\"\n        return {\n            \"key\": self.key,\n            \"value\": self.value\n        }\n</code></pre>"},{"location":"api/client/tags/attribute/#zenaura.client.tags.attribute.Attribute.__init__","title":"<code>__init__(key, value)</code>","text":"<p>Initializes an Attribute object with the given key and value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the attribute.</p> required <code>value</code> <code>str</code> <p>The value of the attribute.</p> required Source code in <code>zenaura/client/tags/attribute.py</code> <pre><code>def __init__(self, key, value):\n    \"\"\"\n    Initializes an Attribute object with the given key and value.\n\n    Args:\n        key (str): The key of the attribute.\n        value (str): The value of the attribute.\n    \"\"\"\n    self.key = key\n    self.value = value\n</code></pre>"},{"location":"api/client/tags/attribute/#zenaura.client.tags.attribute.Attribute.to_dict","title":"<code>to_dict()</code>","text":"<p>Returns a dictionary representation of the attribute.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the key and value of the attribute.</p> Source code in <code>zenaura/client/tags/attribute.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Returns a dictionary representation of the attribute.\n\n    Returns:\n        dict: A dictionary containing the key and value of the attribute.\n    \"\"\"\n    return {\n        \"key\": self.key,\n        \"value\": self.value\n    }\n</code></pre>"},{"location":"api/client/tags/builder/","title":"Builder","text":""},{"location":"api/client/tags/builder/#zenaura.client.tags.builder.Builder","title":"<code>Builder</code>","text":"<p>A builder class for constructing HTML tags.</p> <p>This class provides a fluent interface for creating HTML tags with attributes, children, and styles. It simplifies the process of building complex HTML structures.</p> <p>Attributes:</p> Name Type Description <code>node</code> <code>Node</code> <p>The root node of the tag being built.</p> Source code in <code>zenaura/client/tags/builder.py</code> <pre><code>class Builder:\n    \"\"\"\n    A builder class for constructing HTML tags.\n\n    This class provides a fluent interface for creating HTML tags with attributes,\n    children, and styles. It simplifies the process of building complex HTML structures.\n\n    Attributes:\n        node (Node): The root node of the tag being built.\n    \"\"\"\n\n    def __init__(self, name: str = \"div\") -&gt; None:\n        \"\"\"\n        Initializes a Builder object with the given tag name.\n\n        Args:\n            name (str, optional): The name of the tag. Defaults to \"div\".\n        \"\"\"\n        self.node = Node(name)\n\n    def with_attributes(self, **kwargs) -&gt; \"Builder\":\n        \"\"\"\n        Adds attributes to the tag.\n\n        Args:\n            **kwargs: Key-value pairs of attributes.\n\n        Returns:\n            Builder: The Builder object.\n        \"\"\"\n        for key, value in kwargs.items():\n            self.with_attribute(key, value)\n        return self\n\n    def with_children(self, *children) -&gt; \"Builder\":\n        \"\"\"\n        Adds child nodes to the tag.\n\n        Args:\n            *children: List of child nodes.\n\n        Returns:\n            Builder: The Builder object.\n        \"\"\"\n        for child in children:\n            self.with_child(child)\n        return self\n\n    def with_attribute(self, key: str, value: any) -&gt; \"Builder\":\n        \"\"\"\n        Adds an attribute to the tag.\n\n        Args:\n            key (str): The key of the attribute.\n            value: The value of the attribute.\n\n        Returns:\n            Builder: The Builder object.\n        \"\"\"\n        self.node.attributes.append(Attribute(key, value))\n        return self\n\n    def with_child(self, child: Node) -&gt; \"Builder\":\n        \"\"\"\n        Adds a child node to the tag.\n\n        Args:\n            child (Node): The child node to be added.\n\n        Returns:\n            Builder: The Builder object.\n        \"\"\"\n        self.node.append_child(child)\n        return self\n\n    def with_styles(self, styles: dict) -&gt; \"Builder\":\n        \"\"\"\n        Adds styles to the tag.\n\n        Args:\n            styles (dict): Dictionary of styles.\n\n        Returns:\n            Builder: The Builder object.\n        \"\"\"\n        style_str = \";\".join([f\"{k}:{v}\" for k, v in styles.items()])\n        self.node.attributes.append(Attribute(\"style\", style_str))\n        return self\n\n    def with_classes(self, *class_names: str) -&gt; \"Builder\":\n        \"\"\"\n        Adds multiple class names to the element.\n\n        Args:\n            *class_names (str): Variable number of class names.\n\n        Returns:\n            Builder: The Builder object.\n        \"\"\"\n        for class_name in class_names:\n            self.with_class(class_name)\n        return self\n\n    def with_class(self, class_name: str) -&gt; \"Builder\":\n        \"\"\"\n        Adds a single class name to the element.\n\n        Args:\n            class_name (str): The class name to be added.\n\n        Returns:\n            Builder: The Builder object.\n        \"\"\"\n        for i in self.node.attributes:\n            if i.key == \"class\":\n                if class_name not in i.value:\n                    i.value = i.value + \" \" + class_name\n                    return self\n        self.node.attributes.append(Attribute(\"class\", class_name))\n\n        return self\n\n    def with_class_if(self, class_name: str, condition: bool) -&gt; \"Builder\":\n        \"\"\"\n        Adds a class name to the element if the condition is True.\n        If the condition is False, the class is not added.\n\n        args:\n            class_name (str): The class name to be added.\n            condition (bool): The condition for adding the class.\n        \"\"\"\n        self.with_class(class_name) if condition else None\n        return self\n\n    def with_attribute_if(self, key: str, value: any, condition: bool) -&gt; \"Builder\":\n        \"\"\"\n            adds attribute if condition is true\n            args:\n            key (str): The key of the attribute.\n            value: The value of the attribute.\n            condition (bool): The condition for adding the attribute.\n        \"\"\"\n        self.with_attribute(key, value) if condition else None\n        return self\n\n    def with_child_if(self, child: Node, condition: bool) -&gt; \"Builder\":\n        \"\"\"\n            adds child if condition is true\n            args:\n            child (Node): The child node to be added.\n            condition (bool): The condition for adding the child.\n        \"\"\"\n        self.with_child(child) if condition else None\n        return self\n\n    def with_text(self, text: str):\n        \"\"\"\n            add text node\n        \"\"\"\n        self.with_child(Node(text=text))\n        return self\n\n    def build(self) -&gt; Node:\n        \"\"\"\n        Builds and returns the node.\n\n        Returns:\n            Node: The built node.\n        \"\"\"\n        return self.node\n</code></pre>"},{"location":"api/client/tags/builder/#zenaura.client.tags.builder.Builder.__init__","title":"<code>__init__(name='div')</code>","text":"<p>Initializes a Builder object with the given tag name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the tag. Defaults to \"div\".</p> <code>'div'</code> Source code in <code>zenaura/client/tags/builder.py</code> <pre><code>def __init__(self, name: str = \"div\") -&gt; None:\n    \"\"\"\n    Initializes a Builder object with the given tag name.\n\n    Args:\n        name (str, optional): The name of the tag. Defaults to \"div\".\n    \"\"\"\n    self.node = Node(name)\n</code></pre>"},{"location":"api/client/tags/builder/#zenaura.client.tags.builder.Builder.build","title":"<code>build()</code>","text":"<p>Builds and returns the node.</p> <p>Returns:</p> Name Type Description <code>Node</code> <code>Node</code> <p>The built node.</p> Source code in <code>zenaura/client/tags/builder.py</code> <pre><code>def build(self) -&gt; Node:\n    \"\"\"\n    Builds and returns the node.\n\n    Returns:\n        Node: The built node.\n    \"\"\"\n    return self.node\n</code></pre>"},{"location":"api/client/tags/builder/#zenaura.client.tags.builder.Builder.with_attribute","title":"<code>with_attribute(key, value)</code>","text":"<p>Adds an attribute to the tag.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the attribute.</p> required <code>value</code> <code>any</code> <p>The value of the attribute.</p> required <p>Returns:</p> Name Type Description <code>Builder</code> <code>Builder</code> <p>The Builder object.</p> Source code in <code>zenaura/client/tags/builder.py</code> <pre><code>def with_attribute(self, key: str, value: any) -&gt; \"Builder\":\n    \"\"\"\n    Adds an attribute to the tag.\n\n    Args:\n        key (str): The key of the attribute.\n        value: The value of the attribute.\n\n    Returns:\n        Builder: The Builder object.\n    \"\"\"\n    self.node.attributes.append(Attribute(key, value))\n    return self\n</code></pre>"},{"location":"api/client/tags/builder/#zenaura.client.tags.builder.Builder.with_attribute_if","title":"<code>with_attribute_if(key, value, condition)</code>","text":"<p>adds attribute if condition is true args: key (str): The key of the attribute. value: The value of the attribute. condition (bool): The condition for adding the attribute.</p> Source code in <code>zenaura/client/tags/builder.py</code> <pre><code>def with_attribute_if(self, key: str, value: any, condition: bool) -&gt; \"Builder\":\n    \"\"\"\n        adds attribute if condition is true\n        args:\n        key (str): The key of the attribute.\n        value: The value of the attribute.\n        condition (bool): The condition for adding the attribute.\n    \"\"\"\n    self.with_attribute(key, value) if condition else None\n    return self\n</code></pre>"},{"location":"api/client/tags/builder/#zenaura.client.tags.builder.Builder.with_attributes","title":"<code>with_attributes(**kwargs)</code>","text":"<p>Adds attributes to the tag.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Key-value pairs of attributes.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Builder</code> <code>Builder</code> <p>The Builder object.</p> Source code in <code>zenaura/client/tags/builder.py</code> <pre><code>def with_attributes(self, **kwargs) -&gt; \"Builder\":\n    \"\"\"\n    Adds attributes to the tag.\n\n    Args:\n        **kwargs: Key-value pairs of attributes.\n\n    Returns:\n        Builder: The Builder object.\n    \"\"\"\n    for key, value in kwargs.items():\n        self.with_attribute(key, value)\n    return self\n</code></pre>"},{"location":"api/client/tags/builder/#zenaura.client.tags.builder.Builder.with_child","title":"<code>with_child(child)</code>","text":"<p>Adds a child node to the tag.</p> <p>Parameters:</p> Name Type Description Default <code>child</code> <code>Node</code> <p>The child node to be added.</p> required <p>Returns:</p> Name Type Description <code>Builder</code> <code>Builder</code> <p>The Builder object.</p> Source code in <code>zenaura/client/tags/builder.py</code> <pre><code>def with_child(self, child: Node) -&gt; \"Builder\":\n    \"\"\"\n    Adds a child node to the tag.\n\n    Args:\n        child (Node): The child node to be added.\n\n    Returns:\n        Builder: The Builder object.\n    \"\"\"\n    self.node.append_child(child)\n    return self\n</code></pre>"},{"location":"api/client/tags/builder/#zenaura.client.tags.builder.Builder.with_child_if","title":"<code>with_child_if(child, condition)</code>","text":"<p>adds child if condition is true args: child (Node): The child node to be added. condition (bool): The condition for adding the child.</p> Source code in <code>zenaura/client/tags/builder.py</code> <pre><code>def with_child_if(self, child: Node, condition: bool) -&gt; \"Builder\":\n    \"\"\"\n        adds child if condition is true\n        args:\n        child (Node): The child node to be added.\n        condition (bool): The condition for adding the child.\n    \"\"\"\n    self.with_child(child) if condition else None\n    return self\n</code></pre>"},{"location":"api/client/tags/builder/#zenaura.client.tags.builder.Builder.with_children","title":"<code>with_children(*children)</code>","text":"<p>Adds child nodes to the tag.</p> <p>Parameters:</p> Name Type Description Default <code>*children</code> <p>List of child nodes.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Builder</code> <code>Builder</code> <p>The Builder object.</p> Source code in <code>zenaura/client/tags/builder.py</code> <pre><code>def with_children(self, *children) -&gt; \"Builder\":\n    \"\"\"\n    Adds child nodes to the tag.\n\n    Args:\n        *children: List of child nodes.\n\n    Returns:\n        Builder: The Builder object.\n    \"\"\"\n    for child in children:\n        self.with_child(child)\n    return self\n</code></pre>"},{"location":"api/client/tags/builder/#zenaura.client.tags.builder.Builder.with_class","title":"<code>with_class(class_name)</code>","text":"<p>Adds a single class name to the element.</p> <p>Parameters:</p> Name Type Description Default <code>class_name</code> <code>str</code> <p>The class name to be added.</p> required <p>Returns:</p> Name Type Description <code>Builder</code> <code>Builder</code> <p>The Builder object.</p> Source code in <code>zenaura/client/tags/builder.py</code> <pre><code>def with_class(self, class_name: str) -&gt; \"Builder\":\n    \"\"\"\n    Adds a single class name to the element.\n\n    Args:\n        class_name (str): The class name to be added.\n\n    Returns:\n        Builder: The Builder object.\n    \"\"\"\n    for i in self.node.attributes:\n        if i.key == \"class\":\n            if class_name not in i.value:\n                i.value = i.value + \" \" + class_name\n                return self\n    self.node.attributes.append(Attribute(\"class\", class_name))\n\n    return self\n</code></pre>"},{"location":"api/client/tags/builder/#zenaura.client.tags.builder.Builder.with_class_if","title":"<code>with_class_if(class_name, condition)</code>","text":"<p>Adds a class name to the element if the condition is True. If the condition is False, the class is not added.</p> <p>Parameters:</p> Name Type Description Default <code>class_name</code> <code>str</code> <p>The class name to be added.</p> required <code>condition</code> <code>bool</code> <p>The condition for adding the class.</p> required Source code in <code>zenaura/client/tags/builder.py</code> <pre><code>def with_class_if(self, class_name: str, condition: bool) -&gt; \"Builder\":\n    \"\"\"\n    Adds a class name to the element if the condition is True.\n    If the condition is False, the class is not added.\n\n    args:\n        class_name (str): The class name to be added.\n        condition (bool): The condition for adding the class.\n    \"\"\"\n    self.with_class(class_name) if condition else None\n    return self\n</code></pre>"},{"location":"api/client/tags/builder/#zenaura.client.tags.builder.Builder.with_classes","title":"<code>with_classes(*class_names)</code>","text":"<p>Adds multiple class names to the element.</p> <p>Parameters:</p> Name Type Description Default <code>*class_names</code> <code>str</code> <p>Variable number of class names.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Builder</code> <code>Builder</code> <p>The Builder object.</p> Source code in <code>zenaura/client/tags/builder.py</code> <pre><code>def with_classes(self, *class_names: str) -&gt; \"Builder\":\n    \"\"\"\n    Adds multiple class names to the element.\n\n    Args:\n        *class_names (str): Variable number of class names.\n\n    Returns:\n        Builder: The Builder object.\n    \"\"\"\n    for class_name in class_names:\n        self.with_class(class_name)\n    return self\n</code></pre>"},{"location":"api/client/tags/builder/#zenaura.client.tags.builder.Builder.with_styles","title":"<code>with_styles(styles)</code>","text":"<p>Adds styles to the tag.</p> <p>Parameters:</p> Name Type Description Default <code>styles</code> <code>dict</code> <p>Dictionary of styles.</p> required <p>Returns:</p> Name Type Description <code>Builder</code> <code>Builder</code> <p>The Builder object.</p> Source code in <code>zenaura/client/tags/builder.py</code> <pre><code>def with_styles(self, styles: dict) -&gt; \"Builder\":\n    \"\"\"\n    Adds styles to the tag.\n\n    Args:\n        styles (dict): Dictionary of styles.\n\n    Returns:\n        Builder: The Builder object.\n    \"\"\"\n    style_str = \";\".join([f\"{k}:{v}\" for k, v in styles.items()])\n    self.node.attributes.append(Attribute(\"style\", style_str))\n    return self\n</code></pre>"},{"location":"api/client/tags/builder/#zenaura.client.tags.builder.Builder.with_text","title":"<code>with_text(text)</code>","text":"<p>add text node</p> Source code in <code>zenaura/client/tags/builder.py</code> <pre><code>def with_text(self, text: str):\n    \"\"\"\n        add text node\n    \"\"\"\n    self.with_child(Node(text=text))\n    return self\n</code></pre>"},{"location":"api/client/tags/html/","title":"Html","text":""},{"location":"api/client/tags/html/#zenaura.client.tags.html.HTMLElement","title":"<code>HTMLElement</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class representing an HTML element.</p> <p>This class defines the common interface for all HTML elements, providing methods for manipulating child elements.</p> <p>Methods:</p> Name Description <code>appendChild</code> <p>HTMLElement) -&gt; None: Appends a child element to the current element.</p> <code>removeChild</code> <p>HTMLElement) -&gt; None: Removes a child element from the current element.</p> Source code in <code>zenaura/client/tags/html.py</code> <pre><code>class HTMLElement(ABC):\n    \"\"\"\n    Abstract base class representing an HTML element.\n\n    This class defines the common interface for all HTML elements,\n    providing methods for manipulating child elements.\n\n    Attributes:\n        None\n\n    Methods:\n        appendChild(child: HTMLElement) -&gt; None:\n            Appends a child element to the current element.\n        removeChild(child: HTMLElement) -&gt; None:\n            Removes a child element from the current element.\n    \"\"\"\n\n    @abstractmethod\n    def appendChild(self, child: \"HTMLElement\") -&gt; None:\n        \"\"\"\n        Appends a child element to the current element.\n\n        Args:\n            child: The child element to be appended.\n\n        Raises:\n            TypeError: If the provided child is not an instance of `HTMLElement`.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def removeChild(self, child: \"HTMLElement\") -&gt; None:\n        \"\"\"\n        Removes a child element from the current element.\n\n        Args:\n            child: The child element to be removed.\n\n        Raises:\n            TypeError: If the provided child is not an instance of `HTMLElement`.\n            ValueError: If the provided child is not a child of the current element.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/client/tags/html/#zenaura.client.tags.html.HTMLElement.appendChild","title":"<code>appendChild(child)</code>  <code>abstractmethod</code>","text":"<p>Appends a child element to the current element.</p> <p>Parameters:</p> Name Type Description Default <code>child</code> <code>HTMLElement</code> <p>The child element to be appended.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the provided child is not an instance of <code>HTMLElement</code>.</p> Source code in <code>zenaura/client/tags/html.py</code> <pre><code>@abstractmethod\ndef appendChild(self, child: \"HTMLElement\") -&gt; None:\n    \"\"\"\n    Appends a child element to the current element.\n\n    Args:\n        child: The child element to be appended.\n\n    Raises:\n        TypeError: If the provided child is not an instance of `HTMLElement`.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/client/tags/html/#zenaura.client.tags.html.HTMLElement.removeChild","title":"<code>removeChild(child)</code>  <code>abstractmethod</code>","text":"<p>Removes a child element from the current element.</p> <p>Parameters:</p> Name Type Description Default <code>child</code> <code>HTMLElement</code> <p>The child element to be removed.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If the provided child is not an instance of <code>HTMLElement</code>.</p> <code>ValueError</code> <p>If the provided child is not a child of the current element.</p> Source code in <code>zenaura/client/tags/html.py</code> <pre><code>@abstractmethod\ndef removeChild(self, child: \"HTMLElement\") -&gt; None:\n    \"\"\"\n    Removes a child element from the current element.\n\n    Args:\n        child: The child element to be removed.\n\n    Raises:\n        TypeError: If the provided child is not an instance of `HTMLElement`.\n        ValueError: If the provided child is not a child of the current element.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/client/tags/node/","title":"Node","text":""},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node","title":"<code>Node</code>","text":"Source code in <code>zenaura/client/tags/node.py</code> <pre><code>class Node:\n    def __init__(\n            self,name : str = None, \n            children: Optional[List[\"Node\"]]=None, \n            attributes : Optional[List[Attribute]]=None,\n            text: str = None,\n            ):\n        \"\"\"\n        Represents an HTML element with attributes, children, and text content.\n\n        Attributes:\n            name (str): The tag name of the element.\n            children (list of Node): The child elements of this node.\n            attributes (list of Attribute): The attributes of this node.\n            text (str, optional): The text content of this node.\n            nodeId (str): A unique identifier for this node.\n            is_leaf (bool): Whether this node has no children.\n            is_text_node (bool): Whether this node represents text content.\n            level (int): The depth of this node in the tree.\n            key (int): A unique identifier for this node within its level.\n            path (str): The path from the root to this node.\n        \"\"\"\n        self._parent = None\n\n        # calculated properties\n        self._level = 0\n        self._key = 0 \n        self._is_leaf = True\n        self._path = \"\"\n\n        self.name = name\n        self._children = children if children else []\n        self.attributes = [] if attributes is None else attributes\n        self.nodeId = uuid.uuid4().hex\n        self.text = text        \n        # calculated proerty depends on children, text\n        self._is_text_node = isinstance(self.text, str)\n        update_root_properties(self)\n\n    @property\n    def level(self):\n        return self._level\n\n    @level.setter\n    def level(self, new_level):\n        self._level = new_level\n\n    @property\n    def is_leaf(self):\n        return self._is_leaf\n\n    @is_leaf.setter\n    def is_leaf(self, new_is_leaf):\n        self._is_leaf = new_is_leaf\n\n    @property\n    def key(self):\n        return self._key\n\n    @key.setter\n    def key(self, new_key):\n        self._key = new_key\n\n    @property\n    def path(self):\n        return self._path\n\n    @path.setter\n    def path(self, new_path):\n        self._path = new_path\n\n    @property\n    def is_text_node(self):\n        return self._is_text_node\n\n    @is_text_node.setter\n    def is_text_node(self, new_is_text_node):\n        self._is_text_node = new_is_text_node\n\n    @property\n    def parent(self):\n        \"\"\"Read-only property referencing the node's parent.\"\"\"\n        return self._parent\n\n    @parent.setter\n    def parent(self, new_parent):\n        self._parent = new_parent\n\n    @property\n    def children(self):\n        return self._children\n\n    @children.setter\n    def children(self, new_children):\n        \"\"\"Intercept assignment to update child relationships\"\"\"\n        self._children = new_children\n        update_root_properties(self)\n\n    def append_child(self, child):\n        \"\"\"\n        Adds a child node to this node.\n\n        Args:\n            child (Node or str): The child node to add. If a string is provided,\n                it will be converted to a text node.\n        \"\"\"\n        if isinstance(child, str):\n            child = Node(text=child)\n            child.is_text_node = True\n        self.children.append(child)\n        update_root_properties(self)\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Converts this node and its children into a nested dictionary representation.\n\n        Returns:\n            dict: A dictionary representing the node and its children.\n        \"\"\"\n        return {\n            \"name\": self.name,\n            \"parent\": self.parent.name if self.parent else \"none\",\n            \"level\" : self.level,\n            \"key\": self.key,\n            \"path\": self.path,\n            \"children\": [child.to_dict() if isinstance(child, Node) else child for child in self.children],\n        }\n\n    def getAttributes(self, node) -&gt; List[Attribute]:\n        attrs = []\n        for attr in node.attributes:\n            attrs.append(f' {attr.key}=\"{attr.value}\"')\n        return \"\".join(attrs)\n\n    def to_html(self) -&gt; str:\n        \"\"\"\n        Converts this node and its children into an HTML string.\n\n        Returns:\n            str: The HTML representation of the node and its children.\n        \"\"\"\n        if self.name in self_closing_tags:\n            return f\"&lt;{self.name}{self.getAttributes(self)}&gt;\"\n\n        html = f\"&lt;{self.name}\"\n        html += f\"{self.getAttributes(self)}\"\n        html += \"&gt;\"\n        for child in self.children:\n            if child.is_text_node:\n                html += child.text\n            elif isinstance(child, Node):\n                html += child.to_html()\n            else:\n                html += str(child)\n        html += f\"&lt;/{self.name}&gt;\"\n        return html\n\n    def findChildByName(self, name : str) -&gt; \"Node\":\n        \"\"\"\n        Finds a child node with the given name.\n\n        Args:\n            name (str): The name of the child node to find.\n\n        Returns:\n            Node: The child node with the given name, or None if not found.\n        \"\"\"\n        for child in self.children:\n            if isinstance(child, Node):\n                if child.name == name:\n                    return child\n        return None \n\n    def findAllByName(self, name) -&gt; List[\"Node\"]:\n        \"\"\"\n        Finds all child nodes with the given name.\n\n        Args:\n            name (str): The name of the child nodes to find.\n\n        Returns:\n            List[Node]: A list of child nodes with the given name.\n        \"\"\"\n        found = []\n        for child in self.children:\n            if isinstance(child, Node):\n                if child.name == name:\n                    found.append(child)\n\n        return found \n\n    def findByAttribute(self, key : str, value : str) -&gt; \"Node\":\n        \"\"\"\n        Finds a child node with the given attribute key and value.\n\n        Args:\n            key (str): The attribute key to search for.\n            value (str): The attribute value to search for.\n\n        Returns:\n            Node: The child node with the given attribute, or None if not found.\n        \"\"\"\n        found = None\n        for child in self.children:\n            if isinstance(child, Node):\n                for attribute in child.attributes:\n                    if attribute.key == key and attribute.value == value:\n                        return child\n        return found \n\n    def findAllChildrenByAttributeKey(self, key : str) -&gt; List[\"Node\"]:\n        \"\"\"\n        Finds all child nodes with the given attribute key.\n\n        Args:\n            key (str): The attribute key to search for.\n\n        Returns:\n            List[Node]: A list of child nodes with the given attribute key.\n        \"\"\"\n        found = []\n        for child in self.children:\n            if isinstance(child, Node):\n                for attribute in child.attributes:\n                    if attribute.key == key :\n                        found.append(child)\n                        break\n        return found \n\n    def findAllChildrenByAttributeValue(self, value : str) -&gt; List[\"Node\"]:\n        \"\"\"\n        Finds all child nodes with the given attribute value.\n\n        Args:\n            value (str): The attribute value to search for.\n\n        Returns:\n            List[Node]: A list of child nodes with the given attribute value.\n        \"\"\"\n        found = []\n        for child in self.children:\n            if isinstance(child, Node):\n                for attribute in child.attributes:\n                    if attribute.value == value :\n                        found.append(child)\n                        break\n        return found\n\n    def replace(self, oldNode : \"Node\", newNode: \"Node\") -&gt; None:\n        \"\"\"\n        Replaces a child node with a new node.\n\n        Args:\n            oldNode (Node): The node to be replaced.\n            newNode (Node): The new node to replace it with.\n        \"\"\"\n        found = self.getChildIndex(oldNode)\n        if found:\n            self.children[found] = newNode\n\n    def getChildIndex(self,node : \"Node\") -&gt; int :\n        \"\"\"\n        Gets the index of a child node.\n\n        Args:\n            node (Node): The child node to find the index of.\n\n        Returns:\n            int: The index of the child node, or -1 if not found.\n        \"\"\"\n        for idx, child in enumerate(self.children):\n              if isinstance(child, Node):\n                if child.nodeId == node.nodeId:\n                    return idx\n\n    def insertAfter(self, node : \"Node\", newNode : \"Node\") -&gt; None:\n        \"\"\"\n        Inserts a new node after a specific child node.\n\n        Args:\n            node (Node): The child node to insert after.\n            newNode (Node): The new node to insert.\n        \"\"\"\n        foundIdx = self.getChildIndex(node)\n        if foundIdx:\n            self.children.insert(foundIdx + 1, newNode)\n\n    def insertBefore(self, node : \"Node\", newNode : \"Node\") -&gt; None:\n        \"\"\"\n        Inserts a new node before a specific child node.\n\n        Args:\n            node (Node): The child node to insert before.\n            newNode (Node): The new node to insert.\n        \"\"\"\n        foundIdx = self.getChildIndex(node)\n        if foundIdx:\n            self.children.insert(foundIdx, newNode)\n\n    def remove(self, node : \"Node\"):\n        \"\"\"\n        Removes a child node.\n\n        Args:\n            node (Node): The child node to remove.\n        \"\"\"\n        foundIdx = self.getChildIndex(node)\n        if foundIdx:\n            del self.children[foundIdx]\n\n    def appendAttributeToChild(self, node : \"Node\", attribute : \"Attribute\") -&gt; None:\n        \"\"\"\n        Appends an attribute to a child node.\n\n        Args:\n            node (Node): The child node to add the attribute to.\n            attribute (Attribute): The attribute to add.\n        \"\"\"\n        for child in self.children:\n            if isinstance(child, Node):\n                if child.nodeId == node.nodeId:\n                    child.attributes.append(attribute)\n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.parent","title":"<code>parent</code>  <code>property</code> <code>writable</code>","text":"<p>Read-only property referencing the node's parent.</p>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.__init__","title":"<code>__init__(name=None, children=None, attributes=None, text=None)</code>","text":"<p>Represents an HTML element with attributes, children, and text content.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The tag name of the element.</p> <code>children</code> <code>list of Node</code> <p>The child elements of this node.</p> <code>attributes</code> <code>list of Attribute</code> <p>The attributes of this node.</p> <code>text</code> <code>str</code> <p>The text content of this node.</p> <code>nodeId</code> <code>str</code> <p>A unique identifier for this node.</p> <code>is_leaf</code> <code>bool</code> <p>Whether this node has no children.</p> <code>is_text_node</code> <code>bool</code> <p>Whether this node represents text content.</p> <code>level</code> <code>int</code> <p>The depth of this node in the tree.</p> <code>key</code> <code>int</code> <p>A unique identifier for this node within its level.</p> <code>path</code> <code>str</code> <p>The path from the root to this node.</p> Source code in <code>zenaura/client/tags/node.py</code> <pre><code>def __init__(\n        self,name : str = None, \n        children: Optional[List[\"Node\"]]=None, \n        attributes : Optional[List[Attribute]]=None,\n        text: str = None,\n        ):\n    \"\"\"\n    Represents an HTML element with attributes, children, and text content.\n\n    Attributes:\n        name (str): The tag name of the element.\n        children (list of Node): The child elements of this node.\n        attributes (list of Attribute): The attributes of this node.\n        text (str, optional): The text content of this node.\n        nodeId (str): A unique identifier for this node.\n        is_leaf (bool): Whether this node has no children.\n        is_text_node (bool): Whether this node represents text content.\n        level (int): The depth of this node in the tree.\n        key (int): A unique identifier for this node within its level.\n        path (str): The path from the root to this node.\n    \"\"\"\n    self._parent = None\n\n    # calculated properties\n    self._level = 0\n    self._key = 0 \n    self._is_leaf = True\n    self._path = \"\"\n\n    self.name = name\n    self._children = children if children else []\n    self.attributes = [] if attributes is None else attributes\n    self.nodeId = uuid.uuid4().hex\n    self.text = text        \n    # calculated proerty depends on children, text\n    self._is_text_node = isinstance(self.text, str)\n    update_root_properties(self)\n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.appendAttributeToChild","title":"<code>appendAttributeToChild(node, attribute)</code>","text":"<p>Appends an attribute to a child node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>The child node to add the attribute to.</p> required <code>attribute</code> <code>Attribute</code> <p>The attribute to add.</p> required Source code in <code>zenaura/client/tags/node.py</code> <pre><code>def appendAttributeToChild(self, node : \"Node\", attribute : \"Attribute\") -&gt; None:\n    \"\"\"\n    Appends an attribute to a child node.\n\n    Args:\n        node (Node): The child node to add the attribute to.\n        attribute (Attribute): The attribute to add.\n    \"\"\"\n    for child in self.children:\n        if isinstance(child, Node):\n            if child.nodeId == node.nodeId:\n                child.attributes.append(attribute)\n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.append_child","title":"<code>append_child(child)</code>","text":"<p>Adds a child node to this node.</p> <p>Parameters:</p> Name Type Description Default <code>child</code> <code>Node or str</code> <p>The child node to add. If a string is provided, it will be converted to a text node.</p> required Source code in <code>zenaura/client/tags/node.py</code> <pre><code>def append_child(self, child):\n    \"\"\"\n    Adds a child node to this node.\n\n    Args:\n        child (Node or str): The child node to add. If a string is provided,\n            it will be converted to a text node.\n    \"\"\"\n    if isinstance(child, str):\n        child = Node(text=child)\n        child.is_text_node = True\n    self.children.append(child)\n    update_root_properties(self)\n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.findAllByName","title":"<code>findAllByName(name)</code>","text":"<p>Finds all child nodes with the given name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the child nodes to find.</p> required <p>Returns:</p> Type Description <code>List[Node]</code> <p>List[Node]: A list of child nodes with the given name.</p> Source code in <code>zenaura/client/tags/node.py</code> <pre><code>def findAllByName(self, name) -&gt; List[\"Node\"]:\n    \"\"\"\n    Finds all child nodes with the given name.\n\n    Args:\n        name (str): The name of the child nodes to find.\n\n    Returns:\n        List[Node]: A list of child nodes with the given name.\n    \"\"\"\n    found = []\n    for child in self.children:\n        if isinstance(child, Node):\n            if child.name == name:\n                found.append(child)\n\n    return found \n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.findAllChildrenByAttributeKey","title":"<code>findAllChildrenByAttributeKey(key)</code>","text":"<p>Finds all child nodes with the given attribute key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The attribute key to search for.</p> required <p>Returns:</p> Type Description <code>List[Node]</code> <p>List[Node]: A list of child nodes with the given attribute key.</p> Source code in <code>zenaura/client/tags/node.py</code> <pre><code>def findAllChildrenByAttributeKey(self, key : str) -&gt; List[\"Node\"]:\n    \"\"\"\n    Finds all child nodes with the given attribute key.\n\n    Args:\n        key (str): The attribute key to search for.\n\n    Returns:\n        List[Node]: A list of child nodes with the given attribute key.\n    \"\"\"\n    found = []\n    for child in self.children:\n        if isinstance(child, Node):\n            for attribute in child.attributes:\n                if attribute.key == key :\n                    found.append(child)\n                    break\n    return found \n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.findAllChildrenByAttributeValue","title":"<code>findAllChildrenByAttributeValue(value)</code>","text":"<p>Finds all child nodes with the given attribute value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The attribute value to search for.</p> required <p>Returns:</p> Type Description <code>List[Node]</code> <p>List[Node]: A list of child nodes with the given attribute value.</p> Source code in <code>zenaura/client/tags/node.py</code> <pre><code>def findAllChildrenByAttributeValue(self, value : str) -&gt; List[\"Node\"]:\n    \"\"\"\n    Finds all child nodes with the given attribute value.\n\n    Args:\n        value (str): The attribute value to search for.\n\n    Returns:\n        List[Node]: A list of child nodes with the given attribute value.\n    \"\"\"\n    found = []\n    for child in self.children:\n        if isinstance(child, Node):\n            for attribute in child.attributes:\n                if attribute.value == value :\n                    found.append(child)\n                    break\n    return found\n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.findByAttribute","title":"<code>findByAttribute(key, value)</code>","text":"<p>Finds a child node with the given attribute key and value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The attribute key to search for.</p> required <code>value</code> <code>str</code> <p>The attribute value to search for.</p> required <p>Returns:</p> Name Type Description <code>Node</code> <code>Node</code> <p>The child node with the given attribute, or None if not found.</p> Source code in <code>zenaura/client/tags/node.py</code> <pre><code>def findByAttribute(self, key : str, value : str) -&gt; \"Node\":\n    \"\"\"\n    Finds a child node with the given attribute key and value.\n\n    Args:\n        key (str): The attribute key to search for.\n        value (str): The attribute value to search for.\n\n    Returns:\n        Node: The child node with the given attribute, or None if not found.\n    \"\"\"\n    found = None\n    for child in self.children:\n        if isinstance(child, Node):\n            for attribute in child.attributes:\n                if attribute.key == key and attribute.value == value:\n                    return child\n    return found \n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.findChildByName","title":"<code>findChildByName(name)</code>","text":"<p>Finds a child node with the given name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the child node to find.</p> required <p>Returns:</p> Name Type Description <code>Node</code> <code>Node</code> <p>The child node with the given name, or None if not found.</p> Source code in <code>zenaura/client/tags/node.py</code> <pre><code>def findChildByName(self, name : str) -&gt; \"Node\":\n    \"\"\"\n    Finds a child node with the given name.\n\n    Args:\n        name (str): The name of the child node to find.\n\n    Returns:\n        Node: The child node with the given name, or None if not found.\n    \"\"\"\n    for child in self.children:\n        if isinstance(child, Node):\n            if child.name == name:\n                return child\n    return None \n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.getChildIndex","title":"<code>getChildIndex(node)</code>","text":"<p>Gets the index of a child node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>The child node to find the index of.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the child node, or -1 if not found.</p> Source code in <code>zenaura/client/tags/node.py</code> <pre><code>def getChildIndex(self,node : \"Node\") -&gt; int :\n    \"\"\"\n    Gets the index of a child node.\n\n    Args:\n        node (Node): The child node to find the index of.\n\n    Returns:\n        int: The index of the child node, or -1 if not found.\n    \"\"\"\n    for idx, child in enumerate(self.children):\n          if isinstance(child, Node):\n            if child.nodeId == node.nodeId:\n                return idx\n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.insertAfter","title":"<code>insertAfter(node, newNode)</code>","text":"<p>Inserts a new node after a specific child node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>The child node to insert after.</p> required <code>newNode</code> <code>Node</code> <p>The new node to insert.</p> required Source code in <code>zenaura/client/tags/node.py</code> <pre><code>def insertAfter(self, node : \"Node\", newNode : \"Node\") -&gt; None:\n    \"\"\"\n    Inserts a new node after a specific child node.\n\n    Args:\n        node (Node): The child node to insert after.\n        newNode (Node): The new node to insert.\n    \"\"\"\n    foundIdx = self.getChildIndex(node)\n    if foundIdx:\n        self.children.insert(foundIdx + 1, newNode)\n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.insertBefore","title":"<code>insertBefore(node, newNode)</code>","text":"<p>Inserts a new node before a specific child node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>The child node to insert before.</p> required <code>newNode</code> <code>Node</code> <p>The new node to insert.</p> required Source code in <code>zenaura/client/tags/node.py</code> <pre><code>def insertBefore(self, node : \"Node\", newNode : \"Node\") -&gt; None:\n    \"\"\"\n    Inserts a new node before a specific child node.\n\n    Args:\n        node (Node): The child node to insert before.\n        newNode (Node): The new node to insert.\n    \"\"\"\n    foundIdx = self.getChildIndex(node)\n    if foundIdx:\n        self.children.insert(foundIdx, newNode)\n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.remove","title":"<code>remove(node)</code>","text":"<p>Removes a child node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>The child node to remove.</p> required Source code in <code>zenaura/client/tags/node.py</code> <pre><code>def remove(self, node : \"Node\"):\n    \"\"\"\n    Removes a child node.\n\n    Args:\n        node (Node): The child node to remove.\n    \"\"\"\n    foundIdx = self.getChildIndex(node)\n    if foundIdx:\n        del self.children[foundIdx]\n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.replace","title":"<code>replace(oldNode, newNode)</code>","text":"<p>Replaces a child node with a new node.</p> <p>Parameters:</p> Name Type Description Default <code>oldNode</code> <code>Node</code> <p>The node to be replaced.</p> required <code>newNode</code> <code>Node</code> <p>The new node to replace it with.</p> required Source code in <code>zenaura/client/tags/node.py</code> <pre><code>def replace(self, oldNode : \"Node\", newNode: \"Node\") -&gt; None:\n    \"\"\"\n    Replaces a child node with a new node.\n\n    Args:\n        oldNode (Node): The node to be replaced.\n        newNode (Node): The new node to replace it with.\n    \"\"\"\n    found = self.getChildIndex(oldNode)\n    if found:\n        self.children[found] = newNode\n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts this node and its children into a nested dictionary representation.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary representing the node and its children.</p> Source code in <code>zenaura/client/tags/node.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Converts this node and its children into a nested dictionary representation.\n\n    Returns:\n        dict: A dictionary representing the node and its children.\n    \"\"\"\n    return {\n        \"name\": self.name,\n        \"parent\": self.parent.name if self.parent else \"none\",\n        \"level\" : self.level,\n        \"key\": self.key,\n        \"path\": self.path,\n        \"children\": [child.to_dict() if isinstance(child, Node) else child for child in self.children],\n    }\n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.Node.to_html","title":"<code>to_html()</code>","text":"<p>Converts this node and its children into an HTML string.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The HTML representation of the node and its children.</p> Source code in <code>zenaura/client/tags/node.py</code> <pre><code>def to_html(self) -&gt; str:\n    \"\"\"\n    Converts this node and its children into an HTML string.\n\n    Returns:\n        str: The HTML representation of the node and its children.\n    \"\"\"\n    if self.name in self_closing_tags:\n        return f\"&lt;{self.name}{self.getAttributes(self)}&gt;\"\n\n    html = f\"&lt;{self.name}\"\n    html += f\"{self.getAttributes(self)}\"\n    html += \"&gt;\"\n    for child in self.children:\n        if child.is_text_node:\n            html += child.text\n        elif isinstance(child, Node):\n            html += child.to_html()\n        else:\n            html += str(child)\n    html += f\"&lt;/{self.name}&gt;\"\n    return html\n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.NodeList","title":"<code>NodeList</code>","text":"<p>               Bases: <code>list</code></p> <p>Custom list subclass to trigger update on append.</p> Source code in <code>zenaura/client/tags/node.py</code> <pre><code>class NodeList(list):\n    \"\"\"Custom list subclass to trigger update on append.\"\"\"\n\n    def __init__(self, node, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.node = node  # Reference to the parent Node\n\n    def append(self, child):\n        super().append(child)\n        self.node.children = self  # Trigger the setter\n</code></pre>"},{"location":"api/client/tags/node/#zenaura.client.tags.node.update_root_properties","title":"<code>update_root_properties(root)</code>","text":"<p>Upon intialization of a node or setting children This method create infromation rich tree nodes: 1. link children to their parent 2. assign level, key information  3. is_leaf_node, is_text node and so on</p> Source code in <code>zenaura/client/tags/node.py</code> <pre><code>def update_root_properties(root):\n    \"\"\"\n        Upon intialization of a node or setting children\n        This method create infromation rich tree nodes:\n        1. link children to their parent\n        2. assign level, key information \n        3. is_leaf_node, is_text node\n        and so on\n    \"\"\"\n    stack = [(root, None, 0, 0, root.path)] # (node, level_parent, level, index, path)\n\n    while stack :\n        curr, curr.parent, curr.level, curr.key, curr.path   = stack.pop()\n        curr.is_leaf = len(curr.children) == 0\n        for idx, child in enumerate(curr.children):\n            if isinstance(child, str):\n                child = Node(text=child)\n                child.is_text_node = True\n            child.is_leaf = len(child.children) == 0\n            curr.children[idx] = child\n            stack.append((child, child, curr.level + 1, idx, curr.path + str(curr.level) + str(idx)))\n    return root\n</code></pre>"},{"location":"api/server/server/","title":"Server","text":"<p>This function generates the HTML structure of a Zenaura page.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The main content of the page, typically generated by compiling Zenaura components.</p> required <code>meta_description</code> <code>str</code> <p>A brief description of the page, used by search engines. Defaults to None.</p> <code>None</code> <code>title</code> <code>str</code> <p>The title of the page, displayed in the browser tab. Defaults to None.</p> <code>None</code> <code>icon</code> <code>str</code> <p>The URL of the favicon, a small icon associated with the page. Defaults to None.</p> <code>None</code> <code>pydide</code> <code>str</code> <p>The URL of the PyScript library, used for running Python code in the browser. Defaults to \"https://pyscript.net/releases/2024.1.1/core.js\".</p> <code>'https://pyscript.net/releases/2024.1.1/core.js'</code> <code>scripts</code> <code>list</code> <p>An optional list of additional JavaScript scripts, CSS links to include in the page. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <p>The complete HTML code as a string.</p> Source code in <code>zenaura/server/server.py</code> <pre><code>def template(content, meta_description=None, title=None, icon=None, pydide=\"https://pyscript.net/releases/2024.1.1/core.js\", scripts=None):\n  \"\"\"\n    This function generates the HTML structure of a Zenaura page.\n\n    Args:\n        content (str): The main content of the page, typically generated by compiling Zenaura components.\n        meta_description (str, optional): A brief description of the page, used by search engines. Defaults to None.\n        title (str, optional): The title of the page, displayed in the browser tab. Defaults to None.\n        icon (str, optional): The URL of the favicon, a small icon associated with the page. Defaults to None.\n        pydide (str, optional): The URL of the PyScript library, used for running Python code in the browser. Defaults to \"https://pyscript.net/releases/2024.1.1/core.js\".\n        scripts (list, optional): An optional list of additional JavaScript scripts, CSS links to include in the page. Defaults to None.\n\n    Returns:\n        str: The complete HTML code as a string.\n  \"\"\"\n  if scripts:\n    s = io.StringIO()\n    for script in scripts:\n        s.write(script)\n        s.write(\"\\n\")\n    scripts = s.getvalue()\n\n  return f\"\"\"\n\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"utf-8\" /&gt;\n    &lt;link rel=\"icon\" href=\"{icon}\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /&gt;\n    &lt;meta name=\"theme-color\" content=\"#000000\" /&gt;\n    &lt;meta name=\"title\" content=\"{title}\" /&gt;\n    &lt;meta http-equiv=\"refresh\"  /&gt;\n    &lt;meta\n      name=\"description\"\n      content=\"{meta_description}\"\n    /&gt;\n    &lt;script type=\"module\" src=\"{pydide}\"&gt;&lt;/script&gt;\n    {scripts if scripts else \"\"}\n\n\t&lt;script type=\"py\" src=\"./public/main.py\" config=\"./public/config.json\"&gt;&lt;/script&gt;\n\n    &lt;link  rel=\"stylesheet\" href=\"./public/main.css\"&gt;\n\n    &lt;title&gt;{title}&lt;/title&gt;\n\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"root\"&gt;\n        {content}\n    &lt;/div&gt;\n\n  &lt;/body&gt;\n\n&lt;/html&gt;\n\"\"\"\n</code></pre> <p>A class for server-side rendering of Zenaura applications.</p> <p>This class provides methods for:</p> <ul> <li>Hydrating Zenaura pages for server-side rendering.</li> <li>Hydrating Zenaura apps for server-side rendering.</li> <li>Generating the HTML structure of a Zenaura page.</li> </ul> Source code in <code>zenaura/server/server.py</code> <pre><code>class ZenauraServer:\n    \"\"\"\n    A class for server-side rendering of Zenaura applications.\n\n    This class provides methods for:\n\n    * Hydrating Zenaura pages for server-side rendering.\n    * Hydrating Zenaura apps for server-side rendering.\n    * Generating the HTML structure of a Zenaura page.\n    \"\"\"\n\n    @staticmethod\n    def hydrate_page(page: Page, title=\"zenaura\", meta_description=\"this app created with zenaura\", icon=\"./public/favicon.ico\", pydide=\"https://pyscript.net/releases/2024.1.1/core.js\") -&gt; str:\n        \"\"\"\n        Hydrates a Zenaura page for server-side rendering.\n\n        This method compiles the page's components using the HydratorCompilerAdapter and generates the HTML structure of the page.\n\n        Args:\n            page (Page): The Zenaura page to be hydrated.\n            title (str, optional): The title of the page. Defaults to \"zenaura\".\n            meta_description (str, optional): The meta description of the page. Defaults to \"this app created with zenaura\".\n            icon (str, optional): The URL of the favicon. Defaults to \"./public/favicon.ico\".\n            pydide (str, optional): The URL of the PyScript library. Defaults to \"https://pyscript.net/releases/2024.1.1/core.js\".\n\n        Returns:\n            str: The HTML structure of the hydrated page.\n        \"\"\"\n\n        return template(compiler_adapter.hyd_comp_compile_page(page), meta_description, title, icon, pydide)\n\n    @staticmethod\n    def hydrate_app(app: App, title=\"zenaura\", meta_description=\"this app created with zenaura\", icon=\"./public/favicon.ico\", pydide=\"https://pyscript.net/releases/2024.1.1/core.js\", scripts=None) -&gt; None:\n        \"\"\"\n        Hydrates a Zenaura app for server-side rendering.\n\n        This method renders all pages in the app, sets the page with path \"/\" to visible, and the rest to hidden. It then compiles the index.html file for server-side rendering.\n\n        Args:\n            app (App): The Zenaura app to be hydrated.\n            title (str, optional): The title of the page. Defaults to \"zenaura\".\n            meta_description (str, optional): The meta description of the page. Defaults to \"this app created with zenaura\".\n            icon (str, optional): The URL of the favicon. Defaults to \"./public/favicon.ico\".\n            pydide (str, optional): The URL of the PyScript library. Defaults to \"https://pyscript.net/releases/2024.1.1/core.js\".\n            scripts (list, optional): An optional list of additional JavaScript scripts and CSS links to include in the page. Defaults to None.\n        \"\"\"\n\n        pages = io.StringIO()\n\n        # First page in the stack is shown\n        routes = app.routes.copy()\n\n        def page_div(comps, page_id, hidden, attributes=None):\n            \"\"\"\n                wraps rendered page components with a div, assign hidden attribute\n                if the page is hidden, and add the id\n            \"\"\"\n            if attributes:\n                attrs = []\n                for k,v in attributes.items():\n                    attrs.append(Attribute(k,v))\n\n                attrs = attrs_processor.process_attributes(attrs)\n            if hidden:\n                return f'&lt;div hidden{attrs if attributes else \"\"} data-zenaura=\"{page_id}\"&gt;{comps}&lt;/div&gt;'\n            return f'&lt;div{attrs if attributes else \"\"} data-zenaura=\"{page_id}\"&gt;{comps}&lt;/div&gt;'\n\n        # if / path in routes it's set to shown\n        if \"/\" in routes:\n            page, _, _, ssr = routes.pop(\"/\")\n            pages.write(\n                page_div(\n                    compiler_adapter.hyd_comp_compile_page(page),\n                    page.id,\n                    False,\n                    page.attributes\n                )\n            )\n        else: # first route , in keys stack will be shown, rest hidden\n            keys = list(routes.keys())\n            page, _, _, ssr = routes.pop(keys[0])\n            pages.write(\n                page_div(\n                    compiler_adapter.hyd_comp_compile_page(page),\n                    page.id,\n                    False,\n                    page.attributes\n\n                )\n            )\n\n\n        # Render rest of the pages hidden\n        while routes:\n            _ , (page, _, _, ssr) = routes.popitem()\n            if ssr:  # Ignore server side rendered routes and thier pages.\n                continue\n            # Pages other than / or first route in stack are set to hidden\n            pages.write(\n                page_div(\n                    compiler_adapter.hyd_comp_compile_page(page),\n                    page.id,\n                    True,\n                    page.attributes\n\n                )\n            )\n\n        pages = pages.getvalue()\n\n        # Overwrite in public dir\n        with open(\"./public/index.html\", \"w\") as file:\n            file.write(template(pages, meta_description, title, icon, pydide, scripts))\n\n        return template(pages, meta_description, title, icon, pydide, scripts)\n\n\n    @staticmethod\n    def hydrate_app_layout(layout: Layout, title=\"zenaura\", meta_description=\"this app created with zenaura\", icon=\"./public/favicon.ico\", pydide=\"https://pyscript.net/releases/2024.1.1/core.js\", scripts=None) -&gt; None:\n        \"\"\"\n        Hydrates a Zenaura layout for server-side rendering.\n\n        This method renders all top components -&gt; pages -&gt; bottom in the app, sets the page with path \"/\" to visible, and the rest to hidden. It then compiles the index.html file for server-side rendering.\n\n        Args:\n            layout (App): the layout to be hyderated with top components -&gt; pages -&gt; bottom components wrapped \n            title (str, optional): The title of the page. Defaults to \"zenaura\".\n            meta_description (str, optional): The meta description of the page. Defaults to \"this app created with zenaura\".\n            icon (str, optional): The URL of the favicon. Defaults to \"./public/favicon.ico\".\n            pydide (str, optional): The URL of the PyScript library. Defaults to \"https://pyscript.net/releases/2024.1.1/core.js\".\n            scripts (list, optional): An optional list of additional JavaScript scripts and CSS links to include in the page. Defaults to None.\n        \"\"\"\n\n        pages = io.StringIO()\n\n        # First page in the stack is shown\n        routes = layout.routes.copy()\n\n        # add top components first children of root div \n        for comp in layout.top:\n            pages.write(compiler_adapter.hyd_comp_compile_children(comp.render(), comp.id, True))\n\n        def page_div(comps, page_id, hidden, attributes=None):\n            \"\"\"\n                wraps rendered page components with a div, assign hidden attribute\n                if the page is hidden, and add the id\n            \"\"\"\n            if attributes:\n                attrs = []\n                for k,v in attributes.items():\n                    attrs.append(Attribute(k,v))\n\n                attrs = attrs_processor.process_attributes(attrs)\n            if hidden:\n                return f'&lt;div hidden{attrs if attributes else \"\"} data-zenaura=\"{page_id}\"&gt;{comps}&lt;/div&gt;'\n            return f'&lt;div{attrs if attributes else \"\"} data-zenaura=\"{page_id}\"&gt;{comps}&lt;/div&gt;'\n\n        # if / path in routes it's set to shown\n        if \"/\" in routes:\n            page, _, _, ssr = routes.pop(\"/\")\n            pages.write(\n                page_div(\n                    compiler_adapter.hyd_comp_compile_page(page),\n                    page.id,\n                    False,\n                    page.attributes\n                )\n            )\n        else: # first route , in keys stack will be shown, rest hidden\n            keys = list(routes.keys())\n            page, _, _, ssr = routes.pop(keys[0])\n            pages.write(\n                page_div(\n                    compiler_adapter.hyd_comp_compile_page(page),\n                    page.id,\n                    False,\n                    page.attributes\n\n                )\n            )\n\n\n        # Render rest of the pages hidden\n        while routes:\n            _ , (page, _, _, ssr) = routes.popitem()\n            if ssr:  # Ignore server side rendered routes and thier pages.\n                continue\n            # Pages other than / or first route in stack are set to hidden\n            pages.write(\n                page_div(\n                    compiler_adapter.hyd_comp_compile_page(page),\n                    page.id,\n                    True,\n                    page.attributes\n\n                )\n            )\n\n        # add bottom level components\n        for comp in layout.bottom:\n            pages.write(compiler_adapter.hyd_comp_compile_children(comp.render(), comp.id, True))\n\n        pages = pages.getvalue()\n\n        # Overwrite in public dir\n        with open(\"./public/index.html\", \"w\") as file:\n            file.write(template(pages, meta_description, title, icon, pydide, scripts))\n\n        return template(pages, meta_description, title, icon, pydide, scripts)\n</code></pre> <p>               Bases: <code>Observer</code></p> Source code in <code>zenaura/server/server.py</code> <pre><code>class PausingObserver(Observer):\n    def dispatch_events(self, *args, **kwargs):\n        if not getattr(self, '_is_paused', False):\n            super(PausingObserver, self).dispatch_events(*args, **kwargs)\n\n    def pause(self):\n        self._is_paused = True\n\n    def resume(self):\n        time.sleep(self.timeout)  # allow interim events to be queued\n        self.event_queue.queue.clear()\n        self._is_paused = False\n\n    @contextlib.contextmanager\n    def ignore_events(self):\n        self.pause()\n        yield\n        self.resume()\n</code></pre> <p>A class for running a development server for Zenaura applications.</p> <p>This class provides methods for:</p> <ul> <li>Starting a Flask server with WebSocket support.</li> <li>Sending refresh signals to connected clients when changes are detected.</li> <li>Hydrating the application and notifying clients when changes are made.</li> <li>Running a file system observer to detect changes in the application files.</li> </ul> Source code in <code>zenaura/server/server.py</code> <pre><code>class DevServer:\n    \"\"\"\n    A class for running a development server for Zenaura applications.\n\n    This class provides methods for:\n\n    * Starting a Flask server with WebSocket support.\n    * Sending refresh signals to connected clients when changes are detected.\n    * Hydrating the application and notifying clients when changes are made.\n    * Running a file system observer to detect changes in the application files.\n    \"\"\"\n\n    def __init__(self, app, debug=True, port=5000):\n        \"\"\"\n        Initializes the DevServer class.\n\n        Args:\n            debug (bool, optional): Whether to run the server in debug mode. Defaults to True.\n            port (int, optional): The port on which to run the server. Defaults to 5000.\n        \"\"\"\n\n        self.debug = debug\n        self.port = port\n        self.app = app\n        self.sock = Sock()\n        self.ws_client_list = []\n        self.shutdown_event = Event()\n        self.observer = PausingObserver()\n        self.sock.init_app(self.app)\n\n        self.setup_websocket()\n\n    def setup_websocket(self):\n        \"\"\"\n        Sets up the WebSocket route for sending refresh signals to clients.\n        \"\"\"\n\n        @self.sock.route(\"/refresh\")\n        def refresh(ws):\n            \"\"\"\n            WebSocket handler for sending refresh signals to clients.\n\n            Args:\n                ws (WebSocket): The WebSocket connection.\n            \"\"\"\n\n            self.ws_client_list.append(ws)\n            while not self.shutdown_event.is_set():\n                try:\n                    ws.receive()\n                    ws.sleep(1)\n                    ws.send(\"refresh\")\n                except Exception as e:\n                    print(f\"Error in WebSocket connection: {e}\")\n                    break\n\n    def send_refresh_signal(self):\n        \"\"\"\n        Sends a refresh signal to all connected clients.\n        \"\"\"\n\n        zenaura_logger.info(\"Sending refresh signal...\")\n        clients = self.ws_client_list.copy()\n        for client in clients:\n            try:\n                client.send(\"refresh\")\n            except Exception as e:\n                print(f\"Error sending refresh: {e}\")\n                self.ws_client_list.remove(client)\n\n    def get_change_handler(self):\n        \"\"\"\n        Returns a ChangeHandler class that handles file system events.\n\n        Returns:\n            ChangeHandler: A class that handles file system events.\n        \"\"\"\n\n        DEVSERVER = self\n\n        class ChangeHandler(FileSystemEventHandler):\n            \"\"\"\n            A class that handles file system events.\n\n            This class is used to detect changes in the application files and trigger a refresh of the browser.\n            \"\"\"\n\n            def __init__(self, server):\n                \"\"\"\n                Initializes the ChangeHandler class.\n\n                Args:\n                    server (DevServer): The DevServer instance.\n                \"\"\"\n\n                super().__init__()\n                self.server = server\n\n            def on_any_event(self, event):\n                \"\"\"\n                Handles file system events.\n\n                Args:\n                    event (FileSystemEvent): The file system event.\n                \"\"\"\n\n                try:\n                    zenaura_logger.info(f\"File {event.src_path} has changed.\")\n                    zenaura_logger.info(\"Changes are live...\")\n                    DEVSERVER.hydrate_and_notify()\n                    zenaura_logger.info(\"Reloading browser...\")\n                    DEVSERVER.send_refresh_signal()\n                    zenaura_logger.info(\"Browser reloaded.\")\n                except Exception as e:\n                    zenaura_logger.info(f\"Error in ChangeHandler: {e}\")\n\n        return ChangeHandler\n\n    def start_server(self):\n        \"\"\"\n        Starts the Flask server.\n        \"\"\"\n\n        try:\n            self.app.run(debug=self.debug, port=self.port, use_reloader=False)\n        except Exception as e:\n            zenaura_logger.info(f\"Error starting server: {e}\")\n\n    def hydrate_and_notify(self):\n        \"\"\"\n        Hydrates the application and notifies clients of changes.\n        \"\"\"\n\n        try:\n            self.observer.pause()\n            zenaura_logger.info(\"Hydrating...\")\n            zenaura_logger.info(\"Pausing the observer...\")\n            process = subprocess.Popen(\"python build.py\", shell=True)\n            process.communicate()\n            zenaura_logger.info(\"Hydrated done...\")\n\n        finally:\n            zenaura_logger.info(\"Running the observer...\")\n            self.observer.resume()\n\n    def run(self):\n        \"\"\"\n        Runs the development server.\n\n        This method starts the Flask server, file system observer, and WebSocket server.\n        \"\"\"\n\n        path = 'public'\n        ChangeHandler = self.get_change_handler()\n        event_handler = ChangeHandler(self)\n        self.observer.schedule(event_handler, path, recursive=True)\n        self.observer.start()\n\n        server_thread = Thread(target=self.start_server, daemon=True)\n        server_thread.start()\n\n        try:\n            while not self.shutdown_event.is_set():\n                time.sleep(0.1)  # Shorter sleep interval\n        except KeyboardInterrupt:\n            zenaura_logger.info(\"KeyboardInterrupt received, stopping...\")\n        finally:\n            # Faster Shutdown of Observer\n            self.observer.event_queue.queue.clear()\n            self.observer.stop()  \n            self.observer.join()  \n</code></pre>"},{"location":"api/server/server/#zenaura.server.server.ZenauraServer.hydrate_app","title":"<code>hydrate_app(app, title='zenaura', meta_description='this app created with zenaura', icon='./public/favicon.ico', pydide='https://pyscript.net/releases/2024.1.1/core.js', scripts=None)</code>  <code>staticmethod</code>","text":"<p>Hydrates a Zenaura app for server-side rendering.</p> <p>This method renders all pages in the app, sets the page with path \"/\" to visible, and the rest to hidden. It then compiles the index.html file for server-side rendering.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>App</code> <p>The Zenaura app to be hydrated.</p> required <code>title</code> <code>str</code> <p>The title of the page. Defaults to \"zenaura\".</p> <code>'zenaura'</code> <code>meta_description</code> <code>str</code> <p>The meta description of the page. Defaults to \"this app created with zenaura\".</p> <code>'this app created with zenaura'</code> <code>icon</code> <code>str</code> <p>The URL of the favicon. Defaults to \"./public/favicon.ico\".</p> <code>'./public/favicon.ico'</code> <code>pydide</code> <code>str</code> <p>The URL of the PyScript library. Defaults to \"https://pyscript.net/releases/2024.1.1/core.js\".</p> <code>'https://pyscript.net/releases/2024.1.1/core.js'</code> <code>scripts</code> <code>list</code> <p>An optional list of additional JavaScript scripts and CSS links to include in the page. Defaults to None.</p> <code>None</code> Source code in <code>zenaura/server/server.py</code> <pre><code>@staticmethod\ndef hydrate_app(app: App, title=\"zenaura\", meta_description=\"this app created with zenaura\", icon=\"./public/favicon.ico\", pydide=\"https://pyscript.net/releases/2024.1.1/core.js\", scripts=None) -&gt; None:\n    \"\"\"\n    Hydrates a Zenaura app for server-side rendering.\n\n    This method renders all pages in the app, sets the page with path \"/\" to visible, and the rest to hidden. It then compiles the index.html file for server-side rendering.\n\n    Args:\n        app (App): The Zenaura app to be hydrated.\n        title (str, optional): The title of the page. Defaults to \"zenaura\".\n        meta_description (str, optional): The meta description of the page. Defaults to \"this app created with zenaura\".\n        icon (str, optional): The URL of the favicon. Defaults to \"./public/favicon.ico\".\n        pydide (str, optional): The URL of the PyScript library. Defaults to \"https://pyscript.net/releases/2024.1.1/core.js\".\n        scripts (list, optional): An optional list of additional JavaScript scripts and CSS links to include in the page. Defaults to None.\n    \"\"\"\n\n    pages = io.StringIO()\n\n    # First page in the stack is shown\n    routes = app.routes.copy()\n\n    def page_div(comps, page_id, hidden, attributes=None):\n        \"\"\"\n            wraps rendered page components with a div, assign hidden attribute\n            if the page is hidden, and add the id\n        \"\"\"\n        if attributes:\n            attrs = []\n            for k,v in attributes.items():\n                attrs.append(Attribute(k,v))\n\n            attrs = attrs_processor.process_attributes(attrs)\n        if hidden:\n            return f'&lt;div hidden{attrs if attributes else \"\"} data-zenaura=\"{page_id}\"&gt;{comps}&lt;/div&gt;'\n        return f'&lt;div{attrs if attributes else \"\"} data-zenaura=\"{page_id}\"&gt;{comps}&lt;/div&gt;'\n\n    # if / path in routes it's set to shown\n    if \"/\" in routes:\n        page, _, _, ssr = routes.pop(\"/\")\n        pages.write(\n            page_div(\n                compiler_adapter.hyd_comp_compile_page(page),\n                page.id,\n                False,\n                page.attributes\n            )\n        )\n    else: # first route , in keys stack will be shown, rest hidden\n        keys = list(routes.keys())\n        page, _, _, ssr = routes.pop(keys[0])\n        pages.write(\n            page_div(\n                compiler_adapter.hyd_comp_compile_page(page),\n                page.id,\n                False,\n                page.attributes\n\n            )\n        )\n\n\n    # Render rest of the pages hidden\n    while routes:\n        _ , (page, _, _, ssr) = routes.popitem()\n        if ssr:  # Ignore server side rendered routes and thier pages.\n            continue\n        # Pages other than / or first route in stack are set to hidden\n        pages.write(\n            page_div(\n                compiler_adapter.hyd_comp_compile_page(page),\n                page.id,\n                True,\n                page.attributes\n\n            )\n        )\n\n    pages = pages.getvalue()\n\n    # Overwrite in public dir\n    with open(\"./public/index.html\", \"w\") as file:\n        file.write(template(pages, meta_description, title, icon, pydide, scripts))\n\n    return template(pages, meta_description, title, icon, pydide, scripts)\n</code></pre>"},{"location":"api/server/server/#zenaura.server.server.ZenauraServer.hydrate_app_layout","title":"<code>hydrate_app_layout(layout, title='zenaura', meta_description='this app created with zenaura', icon='./public/favicon.ico', pydide='https://pyscript.net/releases/2024.1.1/core.js', scripts=None)</code>  <code>staticmethod</code>","text":"<p>Hydrates a Zenaura layout for server-side rendering.</p> <p>This method renders all top components -&gt; pages -&gt; bottom in the app, sets the page with path \"/\" to visible, and the rest to hidden. It then compiles the index.html file for server-side rendering.</p> <p>Parameters:</p> Name Type Description Default <code>layout</code> <code>App</code> <p>the layout to be hyderated with top components -&gt; pages -&gt; bottom components wrapped </p> required <code>title</code> <code>str</code> <p>The title of the page. Defaults to \"zenaura\".</p> <code>'zenaura'</code> <code>meta_description</code> <code>str</code> <p>The meta description of the page. Defaults to \"this app created with zenaura\".</p> <code>'this app created with zenaura'</code> <code>icon</code> <code>str</code> <p>The URL of the favicon. Defaults to \"./public/favicon.ico\".</p> <code>'./public/favicon.ico'</code> <code>pydide</code> <code>str</code> <p>The URL of the PyScript library. Defaults to \"https://pyscript.net/releases/2024.1.1/core.js\".</p> <code>'https://pyscript.net/releases/2024.1.1/core.js'</code> <code>scripts</code> <code>list</code> <p>An optional list of additional JavaScript scripts and CSS links to include in the page. Defaults to None.</p> <code>None</code> Source code in <code>zenaura/server/server.py</code> <pre><code>@staticmethod\ndef hydrate_app_layout(layout: Layout, title=\"zenaura\", meta_description=\"this app created with zenaura\", icon=\"./public/favicon.ico\", pydide=\"https://pyscript.net/releases/2024.1.1/core.js\", scripts=None) -&gt; None:\n    \"\"\"\n    Hydrates a Zenaura layout for server-side rendering.\n\n    This method renders all top components -&gt; pages -&gt; bottom in the app, sets the page with path \"/\" to visible, and the rest to hidden. It then compiles the index.html file for server-side rendering.\n\n    Args:\n        layout (App): the layout to be hyderated with top components -&gt; pages -&gt; bottom components wrapped \n        title (str, optional): The title of the page. Defaults to \"zenaura\".\n        meta_description (str, optional): The meta description of the page. Defaults to \"this app created with zenaura\".\n        icon (str, optional): The URL of the favicon. Defaults to \"./public/favicon.ico\".\n        pydide (str, optional): The URL of the PyScript library. Defaults to \"https://pyscript.net/releases/2024.1.1/core.js\".\n        scripts (list, optional): An optional list of additional JavaScript scripts and CSS links to include in the page. Defaults to None.\n    \"\"\"\n\n    pages = io.StringIO()\n\n    # First page in the stack is shown\n    routes = layout.routes.copy()\n\n    # add top components first children of root div \n    for comp in layout.top:\n        pages.write(compiler_adapter.hyd_comp_compile_children(comp.render(), comp.id, True))\n\n    def page_div(comps, page_id, hidden, attributes=None):\n        \"\"\"\n            wraps rendered page components with a div, assign hidden attribute\n            if the page is hidden, and add the id\n        \"\"\"\n        if attributes:\n            attrs = []\n            for k,v in attributes.items():\n                attrs.append(Attribute(k,v))\n\n            attrs = attrs_processor.process_attributes(attrs)\n        if hidden:\n            return f'&lt;div hidden{attrs if attributes else \"\"} data-zenaura=\"{page_id}\"&gt;{comps}&lt;/div&gt;'\n        return f'&lt;div{attrs if attributes else \"\"} data-zenaura=\"{page_id}\"&gt;{comps}&lt;/div&gt;'\n\n    # if / path in routes it's set to shown\n    if \"/\" in routes:\n        page, _, _, ssr = routes.pop(\"/\")\n        pages.write(\n            page_div(\n                compiler_adapter.hyd_comp_compile_page(page),\n                page.id,\n                False,\n                page.attributes\n            )\n        )\n    else: # first route , in keys stack will be shown, rest hidden\n        keys = list(routes.keys())\n        page, _, _, ssr = routes.pop(keys[0])\n        pages.write(\n            page_div(\n                compiler_adapter.hyd_comp_compile_page(page),\n                page.id,\n                False,\n                page.attributes\n\n            )\n        )\n\n\n    # Render rest of the pages hidden\n    while routes:\n        _ , (page, _, _, ssr) = routes.popitem()\n        if ssr:  # Ignore server side rendered routes and thier pages.\n            continue\n        # Pages other than / or first route in stack are set to hidden\n        pages.write(\n            page_div(\n                compiler_adapter.hyd_comp_compile_page(page),\n                page.id,\n                True,\n                page.attributes\n\n            )\n        )\n\n    # add bottom level components\n    for comp in layout.bottom:\n        pages.write(compiler_adapter.hyd_comp_compile_children(comp.render(), comp.id, True))\n\n    pages = pages.getvalue()\n\n    # Overwrite in public dir\n    with open(\"./public/index.html\", \"w\") as file:\n        file.write(template(pages, meta_description, title, icon, pydide, scripts))\n\n    return template(pages, meta_description, title, icon, pydide, scripts)\n</code></pre>"},{"location":"api/server/server/#zenaura.server.server.ZenauraServer.hydrate_page","title":"<code>hydrate_page(page, title='zenaura', meta_description='this app created with zenaura', icon='./public/favicon.ico', pydide='https://pyscript.net/releases/2024.1.1/core.js')</code>  <code>staticmethod</code>","text":"<p>Hydrates a Zenaura page for server-side rendering.</p> <p>This method compiles the page's components using the HydratorCompilerAdapter and generates the HTML structure of the page.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Page</code> <p>The Zenaura page to be hydrated.</p> required <code>title</code> <code>str</code> <p>The title of the page. Defaults to \"zenaura\".</p> <code>'zenaura'</code> <code>meta_description</code> <code>str</code> <p>The meta description of the page. Defaults to \"this app created with zenaura\".</p> <code>'this app created with zenaura'</code> <code>icon</code> <code>str</code> <p>The URL of the favicon. Defaults to \"./public/favicon.ico\".</p> <code>'./public/favicon.ico'</code> <code>pydide</code> <code>str</code> <p>The URL of the PyScript library. Defaults to \"https://pyscript.net/releases/2024.1.1/core.js\".</p> <code>'https://pyscript.net/releases/2024.1.1/core.js'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The HTML structure of the hydrated page.</p> Source code in <code>zenaura/server/server.py</code> <pre><code>@staticmethod\ndef hydrate_page(page: Page, title=\"zenaura\", meta_description=\"this app created with zenaura\", icon=\"./public/favicon.ico\", pydide=\"https://pyscript.net/releases/2024.1.1/core.js\") -&gt; str:\n    \"\"\"\n    Hydrates a Zenaura page for server-side rendering.\n\n    This method compiles the page's components using the HydratorCompilerAdapter and generates the HTML structure of the page.\n\n    Args:\n        page (Page): The Zenaura page to be hydrated.\n        title (str, optional): The title of the page. Defaults to \"zenaura\".\n        meta_description (str, optional): The meta description of the page. Defaults to \"this app created with zenaura\".\n        icon (str, optional): The URL of the favicon. Defaults to \"./public/favicon.ico\".\n        pydide (str, optional): The URL of the PyScript library. Defaults to \"https://pyscript.net/releases/2024.1.1/core.js\".\n\n    Returns:\n        str: The HTML structure of the hydrated page.\n    \"\"\"\n\n    return template(compiler_adapter.hyd_comp_compile_page(page), meta_description, title, icon, pydide)\n</code></pre>"},{"location":"api/server/server/#zenaura.server.server.DevServer.__init__","title":"<code>__init__(app, debug=True, port=5000)</code>","text":"<p>Initializes the DevServer class.</p> <p>Parameters:</p> Name Type Description Default <code>debug</code> <code>bool</code> <p>Whether to run the server in debug mode. Defaults to True.</p> <code>True</code> <code>port</code> <code>int</code> <p>The port on which to run the server. Defaults to 5000.</p> <code>5000</code> Source code in <code>zenaura/server/server.py</code> <pre><code>def __init__(self, app, debug=True, port=5000):\n    \"\"\"\n    Initializes the DevServer class.\n\n    Args:\n        debug (bool, optional): Whether to run the server in debug mode. Defaults to True.\n        port (int, optional): The port on which to run the server. Defaults to 5000.\n    \"\"\"\n\n    self.debug = debug\n    self.port = port\n    self.app = app\n    self.sock = Sock()\n    self.ws_client_list = []\n    self.shutdown_event = Event()\n    self.observer = PausingObserver()\n    self.sock.init_app(self.app)\n\n    self.setup_websocket()\n</code></pre>"},{"location":"api/server/server/#zenaura.server.server.DevServer.get_change_handler","title":"<code>get_change_handler()</code>","text":"<p>Returns a ChangeHandler class that handles file system events.</p> <p>Returns:</p> Name Type Description <code>ChangeHandler</code> <p>A class that handles file system events.</p> Source code in <code>zenaura/server/server.py</code> <pre><code>def get_change_handler(self):\n    \"\"\"\n    Returns a ChangeHandler class that handles file system events.\n\n    Returns:\n        ChangeHandler: A class that handles file system events.\n    \"\"\"\n\n    DEVSERVER = self\n\n    class ChangeHandler(FileSystemEventHandler):\n        \"\"\"\n        A class that handles file system events.\n\n        This class is used to detect changes in the application files and trigger a refresh of the browser.\n        \"\"\"\n\n        def __init__(self, server):\n            \"\"\"\n            Initializes the ChangeHandler class.\n\n            Args:\n                server (DevServer): The DevServer instance.\n            \"\"\"\n\n            super().__init__()\n            self.server = server\n\n        def on_any_event(self, event):\n            \"\"\"\n            Handles file system events.\n\n            Args:\n                event (FileSystemEvent): The file system event.\n            \"\"\"\n\n            try:\n                zenaura_logger.info(f\"File {event.src_path} has changed.\")\n                zenaura_logger.info(\"Changes are live...\")\n                DEVSERVER.hydrate_and_notify()\n                zenaura_logger.info(\"Reloading browser...\")\n                DEVSERVER.send_refresh_signal()\n                zenaura_logger.info(\"Browser reloaded.\")\n            except Exception as e:\n                zenaura_logger.info(f\"Error in ChangeHandler: {e}\")\n\n    return ChangeHandler\n</code></pre>"},{"location":"api/server/server/#zenaura.server.server.DevServer.hydrate_and_notify","title":"<code>hydrate_and_notify()</code>","text":"<p>Hydrates the application and notifies clients of changes.</p> Source code in <code>zenaura/server/server.py</code> <pre><code>def hydrate_and_notify(self):\n    \"\"\"\n    Hydrates the application and notifies clients of changes.\n    \"\"\"\n\n    try:\n        self.observer.pause()\n        zenaura_logger.info(\"Hydrating...\")\n        zenaura_logger.info(\"Pausing the observer...\")\n        process = subprocess.Popen(\"python build.py\", shell=True)\n        process.communicate()\n        zenaura_logger.info(\"Hydrated done...\")\n\n    finally:\n        zenaura_logger.info(\"Running the observer...\")\n        self.observer.resume()\n</code></pre>"},{"location":"api/server/server/#zenaura.server.server.DevServer.run","title":"<code>run()</code>","text":"<p>Runs the development server.</p> <p>This method starts the Flask server, file system observer, and WebSocket server.</p> Source code in <code>zenaura/server/server.py</code> <pre><code>def run(self):\n    \"\"\"\n    Runs the development server.\n\n    This method starts the Flask server, file system observer, and WebSocket server.\n    \"\"\"\n\n    path = 'public'\n    ChangeHandler = self.get_change_handler()\n    event_handler = ChangeHandler(self)\n    self.observer.schedule(event_handler, path, recursive=True)\n    self.observer.start()\n\n    server_thread = Thread(target=self.start_server, daemon=True)\n    server_thread.start()\n\n    try:\n        while not self.shutdown_event.is_set():\n            time.sleep(0.1)  # Shorter sleep interval\n    except KeyboardInterrupt:\n        zenaura_logger.info(\"KeyboardInterrupt received, stopping...\")\n    finally:\n        # Faster Shutdown of Observer\n        self.observer.event_queue.queue.clear()\n        self.observer.stop()  \n        self.observer.join()  \n</code></pre>"},{"location":"api/server/server/#zenaura.server.server.DevServer.send_refresh_signal","title":"<code>send_refresh_signal()</code>","text":"<p>Sends a refresh signal to all connected clients.</p> Source code in <code>zenaura/server/server.py</code> <pre><code>def send_refresh_signal(self):\n    \"\"\"\n    Sends a refresh signal to all connected clients.\n    \"\"\"\n\n    zenaura_logger.info(\"Sending refresh signal...\")\n    clients = self.ws_client_list.copy()\n    for client in clients:\n        try:\n            client.send(\"refresh\")\n        except Exception as e:\n            print(f\"Error sending refresh: {e}\")\n            self.ws_client_list.remove(client)\n</code></pre>"},{"location":"api/server/server/#zenaura.server.server.DevServer.setup_websocket","title":"<code>setup_websocket()</code>","text":"<p>Sets up the WebSocket route for sending refresh signals to clients.</p> Source code in <code>zenaura/server/server.py</code> <pre><code>def setup_websocket(self):\n    \"\"\"\n    Sets up the WebSocket route for sending refresh signals to clients.\n    \"\"\"\n\n    @self.sock.route(\"/refresh\")\n    def refresh(ws):\n        \"\"\"\n        WebSocket handler for sending refresh signals to clients.\n\n        Args:\n            ws (WebSocket): The WebSocket connection.\n        \"\"\"\n\n        self.ws_client_list.append(ws)\n        while not self.shutdown_event.is_set():\n            try:\n                ws.receive()\n                ws.sleep(1)\n                ws.send(\"refresh\")\n            except Exception as e:\n                print(f\"Error in WebSocket connection: {e}\")\n                break\n</code></pre>"},{"location":"api/server/server/#zenaura.server.server.DevServer.start_server","title":"<code>start_server()</code>","text":"<p>Starts the Flask server.</p> Source code in <code>zenaura/server/server.py</code> <pre><code>def start_server(self):\n    \"\"\"\n    Starts the Flask server.\n    \"\"\"\n\n    try:\n        self.app.run(debug=self.debug, port=self.port, use_reloader=False)\n    except Exception as e:\n        zenaura_logger.info(f\"Error starting server: {e}\")\n</code></pre>"},{"location":"api/ui/badge/","title":"Badge","text":""},{"location":"api/ui/badge/#zenaura.ui.badge.Badge","title":"<code>Badge(label, color='blue', class_='px-2 py-1 rounded text-sm font-semibold')</code>","text":"<p>A reusable badge component.</p> <p>Parameters:</p> Name Type Description Default <code>label</code> <code>str</code> <p>The badge text.</p> required <code>color</code> <code>str</code> <p>The color of the badge (e.g., blue, green, red).</p> <code>'blue'</code> <code>class_</code> <code>str</code> <p>Tailwind classes for styling.</p> <code>'px-2 py-1 rounded text-sm font-semibold'</code> <p>Returns:</p> Name Type Description <code>Node</code> <code>Node</code> <p>The badge element.</p> Source code in <code>zenaura/ui/badge.py</code> <pre><code>def Badge(label: str, color: str = \"blue\", class_: str = \"px-2 py-1 rounded text-sm font-semibold\") -&gt; Node:\n    \"\"\"\n    A reusable badge component.\n\n    Args:\n        label (str): The badge text.\n        color (str): The color of the badge (e.g., blue, green, red).\n        class_ (str): Tailwind classes for styling.\n\n    Returns:\n        Node: The badge element.\n    \"\"\"\n    color_classes = f\"bg-{color}-100 text-{color}-800\"\n    return tag(\"span\", text=label, class_=f\"{class_} {color_classes}\")\n</code></pre>"},{"location":"api/ui/breadcrumbs/","title":"Breadcrumbs","text":""},{"location":"api/ui/breadcrumbs/#zenaura.ui.breadcrumbs.BreadCrumbs","title":"<code>BreadCrumbs(breadcrumbs, seprator='&gt;', span_class='', a_tag_class='opacity-60', li_class='flex cursor-pointer items-center font-sans text-sm font-normal leading-normal antialiased transition-colors duration-300 text-light-gray1 hover:text-light-green dark:text-dark-page1 dark:hover:text-dark-gray2 ', ol_class='flex w-full flex-wrap items-center rounded-md py-2 px-4', sep_class='pointer-events-none mx-2 select-none font-sans text-sm font-normal leading-normal antialiased')</code>","text":"<p>Display the path to the current resources as hierarchy of links</p> args <p>breadcrumbs - list of tuples as [(\"title\", \"handler\"), ...] displayed in order   handler url to navigate to.   title is the title of breadcrumb that will be displayed. seprator - custom seprator between breadcrumbs default is text &gt; span_class - span element classes a_tag_class - breadcrumb a tag css calsses li_class - breadcrumb li tag css classes ol_class - bread crumb ol tag css classes sep_class - breadcrumb seprator css classes</p> Source code in <code>zenaura/ui/breadcrumbs.py</code> <pre><code>def BreadCrumbs(\n    breadcrumbs, \n    seprator=\"&gt;\", \n    span_class=\"\", \n    a_tag_class=\"opacity-60\", \n    li_class=\"flex cursor-pointer items-center font-sans text-sm font-normal leading-normal antialiased transition-colors duration-300 text-light-gray1 hover:text-light-green dark:text-dark-page1 dark:hover:text-dark-gray2 \", \n    ol_class=\"flex w-full flex-wrap items-center rounded-md py-2 px-4\", \n    sep_class=\"pointer-events-none mx-2 select-none font-sans text-sm font-normal leading-normal antialiased\"\n    ) -&gt; \"BreadCrumbs\":\n  \"\"\"\n    Display the path to the current resources as hierarchy of links\n\n    args : \n      breadcrumbs - list of tuples as [(\"title\", \"handler\"), ...] displayed in order\n        handler url to navigate to.\n        title is the title of breadcrumb that will be displayed.\n      seprator - custom seprator between breadcrumbs default is text &gt;\n      span_class - span element classes\n      a_tag_class - breadcrumb a tag css calsses\n      li_class - breadcrumb li tag css classes\n      ol_class - bread crumb ol tag css classes\n      sep_class - breadcrumb seprator css classes\n  \"\"\"\n  crumbs = []\n  sep = Span(sep_class, seprator)\n  n = len(breadcrumbs)\n  for i in range(n):\n    title, handler  = breadcrumbs[i]\n    crumb = LI(\n      A(\n        Span(span_class, title),\n        {\"class\": a_tag_class, \"href\": handler},\n      ),\n      {\"class\": li_class}\n    )\n    crumbs.append(crumb)\n    if i != n - 1:\n      crumbs.append(sep)\n  return OL(crumbs, {\"class\" : ol_class})\n</code></pre>"},{"location":"api/ui/button/","title":"Button","text":"<p>Creates an HTML button element. Args:                 class_name (str): The class name for the button.                 text (str): The text content of the button.                 onclick_handler (str, optional): The JavaScript function to call on click.                 name (str, optional): The name of the button.                 attrs (dict): Additional attributes for the button. Returns:                 An HTML button element with the specified attributes and text.</p> Source code in <code>zenaura/ui/common.py</code> <pre><code>def Button(class_name, text, onclick_handler=None, name=None, attrs={}):\n\t\"\"\"\n\tCreates an HTML button element.\n\tArgs:\n\t\t\tclass_name (str): The class name for the button.\n\t\t\ttext (str): The text content of the button.\n\t\t\tonclick_handler (str, optional): The JavaScript function to call on click.\n\t\t\tname (str, optional): The name of the button.\n\t\t\tattrs (dict): Additional attributes for the button.\n\tReturns:\n\t\t\tAn HTML button element with the specified attributes and text.\n\t\"\"\"\n\tbuilder = Builder('button').with_attribute('class', class_name).with_text(text)\n\tif onclick_handler:\n\t\t\tbuilder = builder.with_attribute('py-click', onclick_handler)\n\tif name:\n\t\t\tbuilder = builder.with_attribute(\"name\", name)\n\treturn builder.with_attributes(**attrs).build()\n</code></pre>"},{"location":"api/ui/card/","title":"Card","text":""},{"location":"api/ui/card/#zenaura.ui.card.Card","title":"<code>Card(content, attrs, default_class='shadow  w-64 me-2 px-2.5 py-0.5 rounded bg-light-white text-light-gray1 dark:text-dark-page1 dark:bg-dark-gray2')</code>","text":"<p>Displays a a card with content.  args:   content : card content of zenaura components or elements.   attrs: card attributes.   default_class: default css class names.</p> Source code in <code>zenaura/ui/card.py</code> <pre><code>def Card(\n    content,\n    attrs, \n    default_class=\"shadow  w-64 me-2 px-2.5 py-0.5 rounded bg-light-white text-light-gray1 dark:text-dark-page1 dark:bg-dark-gray2\", \n    ):\n    \"\"\"\n      Displays a a card with content. \n      args:\n        content : card content of zenaura components or elements.\n        attrs: card attributes.\n        default_class: default css class names.\n\n    \"\"\"\n    return Builder(\"div\").with_attribute(\"class\", default_class).with_attributes(**attrs).with_children(*content).build()\n</code></pre>"},{"location":"api/ui/charts/","title":"Charts","text":""},{"location":"api/ui/charts/#zenaura.ui.charts.Canvas","title":"<code>Canvas(id, attrs={}, childrens=[])</code>","text":"<p>canvas html tag for use with chartjs</p> Source code in <code>zenaura/ui/charts.py</code> <pre><code>def Canvas(id, attrs={}, childrens=[]):\n  \"\"\"\n    canvas html tag for use with chartjs\n\n    args: \n      id - unique chart id\n      attrs - html attributes\n      children - children within canvas tag if needed\n  \"\"\"\n  return  Builder(\"canvas\").with_attribute(\"id\", id).build()\n</code></pre>"},{"location":"api/ui/charts/#zenaura.ui.charts.ChartThis","title":"<code>ChartThis(config, chart_id, *args, **kwargs)</code>","text":"<p>Attaches a chart to canvas.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>- ChartJS config https</code> <p>//www.chartjs.org/docs/latest/configuration/</p> required <p>returns:   Chart</p> Source code in <code>zenaura/ui/charts.py</code> <pre><code>def ChartThis(config, chart_id, *args, **kwargs):\n  \"\"\"\n    Attaches a chart to canvas.\n\n    Args: \n      config - ChartJS config https://www.chartjs.org/docs/latest/configuration/\n      chart_id - unique id for canvas &lt;canvas id=chart_id&gt; to attach chartjs graph to.\n    returns:\n      Chart\n  \"\"\"\n  from js import Chart, Object\n  # clean up chart if chart exists \n  chart_exists = Chart.getChart(chart_id)\n  if chart_exists:\n    chart_exists.destroy()\n\n  # use pyodide to transfrom python dict into js object\n  obj = to_js(config, depth=-1,  \n                  pyproxies=None,\n      create_pyproxies=False,\n      dict_converter=Object.fromEntries)\n\n  # attach graph\n  ctx = document.getElementById(chart_id).getContext('2d')\n  Chart.new(ctx, obj)\n\n  # return Chart for extendibility\n  return Chart\n</code></pre>"},{"location":"api/ui/common/","title":"Common","text":"<p>Creates an HTML image element. Args:                 src (str): The source URL of the image.                 alt (str): The alternate text for the image.                 width (str): The width of the image.                 height (str): The height of the image.                 classname (str): The class name for the image. Returns:                 An HTML img element with the specified attributes.</p> Source code in <code>zenaura/ui/common.py</code> <pre><code>def Image(src, alt, width, height, classname=\"\"):\n\t\"\"\"\n\tCreates an HTML image element.\n\tArgs:\n\t\t\tsrc (str): The source URL of the image.\n\t\t\talt (str): The alternate text for the image.\n\t\t\twidth (str): The width of the image.\n\t\t\theight (str): The height of the image.\n\t\t\tclassname (str): The class name for the image.\n\tReturns:\n\t\t\tAn HTML img element with the specified attributes.\n\t\"\"\"\n\treturn Builder(\"img\").with_attributes(\n\t\tsrc=src,\n\t\talt=alt,\n\t\twidth=width,\n\t\theight=height,\n\t).with_attribute(\"class\", classname).build()\n</code></pre> <p>Creates an HTML h2 element. Args:                 text (str): The text content of the header.                 class_name (str): The class name for the header. Returns:                 An HTML h2 element with the specified attributes and text.</p> Source code in <code>zenaura/ui/common.py</code> <pre><code>def Header2(text, class_name=\"\"):\n\t\"\"\"\n\tCreates an HTML h2 element.\n\tArgs:\n\t\t\ttext (str): The text content of the header.\n\t\t\tclass_name (str): The class name for the header.\n\tReturns:\n\t\t\tAn HTML h2 element with the specified attributes and text.\n\t\"\"\"\n\treturn Builder('h2').with_attribute(\"class\", class_name).with_text(text).build()\n</code></pre> <p>Creates an HTML h1 element. Args:                 text (str): The text content of the header.                 class_names (str): The class names for the header. Returns:                 An HTML h1 element with the specified attributes and text.</p> Source code in <code>zenaura/ui/common.py</code> <pre><code>def Header1(text, class_names):\n\t\"\"\"\n\tCreates an HTML h1 element.\n\tArgs:\n\t\t\ttext (str): The text content of the header.\n\t\t\tclass_names (str): The class names for the header.\n\tReturns:\n\t\t\tAn HTML h1 element with the specified attributes and text.\n\t\"\"\"\n\treturn Builder('h1').with_text(text).with_attribute(\"class\", class_names).build()\n</code></pre> <p>Creates an HTML section element. Args:                 children (list): The child elements of the section.                 class_name (str): The class name for the section. Returns:                 An HTML section element with the specified attributes and children.</p> Source code in <code>zenaura/ui/common.py</code> <pre><code>def Section(children, class_name=\"intro\"):\n\t\"\"\"\n\tCreates an HTML section element.\n\tArgs:\n\t\t\tchildren (list): The child elements of the section.\n\t\t\tclass_name (str): The class name for the section.\n\tReturns:\n\t\t\tAn HTML section element with the specified attributes and children.\n\t\"\"\"\n\tsection = Builder('section').with_attribute('class', class_name).build()\n\tsection.children = children\n\treturn section\n</code></pre> <p>Creates an HTML hr element. Returns:                 An HTML hr element with specified attributes.</p> Source code in <code>zenaura/ui/common.py</code> <pre><code>def HR():\n\t\"\"\"\n\tCreates an HTML hr element.\n\tReturns:\n\t\t\tAn HTML hr element with specified attributes.\n\t\"\"\"\n\treturn Builder(\"hr\").with_attribute('class', \"w-full border-b-1 border-light-green dark:border-gray-700 \").build()\n</code></pre> <p>Creates an HTML ordered list (ol) element. Args:                 children (list): The child li elements.                 attrs (dict): The attributes for the ol element. Returns:                 An HTML ol element with the specified attributes and children.</p> Source code in <code>zenaura/ui/common.py</code> <pre><code>def OL(children, attrs):\n\t\"\"\"\n\tCreates an HTML ordered list (ol) element.\n\tArgs:\n\t\t\tchildren (list): The child li elements.\n\t\t\tattrs (dict): The attributes for the ol element.\n\tReturns:\n\t\t\tAn HTML ol element with the specified attributes and children.\n\t\"\"\"\n\treturn Builder(\"ol\").with_attributes(**attrs).with_children(*children).build()\n</code></pre> <p>Creates an HTML list item (li) element. Args:                 child (element): The child element of the li.                 attrs (dict): The attributes for the li element. Returns:                 An HTML li element with the specified attributes and child.</p> Source code in <code>zenaura/ui/common.py</code> <pre><code>def LI(child, attrs):\n\t\"\"\"\n\tCreates an HTML list item (li) element.\n\tArgs:\n\t\t\tchild (element): The child element of the li.\n\t\t\tattrs (dict): The attributes for the li element.\n\tReturns:\n\t\t\tAn HTML li element with the specified attributes and child.\n\t\"\"\"\n\treturn Builder(\"li\").with_attributes(**attrs).with_child(child).build()\n</code></pre> <p>Creates an HTML anchor (a) element. Args:                 child (element): The child element of the a.                 attrs (dict): The attributes for the a element. Returns:                 An HTML a element with the specified attributes and child.</p> Source code in <code>zenaura/ui/common.py</code> <pre><code>def A(child, attrs):\n\t\"\"\"\n\tCreates an HTML anchor (a) element.\n\tArgs:\n\t\t\tchild (element): The child element of the a.\n\t\t\tattrs (dict): The attributes for the a element.\n\tReturns:\n\t\t\tAn HTML a element with the specified attributes and child.\n\t\"\"\"\n\treturn Builder(\"a\").with_attributes(**attrs).with_child(child).build()\n</code></pre> <p>Creates an HTML dialog element. Args:                 children (list): The child elements of the dialog.                 attrs (dict): The attributes for the dialog element. Returns:                 An HTML dialog element with the specified attributes and children.</p> Source code in <code>zenaura/ui/common.py</code> <pre><code>def Dialog(children, attrs):\n\t\"\"\"\n\tCreates an HTML dialog element.\n\tArgs:\n\t\t\tchildren (list): The child elements of the dialog.\n\t\t\tattrs (dict): The attributes for the dialog element.\n\tReturns:\n\t\t\tAn HTML dialog element with the specified attributes and children.\n\t\"\"\"\n\treturn Builder(\"dialog\").with_children(*children).with_attributes(**attrs).build()\n</code></pre> <p>Creates an HTML paragraph (p) element. Args:                 text (str): The text content of the paragraph.                 class_name (str, optional): The class name for the paragraph. Returns:                 An HTML p element with the specified attributes and text.</p> Source code in <code>zenaura/ui/common.py</code> <pre><code>def Paragraph(text, class_name=None):\n\t\"\"\"\n\tCreates an HTML paragraph (p) element.\n\tArgs:\n\t\t\ttext (str): The text content of the paragraph.\n\t\t\tclass_name (str, optional): The class name for the paragraph.\n\tReturns:\n\t\t\tAn HTML p element with the specified attributes and text.\n\t\"\"\"\n\tbuilder = Builder('p').with_text(text)\n\tif class_name:\n\t\t\tbuilder = builder.with_attribute('class', class_name)\n\treturn builder.build()\n</code></pre> <p>Creates an HTML div element. Args:                 class_name (str): The class name for the div.                 children (list): The child elements of the div. Returns:                 An HTML div element with the specified attributes and children.</p> Source code in <code>zenaura/ui/common.py</code> <pre><code>def Div(class_name, children):\n\t\"\"\"\n\tCreates an HTML div element.\n\tArgs:\n\t\t\tclass_name (str): The class name for the div.\n\t\t\tchildren (list): The child elements of the div.\n\tReturns:\n\t\t\tAn HTML div element with the specified attributes and children.\n\t\"\"\"\n\tdiv = Builder('div').with_attribute('class', class_name).build()\n\tdiv.children = children\n\treturn div\n</code></pre> <p>Creates an HTML button element. Args:                 class_name (str): The class name for the button.                 text (str): The text content of the button.                 onclick_handler (str, optional): The JavaScript function to call on click.                 name (str, optional): The name of the button.                 attrs (dict): Additional attributes for the button. Returns:                 An HTML button element with the specified attributes and text.</p> Source code in <code>zenaura/ui/common.py</code> <pre><code>def Button(class_name, text, onclick_handler=None, name=None, attrs={}):\n\t\"\"\"\n\tCreates an HTML button element.\n\tArgs:\n\t\t\tclass_name (str): The class name for the button.\n\t\t\ttext (str): The text content of the button.\n\t\t\tonclick_handler (str, optional): The JavaScript function to call on click.\n\t\t\tname (str, optional): The name of the button.\n\t\t\tattrs (dict): Additional attributes for the button.\n\tReturns:\n\t\t\tAn HTML button element with the specified attributes and text.\n\t\"\"\"\n\tbuilder = Builder('button').with_attribute('class', class_name).with_text(text)\n\tif onclick_handler:\n\t\t\tbuilder = builder.with_attribute('py-click', onclick_handler)\n\tif name:\n\t\t\tbuilder = builder.with_attribute(\"name\", name)\n\treturn builder.with_attributes(**attrs).build()\n</code></pre> <p>Creates an HTML button element with specified attributes and children. Args:                 class_name (str): The class name for the button.                 attrs (dict): Additional attributes for the button.                 children (list): The child elements of the button.                 onclick_handler (str, optional): The JavaScript function to call on click.                 name (str, optional): The name of the button. Returns:                 An HTML button element with the specified attributes and children.</p> Source code in <code>zenaura/ui/common.py</code> <pre><code>def ButtonWithAttrsChildren(class_name, attrs, children, onclick_handler=None, name=None):\n\t\"\"\"\n\tCreates an HTML button element with specified attributes and children.\n\tArgs:\n\t\t\tclass_name (str): The class name for the button.\n\t\t\tattrs (dict): Additional attributes for the button.\n\t\t\tchildren (list): The child elements of the button.\n\t\t\tonclick_handler (str, optional): The JavaScript function to call on click.\n\t\t\tname (str, optional): The name of the button.\n\tReturns:\n\t\t\tAn HTML button element with the specified attributes and children.\n\t\"\"\"\n\treturn Builder(\"button\") \\\n\t\t\t.with_attribute(\"class\", class_name) \\\n\t\t\t.with_attributes(**attrs).with_children(*children) \\\n\t\t\t.with_attribute(\"py-click\", onclick_handler) \\\n\t\t\t.build()\n</code></pre> <p>Creates a loader div element. Returns:                 An HTML div element representing a loader.</p> Source code in <code>zenaura/ui/common.py</code> <pre><code>def Loader():\n\t\"\"\"\n\tCreates a loader div element.\n\tReturns:\n\t\t\tAn HTML div element representing a loader.\n\t\"\"\"\n\treturn Div(\"loader self-center bg-light-white dark:bg-dark-gray1\", [\n\t\tDiv(\"\", [\n\t\t\tDiv(\"\", [\n\t\t\t])\n\t\t])\n\t])\n</code></pre> <p>Creates a navigation item with text. Args:                 href (str): The URL the item links to.                 text (str): The text content of the item.                 class_names (str): The class names for the item.                 click (str, optional): The JavaScript function to call on click. Returns:                 An HTML a element with the specified attributes and text.</p> Source code in <code>zenaura/ui/common.py</code> <pre><code>def NavItemText(href, text, class_names, click=None):\n\t\"\"\"\n\tCreates a navigation item with text.\n\tArgs:\n\t\t\thref (str): The URL the item links to.\n\t\t\ttext (str): The text content of the item.\n\t\t\tclass_names (str): The class names for the item.\n\t\t\tclick (str, optional): The JavaScript function to call on click.\n\tReturns:\n\t\t\tAn HTML a element with the specified attributes and text.\n\t\"\"\"\n\ttag = Builder('a') \\\n\t\t.with_attribute(\"class\", class_names) \\\n\t\t.with_attribute(\"href\", href) \\\n\t\t.with_text(text)\n\tif click:\n\t\t\ttag.with_attribute(\"py-click\", click)\n\treturn tag.build()\n</code></pre> <p>Creates a navigation item with text and a name attribute. Args:                 href (str): The URL the item links to.                 text (str): The text content of the item.                 class_names (str): The class names for the item.                 click (str, optional): The JavaScript function to call on click. Returns:                 An HTML a element with the specified attributes, text, and name.</p> Source code in <code>zenaura/ui/common.py</code> <pre><code>def NavItemTextNameFactory(href, text, class_names, click=None):\n\t\"\"\"\n\tCreates a navigation item with text and a name attribute.\n\tArgs:\n\t\t\thref (str): The URL the item links to.\n\t\t\ttext (str): The text content of the item.\n\t\t\tclass_names (str): The class names for the item.\n\t\t\tclick (str, optional): The JavaScript function to call on click.\n\tReturns:\n\t\t\tAn HTML a element with the specified attributes, text, and name.\n\t\"\"\"\n\ttag = Builder('a') \\\n\t\t.with_attribute(\"class\", class_names) \\\n\t\t.with_attribute(\"href\", href) \\\n\t\t.with_text(text)\n\tif click:\n\t\ttag.with_attribute(\"py-click\", click)\n\tname = text.lower()\n\ttag.with_attribute(\"name\", name)\n\treturn tag.build()\n</code></pre> <p>Creates an HTML anchor (a) element. Args:                 href (str): The URL the link points to.                 text (str): The text content of the link.                 class_names (str): The class names for the link.                 target (str): The target attribute for the link. Returns:                 An HTML a element with the specified attributes and text.</p> Source code in <code>zenaura/ui/common.py</code> <pre><code>def Link(href, text, class_names, target=\"_blank\"):\n\t\"\"\"\n\tCreates an HTML anchor (a) element.\n\tArgs:\n\t\t\thref (str): The URL the link points to.\n\t\t\ttext (str): The text content of the link.\n\t\t\tclass_names (str): The class names for the link.\n\t\t\ttarget (str): The target attribute for the link.\n\tReturns:\n\t\t\tAn HTML a element with the specified attributes and text.\n\t\"\"\"\n\treturn Builder('a') \\\n\t\t.with_attribute(\"class\", class_names) \\\n\t\t.with_attribute(\"href\", href) \\\n\t\t.with_attribute(\"target\", target) \\\n\t\t.with_text(text).build()\n</code></pre> <p>Creates a navigation item with an icon. Args:                 href (str): The URL the item links to.                 img (element): The image element for the icon.                 class_names (str): The class names for the item. Returns:                 An HTML a element with the specified attributes and icon.</p> Source code in <code>zenaura/ui/common.py</code> <pre><code>def NavItemIcon(href, img, class_names=\"\"):\n\t\"\"\"\n\tCreates a navigation item with an icon.\n\tArgs:\n\t\t\thref (str): The URL the item links to.\n\t\t\timg (element): The image element for the icon.\n\t\t\tclass_names (str): The class names for the item.\n\tReturns:\n\t\t\tAn HTML a element with the specified attributes and icon.\n\t\"\"\"\n\treturn Builder('a').with_attribute('href', href).with_attribute(\"class\", class_names).with_child(img).build()\n</code></pre> <pre><code>    Creates an SVG path element.\n    Args:\n                    linecap (str): The stroke-linecap attribute.\n                    linejoin (str): The stroke-linejoin attribute.\n                    d (\n</code></pre> <p>str): The path data.         Returns:                         An SVG path element with the specified attributes.</p> Source code in <code>zenaura/ui/common.py</code> <pre><code>def SvgPath(linecap, linejoin, d):\n\t\"\"\"\n\tCreates an SVG path element.\n\tArgs:\n\t\t\tlinecap (str): The stroke-linecap attribute.\n\t\t\tlinejoin (str): The stroke-linejoin attribute.\n\t\t\td (\n\nstr): The path data.\n\tReturns:\n\t\t\tAn SVG path element with the specified attributes.\n\t\"\"\"\n\treturn Builder('path') \\\n\t\t.with_attribute('stroke-linecap', linecap) \\\n\t\t.with_attribute('stroke-linejoin', linejoin) \\\n\t\t.with_attribute('d', d) \\\n\t\t.build()\n</code></pre> <p>Creates an SVG element. Args:                 class_name (str): The class name for the SVG.                 fill (str): The fill attribute.                 viewBox (str): The viewBox attribute.                 stroke (str): The stroke attribute.                 path (element): The path element inside the SVG.                 stroke_width (str, optional): The stroke-width attribute. Returns:                 An SVG element with the specified attributes and path.</p> Source code in <code>zenaura/ui/common.py</code> <pre><code>def Svg(class_name, fill, viewBox, stroke, path, stroke_width=None):\n\t\"\"\"\n\tCreates an SVG element.\n\tArgs:\n\t\t\tclass_name (str): The class name for the SVG.\n\t\t\tfill (str): The fill attribute.\n\t\t\tviewBox (str): The viewBox attribute.\n\t\t\tstroke (str): The stroke attribute.\n\t\t\tpath (element): The path element inside the SVG.\n\t\t\tstroke_width (str, optional): The stroke-width attribute.\n\tReturns:\n\t\t\tAn SVG element with the specified attributes and path.\n\t\"\"\"\n\tsvg = Builder('svg') \\\n\t\t.with_attribute('class', class_name) \\\n\t\t.with_attributes(\n\t\t\t\tfill=fill,\n\t\t\t\tviewBox=viewBox,\n\t\t\t\tstroke=stroke\n\t\t).with_child(\n\t\t\t\tpath\n\t\t)\n\tif stroke_width:\n\t\t\tsvg.with_attribute('stroke-width', stroke_width)\n\treturn svg.build()\n</code></pre> <p>Creates an HTML span element. Args:                 class_name (str): The class name for the span.                 text (str, optional): The text content of the span. Returns:                 An HTML span element with the specified attributes and text.</p> Source code in <code>zenaura/ui/common.py</code> <pre><code>def Span(class_name, text=None):\n\t\"\"\"\n\tCreates an HTML span element.\n\tArgs:\n\t\t\tclass_name (str): The class name for the span.\n\t\t\ttext (str, optional): The text content of the span.\n\tReturns:\n\t\t\tAn HTML span element with the specified attributes and text.\n\t\"\"\"\n\tspan = Builder('span').with_attribute('class', class_name)\n\tif text:\n\t\t\tspan.with_text(text)\n\treturn span.build()\n</code></pre>"},{"location":"api/ui/form/","title":"Form","text":""},{"location":"api/ui/form/#zenaura.ui.form.Form","title":"<code>Form(attrs, fields, on_submit, default_form_styles='w-full p-2 border border-gray-300 rounded bg-light-white text-light-gray1 dark:text-dark-page1 hover:bg-light-green dark:bg-dark-gray2 dark:hover:bg-dark-gray1')</code>","text":"<p>Displays a form input field.  args:   attrs: python dictionary trasfrom into html attributes.   default_form_styles : default input css class names for form   fields: list of zenaura input fields or custom elements</p> Source code in <code>zenaura/ui/form.py</code> <pre><code>def Form(\n    attrs,\n    fields,\n    on_submit,\n    default_form_styles=\"w-full p-2 border border-gray-300 rounded bg-light-white text-light-gray1 dark:text-dark-page1 hover:bg-light-green dark:bg-dark-gray2 dark:hover:bg-dark-gray1\", \n    ):\n    \"\"\"\n      Displays a form input field. \n      args:\n        attrs: python dictionary trasfrom into html attributes.\n        default_form_styles : default input css class names for form\n        fields: list of zenaura input fields or custom elements\n\n    \"\"\"\n    return Builder(\"form\").with_attribute(\"class\", default_form_styles).with_attributes(**attrs).with_children(*fields).with_attribute(\"py-submit\", on_submit).build()\n</code></pre>"},{"location":"api/ui/input/","title":"Input","text":""},{"location":"api/ui/input/#zenaura.ui.input.Input","title":"<code>Input(label_text, attrs, default_input_class='w-full p-2 border border-gray-300 rounded bg-light-white text-light-gray1 dark:text-dark-page1 hover:bg-light-green dark:bg-dark-gray2 dark:hover:bg-dark-gray1', default_label_class='block mb-2 text-light-gray1 dark:text-dark-page1', default_wrapper_class='p-4')</code>","text":"<p>Displays a form input field.  args:   attrs: python dictionary trasfrom into html attributes.   label: label_text : input label text.   default_input_class : default input css class names   default_label_class : default label css class names   default_wrapper_class : default input wrapper css class names</p> Source code in <code>zenaura/ui/input.py</code> <pre><code>def Input(\n  label_text,\n  attrs, \n  default_input_class=\"w-full p-2 border border-gray-300 rounded bg-light-white text-light-gray1 dark:text-dark-page1 hover:bg-light-green dark:bg-dark-gray2 dark:hover:bg-dark-gray1\", \n  default_label_class=\"block mb-2 text-light-gray1 dark:text-dark-page1\",\n  default_wrapper_class=\"p-4\"\n  ):\n  \"\"\"\n    Displays a form input field. \n    args:\n      attrs: python dictionary trasfrom into html attributes.\n      label: label_text : input label text.\n      default_input_class : default input css class names\n      default_label_class : default label css class names\n      default_wrapper_class : default input wrapper css class names\n\n  \"\"\"\n  return Div(default_wrapper_class, [\n    Builder(\"label\").with_attribute(\"class\", default_label_class).with_text(label_text).build(),\n    Builder('input').with_attribute(\"class\", default_input_class).with_attributes(\n      **attrs\n    ).build(),\n  ])\n</code></pre>"},{"location":"api/ui/menu/","title":"Menu","text":""},{"location":"api/ui/menu/#zenaura.ui.menu.Menu","title":"<code>Menu(main_btn, children, show)</code>","text":"<p>Display a menu to the user - triggered by py-click</p> args <p>main_btn -&gt; button used to toggle dropdown menu on click. children -&gt; menu children  show -&gt; used to toggle menu visibility</p> <p>return :          Togglable menu with options</p> Source code in <code>zenaura/ui/menu.py</code> <pre><code>def Menu(main_btn : Button, children: List[ButtonWithAttrsChildren], show : bool) -&gt; \"Menu\":\n\t\"\"\"\n\t\tDisplay a menu to the user - triggered by py-click\n\n\t\targs : \n\t\t\tmain_btn -&gt; button used to toggle dropdown menu on click.\n\t\t\tchildren -&gt; menu children \n\t\t\tshow -&gt; used to toggle menu visibility\n\t\treturn : \n\t\t\tTogglable menu with options\n\t\"\"\"\n\n\tmenu = Div(\n\t\t\"absolute right-0 z-20 w-56 py-2 mt-2 overflow-hidden bg-white rounded-md shadow-xl dark:bg-dark-gray1\" + (\" hidden\" if not show else \"\"),\n\t\tchildren\n\t)\n\n\treturn Div(\"flex justify-center\", [\n\t\tDiv(\"relative inline-block mb-20\", [\n\t\t\tmain_btn, \n\t\t\tmenu\n\n\t\t])\n\t])\n</code></pre>"},{"location":"api/ui/message/","title":"Message","text":""},{"location":"api/ui/message/#zenaura.ui.message.Message","title":"<code>Message(content, close, show, class_names='fixed top-0 px-4 py-4 right-0 mt-2  shadow z-40 rounded bg-light-white dark:bg-dark-black')</code>","text":"<p>Creates a closeable message notification</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <p>content of message</p> required <code>close</code> <p>close handler</p> required <code>class_names</code> <p>Default class names</p> <code>'fixed top-0 px-4 py-4 right-0 mt-2  shadow z-40 rounded bg-light-white dark:bg-dark-black'</code> <code>show</code> <p>boolean show or hide message</p> required Source code in <code>zenaura/ui/message.py</code> <pre><code>def Message(content, close, show, class_names=\"fixed top-0 px-4 py-4 right-0 mt-2  shadow z-40 rounded bg-light-white dark:bg-dark-black\"):\n\t\"\"\"\n\tCreates a closeable message notification\n\n\targs:\n\t\t\ttext: content of message\n\t\t\tclose: close handler\n\t\t\tclass_names : Default class names\n\t\t\tshow : boolean show or hide message\n\t\"\"\"\n\tmain = \"relative\" if show else \"hidden\"\n\treturn Div(main, [\n\t\tDiv(class_names, [\n\t\t\tDiv(\"relative\", [\n\t\t\t\tcontent,\n\t\t\t\tButton(\"fixed top-0 right-0 dark:text-dark-page1 \", \"X\", attrs={\n\t\t\t\t\"py-click\": close\n\t\t\t\t})\n\t\t\t])\n\t\t])\n\t])\n</code></pre>"},{"location":"api/ui/modal/","title":"Modal","text":""},{"location":"api/ui/modal/#zenaura.ui.modal.Modal","title":"<code>Modal(content, close_btn, show_modal=False, class_names='shadow z-40 rounded bg-light-white text-light-gray1 dark:text-dark-page1 dark:bg-dark-gray2')</code>","text":"<p>Creates a modal component with given content.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <p>Content to be displayed inside the modal, typically a Component.</p> required <code>show_modal</code> <p>Boolean to control the visibility of the modal.</p> <code>False</code> <code>close_btn</code> <p>Button to close modal when it's open</p> required <code>class_names</code> <p>Default class names</p> <code>'shadow z-40 rounded bg-light-white text-light-gray1 dark:text-dark-page1 dark:bg-dark-gray2'</code> Source code in <code>zenaura/ui/modal.py</code> <pre><code>def Modal(content, close_btn, show_modal=False, class_names=\"shadow z-40 rounded bg-light-white text-light-gray1 dark:text-dark-page1 dark:bg-dark-gray2\"):\n  \"\"\"\n  Creates a modal component with given content.\n\n  args:\n      content: Content to be displayed inside the modal, typically a Component.\n      show_modal: Boolean to control the visibility of the modal.\n      close_btn: Button to close modal when it's open\n      class_names : Default class names\n  \"\"\"\n  attrs = {\"open\": \"\", \"class\": class_names} if show_modal else {}\n  modal_content = Dialog([\n    content,\n    close_btn,\n  ], attrs)\n\n  return modal_content\n</code></pre>"},{"location":"api/ui/popover/","title":"Popover","text":""},{"location":"api/ui/popover/#zenaura.ui.popover.Popover","title":"<code>Popover(content, over_content, show=False, position='bottom-0')</code>","text":"<p>Displays a button and popover appears when button is hovered over.  args:   content : popover content   attrs: card attributes.   default_class: default css class names for content   over_content: content that popover appear when overed over   show: when user hover over over_content content card will be visible, elease will be hidden   position: position of content to over_content, left-0, right-0, top-0, bottom-0 relative position</p> Source code in <code>zenaura/ui/popover.py</code> <pre><code>def Popover(\n  content,\n  over_content,\n  show=False,\n  position=\"bottom-0\"\n  ):\n  \"\"\"\n    Displays a button and popover appears when button is hovered over. \n    args:\n      content : popover content\n      attrs: card attributes.\n      default_class: default css class names for content\n      over_content: content that popover appear when overed over\n      show: when user hover over over_content content card will be visible, elease will be hidden\n      position: position of content to over_content, left-0, right-0, top-0, bottom-0 relative position\n  \"\"\"\n  return Div(\n      \"relative\",\n    [\n        over_content,\n      Div(f\"absolute z-10  {position}\" + (\" hidden\" if not show else \"\"), [\n        content\n      ]),\n    ]\n    )\n</code></pre>"},{"location":"api/ui/select/","title":"Select","text":""},{"location":"api/ui/select/#zenaura.ui.select.Option","title":"<code>Option(label, attrs, default_input_class='w-full p-2 border border-gray-300 rounded bg-light-white text-light-gray1 dark:text-dark-page1 hover:bg-light-green dark:bg-dark-gray2 dark:hover:bg-dark-gray1')</code>","text":"<p>Displays a form input field.  args:   attrs: python dictionary trasfrom into html attributes.   default_input_class : default input css class names   default_label_class : default label css class names   value : text value of option</p> Source code in <code>zenaura/ui/select.py</code> <pre><code>def Option(\n  label,\n  attrs,\n  default_input_class=\"w-full p-2 border border-gray-300 rounded bg-light-white text-light-gray1 dark:text-dark-page1 hover:bg-light-green dark:bg-dark-gray2 dark:hover:bg-dark-gray1\", \n  ):\n  \"\"\"\n    Displays a form input field. \n    args:\n      attrs: python dictionary trasfrom into html attributes.\n      default_input_class : default input css class names\n      default_label_class : default label css class names\n      value : text value of option      \n  \"\"\"\n  return Builder('option').with_attribute(\"class\", default_input_class).with_attributes(\n    **attrs\n  ).with_text(label).build()\n</code></pre>"},{"location":"api/ui/select/#zenaura.ui.select.Select","title":"<code>Select(label_text, attrs, options, default_input_class='w-full p-2 border border-gray-300 rounded bg-light-white text-light-gray1 dark:text-dark-page1 hover:bg-light-green dark:bg-dark-gray2 dark:hover:bg-dark-gray1', default_label_class='block mb-2 text-light-gray1 dark:text-dark-page1', default_wrapper_class='p-4')</code>","text":"<p>Displays a form input field.  args:   attrs: python dictionary trasfrom into html attributes.   label: label_text : input label text.   default_input_class : default input css class names   default_label_class : default label css class names   default_wrapper_class : default input wrapper css class names   options: select options List[Option]</p> Source code in <code>zenaura/ui/select.py</code> <pre><code>def Select(\n  label_text,\n  attrs,\n  options, \n  default_input_class=\"w-full p-2 border border-gray-300 rounded bg-light-white text-light-gray1 dark:text-dark-page1 hover:bg-light-green dark:bg-dark-gray2 dark:hover:bg-dark-gray1\", \n  default_label_class=\"block mb-2 text-light-gray1 dark:text-dark-page1\",\n  default_wrapper_class=\"p-4\",\n  ):\n  \"\"\"\n    Displays a form input field. \n    args:\n      attrs: python dictionary trasfrom into html attributes.\n      label: label_text : input label text.\n      default_input_class : default input css class names\n      default_label_class : default label css class names\n      default_wrapper_class : default input wrapper css class names\n      options: select options List[Option]\n\n  \"\"\"\n  return Div(default_wrapper_class, [\n    Builder(\"label\").with_attribute(\"class\", default_label_class).with_text(label_text).build(),\n    Builder('select').with_attribute(\"class\", default_input_class).with_attributes(\n      **attrs\n    ).with_children(*options).build(),\n  ])\n</code></pre>"},{"location":"api/ui/table/","title":"Table","text":""},{"location":"api/ui/table/#zenaura.ui.table.Table","title":"<code>Table(data, columns, attrs={}, class_names='min-w-full bg-white shadow-md rounded-xl', td_class_names='py-3 px-4 text-left', th_class_names='py-3 px-4', tr_class_names='border-b border-light-gray dark:border-dark-page1')</code>","text":"<p>Creates a table component with given data, columns. args:                 data - list of dictionaries of data e.g. [{\"key\" : 1, \"name\": \"Mike\"}]                 columns - list of dictionaries of column names [{\"title\": \"Name\", \"index\": \"name\"}]                                 note index for each column is where data is indexed and displayed, for example                                                 when index is \"name\" , for every dictionary in data \"name\" is fetched and displayed                 class_names - default class name                 attrs table tag attributes dictionary</p> Source code in <code>zenaura/ui/table.py</code> <pre><code>def Table(data, columns, attrs={}, class_names=\"min-w-full bg-white shadow-md rounded-xl\", td_class_names=\"py-3 px-4 text-left\", th_class_names=\"py-3 px-4\", tr_class_names=\"border-b border-light-gray dark:border-dark-page1\"):\n\t\"\"\"\n\tCreates a table component with given data, columns.\n\targs:\n\t\t\tdata - list of dictionaries of data e.g. [{\"key\" : 1, \"name\": \"Mike\"}]\n\t\t\tcolumns - list of dictionaries of column names [{\"title\": \"Name\", \"index\": \"name\"}]\n\t\t\t\t\tnote index for each column is where data is indexed and displayed, for example\n\t\t\t\t\t\t\twhen index is \"name\" , for every dictionary in data \"name\" is fetched and displayed\n\t\t\tclass_names - default class name\n\t\t\tattrs table tag attributes dictionary\n\t\"\"\"\n\tnames = [Builder(\"th\").with_class(th_class_names).with_text(col[\"title\"]).build() for col in columns]\n\tindexes = [col[\"index\"] for col in columns]\n\trows = []\n\tfor i in range(len(data)):\n\t\t\trow_items = [Builder(\"td\").with_class(td_class_names).with_text(str(data[i][index])).build() for index in indexes]\n\t\t\trows.append(Builder(\"tr\").with_class(tr_class_names).with_children(\n\t\t\t\t\t*row_items\n\t\t\t).build())\n\n\treturn    Builder(\"table\").with_attributes(**attrs).with_attribute(\"class\", class_names).with_children(\n\t\t\tBuilder(\"thead\").with_child(\n\t\t\t\t\tBuilder(\"tr\").with_class(tr_class_names).with_children(\n\t\t\t\t\t*names\n\t\t\t).build()\n\t\t\t).build(),\n\t\t\tBuilder(\"tbody\").with_children(\n\t\t\t\t\t*rows\n\t\t\t).build()\n\t).build()\n</code></pre>"},{"location":"api/ui/tabs/","title":"Tabs","text":""},{"location":"api/ui/tabs/#zenaura.ui.tabs.Tabs","title":"<code>Tabs(buttons, content, g_class_names='bg-gray-100 font-sans', buttons_wrapper_class_names='flex  border-b-2 border-light-green dark:border-dark-black')</code>","text":"<p>Create tabs with content for each tab.  args:                 buttons : list of TabButton which is a button upon click becomes active and display content                 content : list of TabContent which is the content under each tab.                 g_class_names: global wrapper div class names                 button_wrapper_class_names: button wrapper div class names.</p> Source code in <code>zenaura/ui/tabs.py</code> <pre><code>def Tabs(buttons, content, g_class_names =\"bg-gray-100 font-sans\", buttons_wrapper_class_names=\"flex  border-b-2 border-light-green dark:border-dark-black\"):\n\t\"\"\"\n\t\t\tCreate tabs with content for each tab. \n\t\t\targs:\n\t\t\t\t\tbuttons : list of TabButton which is a button upon click becomes active and display content\n\t\t\t\t\tcontent : list of TabContent which is the content under each tab.\n\t\t\t\t\tg_class_names: global wrapper div class names\n\t\t\t\t\tbutton_wrapper_class_names: button wrapper div class names.\n\t\"\"\"\n\treturn Div(\n\tg_class_names,\n\t[\n\tDiv(\n\t\t\"p-8\",\n\t\t[\n\t\tDiv(\n\t\t\t\"\",\n\t\t\t[\n\t\t\t\tDiv(\n\t\t\t\t\tbuttons_wrapper_class_names,\n\t\t\t\t\tbuttons\n\t\t\t\t),\n\t\t\t\tDiv(\n\t\t\t\t\t\"mt-3\", \n\t\t\t\t\tcontent\n\t\t\t\t)\n\t\t\t]\n\t\t)\n\t\t]\n\t)\n\t]\n)\n</code></pre>"},{"location":"basics/components/","title":"Zenaura Components: Functional and Class Components","text":"<p>Zenaura allows you to build modular UIs by combining functional components with class components. Understanding when to use each and how to structure them effectively is key to building maintainable applications.</p> <p>class components : Are stateful components with business logic in them. functional components: Are stateless ui elements they get their state via props \" function arguments \"</p>"},{"location":"basics/components/#using-functional-components-within-class-components","title":"Using Functional Components Within Class Components","text":"<p>Class components are ideal for managing state and complex logic, while functional components are best for reusable and presentational UI. You can use functional components inside class components to keep your code modular and clean.</p>"},{"location":"basics/components/#example","title":"Example:","text":"<pre><code>from zenaura.client.component import Component\nfrom zenaura.ui import div, h1, img\n\n# Functional Component\ndef Header(title):\n    return h1(title, class_=\"header\")\n\n# Class Component\nclass ZenauraStarter(Component):\n    def render(self):\n        return div(\n            div(\n                img(src=\"./public/logo.png\", width=255, height=255, alt=\"starterLogo\"),\n                Header(\"The Python Framework For\"),\n                Header(\"Building Modern Web User Interfaces\"),\n            ),\n            class_=\"zenaura\"\n        )\n</code></pre>"},{"location":"basics/components/#why-use-functional-components-in-class-components","title":"Why Use Functional Components in Class Components?","text":"<ol> <li> <p>Separation of Concerns    Functional components handle UI presentation, leaving logic to the class component.</p> </li> <li> <p>Reusability    Functional components can be reused across multiple class components.</p> </li> <li> <p>Simplified Code    Breaking down large class components into smaller functional components makes your code easier to read and maintain.</p> </li> </ol>"},{"location":"basics/components/#reusable-components-vs-non-reusable-components","title":"Reusable Components vs. Non-Reusable Components","text":""},{"location":"basics/components/#non-reusable-class-components","title":"Non-Reusable Class Components","text":"<p>By default, Zenaura class components are limited and cannot be reused unless explicitly marked as reusable. These components are tied to specific instances and use cases.</p>"},{"location":"basics/components/#example_1","title":"Example:","text":"<pre><code>from zenaura.client.component import Component\n\nclass LimitedComponent(Component):\n    def render(self):\n        return div(\"This is a limited component\", class_=\"limited\")\n</code></pre> <p>Usage: <pre><code>limited1 = LimitedComponent()\nlimited2 = LimitedComponent()  # Error: Non-reusable components cannot be instantiated multiple times\n</code></pre></p>"},{"location":"basics/components/#reusable-class-components","title":"Reusable Class Components","text":"<p>Marking a class component as reusable allows it to be instantiated multiple times within the same project. Use the <code>@Reuseable</code> decorator to enable this.</p>"},{"location":"basics/components/#example_2","title":"Example:","text":"<pre><code>from zenaura.client.component import Component, Reuseable\n\n@Reuseable\nclass ReusableComponent(Component):\n    def render(self):\n        return div(\"This is a reusable component\", class_=\"reusable\")\n</code></pre> <p>Usage: <pre><code>reusable1 = ReusableComponent()  # No error\nreusable2 = ReusableComponent()  # No error\n</code></pre></p>"},{"location":"basics/components/#when-to-use-non-reusable-components","title":"When to Use Non-Reusable Components","text":"<ul> <li>For components tightly coupled to specific logic or state.</li> <li>For one-off components not meant to be instantiated multiple times.</li> </ul>"},{"location":"basics/components/#when-to-use-reusable-components","title":"When to Use Reusable Components","text":"<ul> <li>For UI elements used across different parts of the application (e.g., buttons, cards, modals).</li> <li>When you need consistency across instances with shared logic but independent states.</li> </ul>"},{"location":"basics/components/#combining-functional-and-reusable-components","title":"Combining Functional and Reusable Components","text":"<p>You can nest reusable and functional components inside a class component to create highly modular and flexible UIs.</p>"},{"location":"basics/components/#example_3","title":"Example:","text":"<pre><code>from zenaura.client.component import Component, Reuseable\nfrom zenaura.ui import div, h1\n\n# Functional Component\ndef Card(content):\n    return div(content, class_=\"card\")\n\n# Reusable Class Component\n@Reuseable\nclass ReusableCardList(Component):\n    def render(self):\n        return div(\n            Card(\"Card 1 Content\"),\n            Card(\"Card 2 Content\"),\n            class_=\"card-list\"\n        )\n</code></pre>"},{"location":"basics/components/#best-practices","title":"Best Practices","text":"<ol> <li>Functional Inside Class: Use functional components within class components for reusable, presentation-focused UI.</li> <li>Reusable Components: Mark components as reusable when they need to be instantiated multiple times.</li> <li>Non-Reusable Components: Use non-reusable components for one-off, tightly scoped logic.</li> <li>Modularity: Break large components into smaller functional components for better maintainability.</li> </ol> <p>By understanding the distinction between reusable and non-reusable components and leveraging functional components effectively, you can build scalable, maintainable, and efficient Zenaura applications. \ud83d\ude80</p>"},{"location":"basics/di/","title":"Simple Guide to Dependency Injection in Zenaura","text":"<p>Dependency injection (DI) allows you to inject external dependencies into your components, making your code more modular and easier to test.</p>"},{"location":"basics/di/#why-use-dependency-injection","title":"Why Use Dependency Injection?","text":"<ul> <li>Decoupling: Makes your components independent of the specific implementations of their dependencies.</li> <li>Testability: Easier to mock dependencies during testing.</li> <li>Flexibility: Easily swap out dependencies without changing your component code.</li> </ul>"},{"location":"basics/di/#basic-steps-for-dependency-injection","title":"Basic Steps for Dependency Injection","text":""},{"location":"basics/di/#step-1-define-your-dependencies","title":"Step 1: Define Your Dependencies","text":"<p>First, create the dependencies that your components will need. These could be services, configurations, or any other objects.</p> <pre><code>class ApiService:\n    def fetch_data(self):\n        return \"data from API\"\n\nclass Logger:\n    def log(self, message):\n        print(f\"LOG: {message}\")\n\n# Create instances of your dependencies\ndependencies = {\n    \"api_service\": ApiService(),\n    \"logger\": Logger()\n}\n</code></pre>"},{"location":"basics/di/#inject-dependencies-into-components","title":"Inject Dependencies into Components","text":"<p>When creating a component, pass the dependencies to the component's constructor.</p> <pre><code>from zenaura.client.component import Component\nfrom zenaura.ui import div, h1\nclass MyComponent(Component):\n    def __init__(self, di):\n        super().__init__()\n        self.api_service = di[\"api_service\"]\n        self.logger = di[\"logger\"]\n\n    def render(self):\n        return div(\n            h1(\"some text\")\n        )\n\n# Instantiate the component with dependencies\nmy_component = MyComponent(dependencies)\n</code></pre>"},{"location":"basics/di/#use-dependencies-in-component-methods","title":"Use Dependencies in Component Methods","text":"<p>Utilize the injected dependencies in your component's methods as needed.</p> <pre><code>class DataFetcherComponent(Component):\n    def __init__(self, di):\n        super().__init__()\n        self.api_service = di[\"api_service\"]\n        self.logger = di[\"logger\"]\n\n    async def fetch_and_log_data(self):\n        data = self.api_service.fetch_data()\n        self.logger.log(f\"Data: {data}\")\n\n    def render(self):\n        return return div(\n            h1(\"some text\")\n        )\n\n# Instantiate the component with dependencies\ndata_fetcher_component = DataFetcherComponent(dependencies)\n</code></pre>"},{"location":"basics/di/#step-4-injecting-dependencies-into-nested-components","title":"Step 4: Injecting Dependencies into Nested Components","text":"<p>The only type of components you can inject in another component are functional components, fuctional components are stateless receive state via props</p> <pre><code>class ParentComponent(Component):\n    def __init__(self, di):\n        super().__init__()\n        self.di = di\n\n    def render(self):\n        return div(\n            ChildComponent(di[0])\n            class_=\"root\"\n        )\n\ndef ChildComponent(text):\n    return div(\n        h1(text)\n    )\n\n# Instantiate the parent component with dependencies\ndependencies = [\"1\", \"2\"]\nparent_component = ParentComponent(dependencies)\n</code></pre>"},{"location":"basics/html_tags/","title":"Introduction to Zenaura Tags","text":"<p>Zenaura simplifies UI development by providing Pythonic representations of HTML tags. These tags allow you to define and manipulate DOM elements directly in Python, ensuring consistency and maintainability in your web applications.</p>"},{"location":"basics/html_tags/#key-features-of-zenaura-tags","title":"Key Features of Zenaura Tags","text":"<ol> <li>Python-Friendly Tags </li> <li>Zenaura resolves conflicts with Python keywords by renaming certain HTML tags.</li> <li> <p>Example: Use <code>input_</code> for the <code>&lt;input&gt;</code> tag to avoid conflicts.</p> </li> <li> <p>Special Attributes </p> </li> <li> <p>Some HTML attributes are adjusted for Python compatibility:</p> <ul> <li><code>class</code> \u2192 <code>class_</code></li> <li><code>for</code> \u2192 <code>for_</code></li> <li><code>name</code> \u2192 <code>name_</code></li> <li><code>type</code> \u2192 <code>type_</code></li> </ul> </li> <li> <p>Attribute Value Normalization </p> </li> <li> <p>Boolean values are converted to valid HTML:</p> <ul> <li><code>True</code> \u2192 <code>\"true\"</code></li> <li><code>False</code> \u2192 <code>\"false\"</code></li> </ul> </li> <li> <p>Dynamic Processing </p> </li> <li>Attributes and tag names are processed internally for proper rendering:      <pre><code>def process_attributes(attrs: List[Attribute]) -&gt; str:\n    # Converts Python-friendly attributes to valid HTML\n</code></pre></li> </ol>"},{"location":"basics/html_tags/#example-using-tags-and-attributes","title":"Example: Using Tags and Attributes","text":""},{"location":"basics/html_tags/#python-code","title":"Python Code:","text":"<pre><code>from zenaura.ui import div, input_\n\ndiv(\n    input_(type_=\"text\", name_=\"username\", class_=\"form-control\"),\n    class_=\"form-group\"\n)\n</code></pre>"},{"location":"basics/html_tags/#rendered-html","title":"Rendered HTML:","text":"<pre><code>&lt;div class=\"form-group\"&gt;\n  &lt;input type=\"text\" name=\"username\" class=\"form-control\"&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"basics/html_tags/#special-tags-and-attributes","title":"Special Tags and Attributes","text":""},{"location":"basics/html_tags/#special-tags","title":"Special Tags","text":"<p>Zenaura resolves Python keyword conflicts by renaming certain tags: - <code>input_</code> \u2192 <code>&lt;input&gt;</code></p>"},{"location":"basics/html_tags/#special-attributes","title":"Special Attributes","text":"<p>Zenaura adjusts certain attributes for compatibility: | Python Attribute | HTML Attribute | |-------------------|----------------| | <code>class_</code>         | <code>class</code>        | | <code>for_</code>           | <code>for</code>          | | <code>name_</code>          | <code>name</code>         | | <code>type_</code>          | <code>type</code>         |</p>"},{"location":"basics/html_tags/#boolean-values","title":"Boolean Values","text":"<p>Boolean values are normalized: | Python Value | HTML Value | |--------------|------------| | <code>True</code>       | <code>\"true\"</code>   | | <code>False</code>      | <code>\"false\"</code>  |</p>"},{"location":"basics/html_tags/#best-practices","title":"Best Practices","text":"<ul> <li>Use <code>class_</code>, <code>for_</code>, and other special attributes to avoid Python conflicts.</li> <li>Refactor repeated structures into reusable components for clarity and maintainability.</li> <li>Leverage Python logic to dynamically adjust attributes and values.</li> </ul> <p>By adopting Zenaura\u2019s Pythonic tags, attributes, and special handling mechanisms, you can create dynamic, readable, and maintainable web UIs efficiently. \ud83d\ude80</p>"},{"location":"basics/pages/","title":"Working with Pages in Zenaura","text":"<p>Pages in Zenaura serve as the top-level structure for organizing and rendering your application\u2019s components. This guide will cover the basics of creating and managing pages, adding components to them, and setting up routing to navigate between different pages.</p>"},{"location":"basics/pages/#overview","title":"Overview","text":"<p>A page in Zenaura is essentially a container for components. It defines what components should be displayed and how they are structured. They are rendered as stack for example the following page :   Pages are managed by the router, which handles navigation and rendering based on the application's routes.</p>"},{"location":"basics/pages/#key-concepts","title":"Key Concepts","text":"<ul> <li>Page: A top-level container for components.</li> <li>Component: A building block of the UI, which can be stateful or stateless.</li> <li>Router: Manages navigation and rendering of pages based on URL routes.</li> </ul>"},{"location":"basics/pages/#creating-a-page","title":"Creating a Page","text":"<p>To create a page, you need to define which components it contains. Here\u2019s an example of setting up a simple page with some components:</p>"},{"location":"basics/pages/#explanation","title":"Explanation","text":"<ol> <li>Define Components: In this example, we define three simple components: <code>Header</code>, <code>Footer</code>, and <code>MainContent</code>.</li> <li>Create a Page: We then create a <code>Page</code> instance and pass a list of components that should be rendered on this page.</li> </ol>"},{"location":"basics/pages/#adding-pages-to-the-router","title":"Adding Pages to the Router","text":"<p>To enable navigation between pages, we need to add them to the router. The router manages different routes and renders the appropriate page based on the current URL.</p> <pre><code>from zenaura.client.app import Route, App\nfrom public.routes import ClientRoutes\n\n# Initialize the router\nrouter = App()\n\n# Add routes for different pages\nrouter.add_route(Route(\n    title=\"Home\",\n    path=ClientRoutes.home.value,\n    page=home_page\n))\n\n# Add more routes as needed\n</code></pre>"},{"location":"basics/pages/#explanation_1","title":"Explanation","text":"<ol> <li>Initialize Router: We create an instance of the <code>App</code> class, which serves as the router.</li> <li>Add Routes: We add a route for the <code>home_page</code> we created earlier. Each route is defined by a title, a path, and the page to be rendered.</li> </ol>"},{"location":"basics/pages/#navigation-between-pages","title":"Navigation Between Pages","text":"<p>To navigate between pages, you can use the <code>navigate</code> method provided by the router. This can be done within component event handlers or other parts of your application.</p> <pre><code>class NavigationComponent(Component):\n    async def go_to_home(self, event):\n        await router.navigate(ClientRoutes.home.value)\n\n    def render(self):\n        return Builder(\"button\").with_text(\"Go to Home\").with_attribute(\"py-click\", f\"{self.instance_name}.go_to_home\").build()\n</code></pre>"},{"location":"basics/pages/#explanation_2","title":"Explanation","text":"<ol> <li>Navigation Method: The <code>go_to_home</code> method uses the <code>navigate</code> method of the router to change the current URL to the home path.</li> <li>Event Handler: The <code>py-click</code> attribute in the <code>Builder</code> method links the button click event to the <code>go_to_home</code> method, enabling navigation when the button is clicked.</li> </ol>"},{"location":"basics/pages/#example-complete-application","title":"Example: Complete Application","text":"<p>Let\u2019s put everything together in a complete example:</p> <pre><code>from zenaura.client.component import Component\nfrom zenaura.client.tags.builder import Builder\nfrom zenaura.client.page import Page\nfrom zenaura.client.app import Route, App\nfrom public.routes import ClientRoutes\nfrom zenaura.client.tags.node import Node, Attribute\n\n# Define Components\nclass Header(Component):\n    def render(self):\n        return Builder(\"h1\").with_text(\"Welcome to Zenaura!\").build()\n\nclass Footer(Component):\n    def render(self):\n        return Builder(\"footer\").with_text(\"\u00a9 2024 Zenaura Inc.\").build()\n\nclass MainContent(Component):\n    def render(self):\n        return Builder(\"div\").with_text(\"This is the main content area.\").build()\n\nclass NavigationComponent(Component):\n    async def go_to_home(self, event):\n        await router.navigate(ClientRoutes.home.value)\n\n    def render(self):\n        return Builder(\"button\").with_text(\"Go to Home\").with_attribute(\"py-click\", f\"{self.instance_name}.go_to_home\").build()\n\n# Create Pages\nheader = Header()\nfooter = Footer()\nmain_content = MainContent()\nnavigation = NavigationComponent()\n\nhome_page = Page([header, main_content, footer])\nnavigation_page = Page([navigation, footer])\n\n# Initialize Router\nrouter = App()\n\n# Add Routes\nrouter.add_route(Route(\n    title=\"Home\",\n    path=ClientRoutes.home.value,\n    page=home_page\n))\n\nrouter.add_route(Route(\n    title=\"Navigation\",\n    path=ClientRoutes.navigation.value,\n    page=navigation_page\n))\n\n# Start the App\nif __name__ == \"__main__\":\n    import asyncio\n    event_loop = asyncio.get_event_loop()\n    event_loop.run_until_complete(router.handle_location())\n</code></pre>"},{"location":"basics/pages/#adding-attributes-for-page-wrapper-div","title":"Adding attributes for page wrapper div","text":"<p>Each page components are wrapped in single div where it's <code>data-zenara</code> is set to <code>page.id</code>, if you need functionality to add attributes to the page such as <code>class=\"flex\"</code> you can do so using optional page attributes.  <pre><code>home_page = Page([header, main_content, footer], {\"class\": \"flex\" })\n</code></pre></p> <p>The above page will render as follow : <pre><code>&lt;div data-zenaura=\"72e7e09f\" class=\"flex\"&gt;&lt;/div&gt;\n</code></pre></p>"},{"location":"basics/pages/#explanation_3","title":"Explanation","text":"<ol> <li>Components and Pages: We define components and create two pages: <code>home_page</code> and <code>navigation_page</code>.</li> <li>Router Setup: We initialize the router, add routes for both pages, and start the application.</li> </ol>"},{"location":"basics/pages/#best-practices","title":"Best Practices","text":"<ol> <li>Component Organization: Organize your components into separate files or modules for better maintainability.</li> <li>Consistent Structure: Follow a consistent structure for defining and adding pages to the router.</li> <li>Reusability: Use reusable components wherever possible to keep your code DRY (Don't Repeat Yourself).</li> </ol>"},{"location":"basics/pages/#summary","title":"Summary","text":"<p>In this guide, we've covered how to create and manage pages in Zenaura. We explored adding components to pages, setting up the router, and handling navigation. By following these principles, you can build a well-structured and navigable Zenaura application.</p>"},{"location":"basics/router/","title":"Zenaura Router Guide","text":"<p>The Zenaura Router, encapsulated in the <code>App</code> class, provides a powerful and flexible way to manage routes and navigation in your application.</p> <p>Users will not feel they are going through pages in your application, everything will feel as if they were using single app and content appear as they switch pages.</p>"},{"location":"basics/router/#key-features","title":"Key Features","text":"<ul> <li>Routing: Define paths and associate them with components.</li> <li>Navigation: Move between different routes programmatically.</li> <li>History Management: Keep track of navigation history and handle forward/backward navigation.</li> </ul>"},{"location":"basics/router/#setting-up-the-router","title":"Setting Up the Router","text":""},{"location":"basics/router/#initialization","title":"Initialization","text":"<p>To start using the router, instantiate the <code>App</code> class:</p> <pre><code>from zenaura.client.app import App\n\napp = App()\n</code></pre>"},{"location":"basics/router/#adding-routes","title":"Adding Routes","text":"<p>Define routes using the <code>add_route</code> method. Each route is represented by a <code>Route</code> object, which includes the path, page, title, and optional middleware and SSR settings.</p> <pre><code>from zenaura.client.app import Route\nfrom zenaura.client.component import Page\n\n# Define your page components\nhome_page = Page([HomeComponent()])\nabout_page = Page([AboutComponent()])\n\n# Add routes\napp.add_route(Route(title=\"Home\", path=\"/\", page=home_page))\napp.add_route(Route(title=\"About\", path=\"/about\", page=about_page))\n\napp.run() # this will run the router on page load.\n</code></pre>"},{"location":"basics/router/#navigating-between-routes","title":"Navigating Between Routes","text":"<p>Use the <code>navigate</code> method to programmatically navigate to a different route.</p> <pre><code>await app.navigate(\"/about\")\n</code></pre>"},{"location":"basics/router/#navigation-history","title":"Navigation History","text":"<p>Navigate back and forth through the history stack using the <code>back</code> and <code>forward</code> methods.</p> <pre><code>await app.back()\nawait app.forward()\n</code></pre>"},{"location":"basics/router/#getting-the-current-route","title":"Getting the Current Route","text":"<p>Retrieve the current route's page and title using the <code>get_current_route</code> method.</p> <pre><code>current_route = app.get_current_route()\nprint(current_route)\n</code></pre>"},{"location":"basics/router/#handle-params-and-queries","title":"Handle params and queries","text":"<p>Retrieve the current route with it's params and queries</p> <pre><code>route = Route(\"test\", \"/test\", Page([]), None)\nrouter = App()\nrouter.add_route(route)\nself.window.location.pathname = \"/test/123/123?k=1&amp;k2=3\"\ncurrent_route, info = self.router.get_current_route()\nprint(info[\"wildcard\"][\"params\"]) #  [\"123\", \"123\"]\nprint(info[\"wildcard\"][\"query\"][\"k\"]) # 1\nprint(info[\"wildcard\"][\"query\"][\"k2\"]) # 3\n</code></pre>"},{"location":"basics/router/#handle-wild-card-client-routes","title":"Handle wild card client routes","text":"<p>Zenaura router handles wild card routes if they are defined as follow :</p> <pre><code>route = Route(\"wildcard\", \"/users/*\", Page([]), None)\nrouter = App()\nrouter.add_route(route)\nself.window.location.pathname = \"/users/123/123?k=1&amp;k2=3\"\ncurrent_route, info = self.router.get_current_route()\nprint(info[\"wildcard\"][\"params\"]) #  [\"123\", \"123\"]\nprint(info[\"wildcard\"][\"query\"][\"k\"]) # 1\nprint(info[\"wildcard\"][\"query\"][\"k2\"]) # 3\n</code></pre>"},{"location":"basics/router/#adding-middleware-that-runs-before-the-route-is-matched","title":"Adding middleware that runs before the route is matched","text":"<p>In every route you can define a middleware a specific logic that runs before zenaura match the route and mount the page:</p> <pre><code>middleware_order = []\ndef middleware1():\n    middleware_order.append(1)\n    print(middleware_order)\n\ndef middleware2():\n    middleware_order.append(2)\n    print(middleware_order)\n\ndef middleware():\n    middleware1()\n    middleware2()\n\nroute = Route(\"middlewareorder\", \"/middleware\", Page([]), middleware)\nrouter = App()\nrouter.add_route(route)\nawait router.navigate(\"/middleware\")\n# prints [1]\n# prints [1, 2]\n</code></pre>"},{"location":"basics/router/#route-configuration","title":"Route Configuration","text":"<p>The <code>Route</code> class represents the configuration for each route.</p>"},{"location":"basics/router/#attributes","title":"Attributes","text":"<ul> <li><code>title</code> (str): The title of the route.</li> <li><code>path</code> (str): The path of the route.</li> <li><code>page</code> (Page): The page component associated with the route.</li> <li><code>middleware</code> (Optional[Callable]): Optional middleware function to be executed.</li> <li><code>ssr</code> (bool): Indicates if the route is server-side rendered.</li> </ul>"},{"location":"basics/router/#example","title":"Example","text":"<pre><code>route = Route(title=\"Home\", path=\"/\", page=home_page)\napp.add_route(route)\n</code></pre>"},{"location":"basics/router/#handling-not-found-pages","title":"Handling Not Found Pages","text":"<p>If a route is not found, the <code>not_found</code> method displays a \"Page Not Found\" message.</p> <pre><code>class NotFound(Page):\n    def render(self):\n        return Builder(\"div\").with_text(\"Page Not Found\").build()\n\napp.not_found_page = NotFound()\n</code></pre>"},{"location":"basics/router/#example-complete-router-setup","title":"Example: Complete Router Setup","text":"<p>Here's an example demonstrating the full setup of the Zenaura Router:</p> <pre><code>from zenaura.client.app import App, Route\nfrom zenaura.client.component import Page\nfrom zenaura.client.tags.builder import Builder\n\nclass HomeComponent(Page):\n    def render(self):\n        return Builder(\"div\").with_text(\"Welcome to the Home Page\").build()\n\nclass AboutComponent(Page):\n    def render(self):\n        return Builder(\"div\").with_text(\"About Us\").build()\n\nclass NotFound(Page):\n    def render(self):\n        return Builder(\"div\").with_text(\"Page Not Found\").build()\n\n# Initialize the app\napp = App()\n\n# Define pages\nhome_page = Page([HomeComponent()])\nabout_page = Page([AboutComponent()])\n\n# Add routes\napp.add_route(Route(title=\"Home\", path=\"/\", page=home_page))\napp.add_route(Route(title=\"About\", path=\"/about\", page=about_page))\n\n# Set not found page\napp.not_found_page = NotFound()\n\napp.run()\n</code></pre>"},{"location":"basics/state/","title":"Zenaura Component State Management","text":"<p>State management is a crucial aspect of building dynamic and interactive user interfaces. In Zenaura, components can maintain and update their state to reflect changes in the application.</p>"},{"location":"basics/state/#understanding-state-in-components","title":"Understanding State in Components","text":"<p>State in Zenaura components refers to the data that changes over time and drives the UI. Each stateful component can hold its own state, which can be updated in response to user interactions or other events.</p>"},{"location":"basics/state/#example-of-a-stateful-component","title":"Example of a Stateful Component","text":"<p>Here's an example of a component managing multiple pieces of state:</p> <pre><code>from zenaura.client.component import Component\nfrom zenaura.client.tags import div, h1, h2, input, button\nfrom zenaura.client.mutator import mutator\nfrom zenaura.client.dispatcher import dispatcher\n\n# Example Stateful Component\nclass UserProfile(Component):\n    def __init__(self):\n        super().__init__()\n        self.set_state({\n            \"name\": \"John Doe\",\n            \"age\": 30\n        })\n\n    @mutator\n    async def update_name(self, event):\n        new_name = event.target.value\n        self.set_state({\"name\": new_name})\n\n    @mutator\n    async def increment_age(self, event):\n        current_age = self.get_state()[\"age\"]\n        self.set_state({\"age\": current_age + 1})\n\n    def render(self):\n        state = self.get_state()\n        return div(\n            h1(f\"Name: {state['name']}\"),\n            input(value=state[\"name\"], id=\"user_profile_name\"),\n            h2(f\"Age: {state['age']}\"),\n            button(\"Increase Age\", id=\"user_profile_age\")\n        )\n\n# Create the user profile component\nuser_profile = UserProfile()\n\n# Bind events using the dispatcher\ndispatcher.bind(\"user_profile_name\", \"change\", user_profile.update_name)\ndispatcher.bind(\"user_profile_age\", \"click\", user_profile.increment_age)\n</code></pre> <p>The dispacher binds change events to input fields, whenever data changes the state is updated, and @mutator will trigger zenaura vDOM to show updates to the user.</p>"},{"location":"basics/user_events/","title":"User Events","text":""},{"location":"basics/user_events/#handling-user-events-in-zenaura-revised","title":"Handling User Events in Zenaura (Revised)","text":"<p>In Zenaura, handling user events is a key aspect of creating interactive and dynamic applications. This guide will cover how Zenaura processes user events, updates the state, and re-renders components.</p>"},{"location":"basics/user_events/#overview","title":"Overview","text":"<p>The workflow in Zenaura for handling user events follows this sequence:</p> <ol> <li>User Event: An event (e.g., click, input change) occurs in the browser.</li> <li>Mutate State: The event triggers a mutator method in the component, which updates the component's state.</li> <li>Re-render Component: Zenaura compares the new state with the previous state and generates a virtual DOM diff.</li> <li>Render Component on the Browser: The diff is applied to update the actual DOM in the browser.</li> </ol>"},{"location":"basics/user_events/#example-of-handling-user-events","title":"Example of Handling User Events","text":"<pre><code>from zenaura.client.component import Component\nfrom zenaura.client.tags import div, h1, button\nfrom zenaura.client.mutator import mutator\nfrom zenaura.client.dispatcher import dispatcher\n\nclass Counter(Component):\n    def __init__(self, instance_name):\n        super().__init__()\n        self.set_state({\"count\": 0})\n        self.instance_name = instance_name\n\n    @mutator\n    async def increment(self, event):\n        self.set_state({\"count\": self.get_state()[\"count\"] + 1})\n\n    @mutator\n    async def decrement(self, event):\n        self.set_state({\"count\": self.get_state()[\"count\"] - 1})\n\n    def render(self):\n        count = self.get_state()[\"count\"]\n        return div(\n            h1(f\"Count: {count}\"),\n            button(\"+\", id=f\"{self.instance_name}.increase\"),\n            button(\"-\", id=f\"{self.instance_name}.decrease\"),\n        )\n\n# Create an instance of the Counter component\ncounter1 = Counter(\"counter1\")\n\n# Bind events using the dispatcher\ndispatcher.bind(\"counter1.increase\", \"click\", counter1.increment)\ndispatcher.bind(\"counter1.decrease\", \"click\", counter1.decrement)\n</code></pre>"},{"location":"basics/user_events/#explanation-of-changes","title":"Explanation of Changes","text":"<ol> <li> <p>Replacing <code>Builder</code> with <code>tags</code>:</p> </li> <li> <p>The <code>tags</code> library (<code>div</code>, <code>h1</code>, <code>button</code>, etc.) is used for a cleaner and more readable declarative syntax.</p> </li> <li> <p>Each tag directly represents the HTML structure of the component.</p> </li> <li> <p>Event Binding with <code>dispatcher</code>:</p> </li> <li> <p>Events (<code>click</code> for incrementing and decrementing the counter) are bound to their respective methods (<code>increment</code> and <code>decrement</code>) using <code>dispatcher</code>.</p> </li> <li> <p>The <code>dispatcher.bind</code> ensures that each button is linked to the correct instance and method.</p> </li> <li> <p>Maintaining the <code>@mutator</code> Decorator:</p> </li> <li> <p>The <code>@mutator</code> decorator ensures that Zenaura's state management and virtual DOM diffing work seamlessly to update the UI dynamically.</p> </li> <li> <p>Using Instance Names:</p> </li> <li>The <code>instance_name</code> ensures unique IDs for buttons, enabling multiple instances of the <code>Counter</code> component to exist independently.</li> </ol> <p>This updated example aligns with the recommended approach and uses the <code>tags</code> system for simplicity and clarity while retaining the core functionality.</p>"},{"location":"intermediate/forms/","title":"Handling Forms in Zenaura","text":"<p>Handling forms efficiently in Zenaura involves managing form states and handlers in a structured way. This guide will walk you through creating and handling a form using a pattern that mimics dependency injection to keep your code clean and maintainable.</p>"},{"location":"intermediate/forms/#step-1-define-needed-presentaional-components","title":"Step 1: Define Needed presentaional components","text":"<p>First, create needed presentational components such as <code>Label</code>, <code>Input</code>, and <code>Button</code>, <code>TextArea</code>, and <code>Form</code>.</p> <p>In <code>presentational.py</code></p> <pre><code>from zenaura.ui import div, label, input_, textarea, button, form\n\ndef Div(class_name, children):\n    return div(*children, class_=class_name)\n\ndef Label(text):\n    return label(text)\n\ndef Input(type_, name):\n    return input_(type_=type_, name_=name, id=change_event_id)\n\ndef TextArea(name):\n    return textarea(name_=name, id=change_event_id)\n\ndef Button(text, submit_button_id):\n    return button(\n        text,\n        id=submit_button_id\n    )\n\ndef UserForm(change_event_id, submit_button_id):\n    return form(\n        Div('form-group', [\n            Label(\"Name:\"),\n            Input(\"text\", \"name\"),\n            Label(\"Email:\"),\n            Input(\"email\", \"email\"),\n            Label(\"Message:\"),\n            TextArea(\"message\"),\n            Button(\"submit\", submit_button_id)\n        ]),\n        id=change_event_id\n    )\n</code></pre>"},{"location":"intermediate/forms/#step-2-we-will-create-our-form-component","title":"Step 2: We will create our Form component","text":"<p>The form component will handle 3 fields, name, email, message, and submit button.</p> <p>in <code>components.py</code></p> <pre><code>from zenaura.client.component import Component\nfrom public.presentational import UserForm\n\nclass UserFormComponent(Component):\n    def __init__(self, instance_name):\n        super().__init__()\n        self.instance_name = instance_name\n        self.state = {\n\n                \"name\": \"\",\n\n                \"email\": \"\",\n\n                \"message\": \"\"\n\n            }\n\n    def update_state(self, field, value):\n        self.state[field] = value\n\n    def submit_form(self):\n        print(\"Form submitted with:\", self.state)\n\n    def handle_input(self, event):\n        field = event.target.name\n        value = event.target.value\n        self.update_state(field, value)\n        print(self.state)\n\n\n    def handle_submit(self, event):\n        event.preventDefault()\n        self.submit_form()\n\n    def render(self):\n        return UserForm(\"form_field_change\", \"submit_user_form\")\n</code></pre>"},{"location":"intermediate/forms/#step-3-link-the-form-to-a-page","title":"Step 3: Link the form to a page","text":"<p>finally we link the form to a page in <code>main.py</code></p>"},{"location":"intermediate/forms/#application-component","title":"Application Component","text":"<pre><code>from zenaura.client.app import Route, App\nfrom zenaura.client.page import Page\nfrom public.routes import ClientRoutes\nfrom public.components import UserFormComponent\n\nform = UserFormComponent(\"starter\")\n\ndispatcher.bind(\"submit_user_form\", \"click\",  form.handle_submit)\ndispatcher.bind(\"form_field_change\", \"input\",  form.handle_input)\n# App and routing\nrouter = App()\nhome_page = Page([form])\n\nrouter.add_route(Route(\n    title=\"Developer-Focused | Zenaura\",\n    path=\"/\",\n    page=home_page\n))\n\n# Run the application\napp.run()\n</code></pre> <p>When user enter data in any of the form fields, input event is triggered from the browser, zenaura will dispach the form input change event, and the handler will search for the target name and use it to update the state.</p> <p>Note there is no mutation, if you want to add validation you might want to add @mutator on handle change, so you can display error message.</p> <p>Same with click event, the dispacher bind the user click event to from.handle_submit.</p>"},{"location":"intermediate/global_state/","title":"Global State","text":""},{"location":"intermediate/global_state/#managing-global-state-with-the-observer-pattern","title":"Managing Global State with the Observer Pattern","text":"<p>In this guide, we'll implement a global state management system using the Observer pattern. We'll create four counters, and when Counter 1 reaches 5, all counters will reset.</p> <p>Subject and Observer in zenaura allows us to syncrhoinze multiple components to single subject. They will receive signals via update method.</p> <p>This may sound complicated, but it actually simplify alot of use-cases for you, here is an example :</p>"},{"location":"intermediate/global_state/#step-1-create-needed-presentational-components","title":"Step 1: Create needed presentational components","text":"<pre><code>from zenaura.ui import h1, p, div, button\n\ndef Header1(text):\n    return h1(text)\n\ndef Paragraph(text, class_name=None):\n    return p(text, class_=class_name) if class_name else p(text)\n\ndef Div(class_name, children):\n    return div(*children, class_=class_name)\n\ndef Button(class_name, text, id=None, name=None):\n    return button(\n        text,\n        class_=class_name,\n        id=id,\n        name_=name\n    )\n\ndef CounterPresntaional(increaseBtn, headertext, count):\n    return div(\n        headertext,\n        increaseBtn,\n        id=\"large-header\"\n    )\n</code></pre>"},{"location":"intermediate/global_state/#step-2-observer-subject-counter-component","title":"Step 2: Observer, Subject, Counter component","text":"<p>First, we need to import our <code>Observer</code> abstract base class and our <code>Subject</code> class that will manage the observers. Also we will define some presentational components that helps us build the counters.</p> <p>importing the <code>Observer</code>, <code>Subject</code>.</p> <pre><code>from zenaura.client.observer import Observer, Subject\n</code></pre> <p>importing presentational components</p> <pre><code>from public.presentational import Div, Header1, CounterPresntaional, Button\n</code></pre> <p>creating the <code>Subject</code> class that will manage the observers. and the <code>CounterObserver</code> class that will react to state changes.</p> <pre><code># Create the subject\ncounter_subject = Subject()\ncounter_subject.state = {\"counter1\": 0, \"counter2\": 0, \"counter3\": 0, \"counter4\": 0}\n\n\n# create counter observer:\nclass CounterObserver(Observer):\n    pass\n</code></pre> <p>now we will create the counter component, where we manage a global state between different instances of it.</p> <pre><code>from zenaura.client.component import Resueable, Component\nfrom zenaura.client.mutator import mutator, mutates\n\n@Reuseable\nclass Counter(Component, CounterObserver):\n    def __init__(self, subject, counter_name):\n        super().__init__()\n        self.subject = subject\n        self.subject.attach(self)\n        self.counter_name = counter_name\n\n    @mutator\n    async def increment(self, event):\n        self.subject.state[self.counter_name] += 1\n        self.subject.notify()\n\n    @mutates\n    def update(self, value):\n        if self.subject.state[\"counter1\"] == 5:\n            for k in self.subject.state.keys():\n                self.subject.state[k] = 0\n\n    def render(self):\n        return Div(\"container\", [\n            CounterPresntaional(\n                Button(\"btn\", \"Increment\", f\"{self.counter_name}\"),\n                Header1(f\"count {self.subject.state[self.counter_name]}\"),\n                self.subject.state[self.counter_name],\n\n            )\n        ])\n</code></pre> <p>In init,</p> <pre><code>class Counter(Component, CounterObserver):\n    def __init__(self, subject, counter_name):\n        super().__init__()\n        self.subject = subject\n        self.subject.attach(self)\n        self.counter_name = counter_name\n</code></pre> <p>We link every instance of the counter to the global subject, since subject will only call counterInstance.update.</p> <p>In increment,</p> <pre><code>@mutator\nasync def increment(self, event):\n    self.subject.state[self.counter_name] += 1\n    self.subject.notify()\n</code></pre> <p>we decorate with mutator so the component re-renders after increment called which is user event.</p> <p>In update,</p> <pre><code>  @mutates\n  def update(self, value):\n        if self.subject.state[\"counter1\"] == 5:\n            for k in self.subject.state.keys():\n                self.subject.state[k] = 0\n</code></pre> <p>we implement the functionality of the global state, reseting all the counters when counter 1 reaches 5. Note we decorating update method with mutates, not mutator.</p> <p>mutates is same as mutator , it will rerender the component, but it's for regualr python callbacks not coroutines.</p>"},{"location":"intermediate/global_state/#step-3-create-and-attach-counters-to-the-subject-create-the-page","title":"Step 3: Create and Attach Counters to the Subject, create the page","text":"<p>Now, we'll create the counters and attach them to the subject. And create the page of the counters</p>"},{"location":"intermediate/global_state/#main-application","title":"Main Application","text":"<p>in <code>main.py</code> :</p> <pre><code>from zenaura.client.app import App, Route\nfrom zenaura.client.page import Page\nfrom public.components import Counter, counter_subject\nimport asyncio\n\n# Create counter components\ncounter1 = Counter(counter_subject, \"counter1\")\ncounter2 = Counter(counter_subject, \"counter2\")\ncounter3 = Counter(counter_subject, \"counter3\")\ncounter4 = Counter(counter_subject, \"counter4\")\n\n## binds events :\ndispatcher.bind(\"counter1\", \"click\", counter1.increment)\n\ndispatcher.bind(\"counter2\", \"click\", counter2.increment)\n\ndispatcher.bind(\"counter3\", \"click\", counter3.increment)\n\ndispatcher.bind(\"counter4\", \"click\", counter4.increment)\n\n# create the app\napp = App()\n\napp.add_route(\n    Route(\n        \"Home\",\n        \"/\",\n        Page(\n            [counter1, counter2, counter3, counter4]\n       )\n    )\n)\n\n\n# Run the application\napp.run()\n</code></pre> <p>This will result in the required behavior, where the four counters are synced to a single global state as shown in the below GIF:</p> <p></p>"},{"location":"intermediate/layout/","title":"Layout","text":""},{"location":"intermediate/layout/#layouts","title":"Layouts","text":"<p>Layouts in Zenaura allow you to define global components that exist within the root <code>div</code> for every route. Like other Zenaura components, their state is preserved. Layouts are a way to organize your Zenaura application, ensuring consistency and reusability of common UI elements.</p> <p>The typical structure is:</p> <pre><code>Top Components -&gt; App Routes -&gt; Bottom Components\n</code></pre>"},{"location":"intermediate/layout/#example-structure","title":"Example Structure","text":"<pre><code>&lt;div id=\"root\"&gt;\n  &lt;nav&gt;&lt;/nav&gt;\n  &lt;!-- Global top-of-page navigation component --&gt;\n  &lt;div id=\"page1\"&gt;&lt;/div&gt;\n  &lt;div id=\"page2\" hidden&gt;&lt;/div&gt;\n  &lt;div id=\"page3\" hidden&gt;&lt;/div&gt;\n  &lt;div id=\"page4\" hidden&gt;&lt;/div&gt;\n  &lt;footer&gt;&lt;/footer&gt;\n  &lt;!-- Global bottom-of-page footer component --&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"intermediate/layout/#example-of-creating-a-layout","title":"Example of Creating a Layout","text":""},{"location":"intermediate/layout/#step-1-define-layout-in-mainpy","title":"Step 1: Define Layout in <code>main.py</code>","text":"<pre><code>from zenaura.client.app import Route, App\nfrom zenaura.client.page import Page\nfrom zenaura.client.layout import Layout\nfrom public.routes import ClientRoutes\nfrom public.components.header import Header\nfrom public.components.intro import IntroSection\nfrom public.components.footer import Footer\nfrom public.components.examples import Example\n\napp = App()\n\n# Instantiate components\nnav_bar_header = Header(\"\")\nintro_section = IntroSection()\nfooter = Footer()\nexample = Example()\n\n# Define pages\nhome_page = Page([intro_section])\nexample_page = Page([example])\n\n# Define routes\napp.add_route(Route(\n    title=\"Developer-Focused | Zenaura\",\n    path=ClientRoutes.home.value,\n    page=home_page\n))\n\napp.add_route(Route(\n    title=\"Example\",\n    path=ClientRoutes.examples.value,\n    page=example_page\n))\n\n# Create the app layout\nmy_app_layout = Layout(\n    top=[nav_bar_header],    # Components to appear before the routes\n    routes=app.routes,       # Application routes (pages)\n    bottom=[footer]          # Components to appear after the routes\n)\n\n# optional : pass layout to router to trigger global components attached lifecycle method\napp.layout = my_app_layout\n\napp.run()\n</code></pre>"},{"location":"intermediate/layout/#step-2-hydrate-layout-in-buildpy","title":"Step 2: Hydrate Layout in <code>build.py</code>","text":"<pre><code>from public.main import my_app_layout\nfrom zenaura.client.server import ZenauraServer\n\nZenauraServer.hydrate_app_layout(my_app_layout, scripts=[\n    '&lt;link rel=\"stylesheet\" href=\"public/gigavolt.min.css\"&gt;',\n    '&lt;link rel=\"stylesheet\" href=\"public/output.css\"&gt;',\n    '&lt;script src=\"public/highlight.min.js\"&gt;&lt;/script&gt;',\n    '&lt;script src=\"public/python.min.js\"&gt;&lt;/script&gt;',\n    '&lt;script&gt;hljs.highlightAll();&lt;/script&gt;',\n    \"\"\"\n    &lt;script&gt;\n        const ws = new WebSocket(\"ws://localhost:5000/refresh\");\n        ws.onmessage = () =&gt; {\n            console.log(\"Reloading...\");\n            location.reload();\n        };\n    &lt;/script&gt;\n    \"\"\"\n])\n</code></pre> <p>This setup ensures that the navigation bar (<code>nav_bar_header</code>) and footer (<code>footer</code>) components appear on every page of the application. You can add multiple components to the top or bottom sections as needed for your application layout.</p>"},{"location":"quick/first_app/","title":"Creating Your First Zenaura App","text":"<p>In this example, we will walk through creating your first Zenaura application and cover basic concepts.</p> <p>The Zenaura library includes a simple CLI tool to streamline development.</p>"},{"location":"quick/first_app/#cli-commands","title":"CLI Commands","text":"<p>The following commands are available via the CLI:</p> <ul> <li><code>init</code>: Creates a basic Zenaura application with pre-configured files.</li> <li><code>build</code>: Builds the Zenaura application.</li> <li><code>run</code>: Runs the development server.</li> </ul>"},{"location":"quick/first_app/#initializing-a-basic-zenaura-application","title":"Initializing a Basic Zenaura Application","text":"<pre><code>zenaura init\n</code></pre> <p>This command generates a basic Zenaura application with essential files, enabling you to get started quickly.</p>"},{"location":"quick/first_app/#auto-generated-files","title":"Auto-Generated Files","text":"<p>The <code>init</code> command creates the following structure:</p> <ul> <li><code>build.py</code>: Script for building the Zenaura application.</li> <li><code>index.py</code>: Entry point for a simple Zenaura server.</li> <li><code>public/main.py</code>: Main file for importing components, creating pages, and configuring the client router.</li> <li><code>public/main.css</code>: Primary CSS file for styling.</li> <li><code>public/config.json</code>: PyScript Pyodide configuration file.</li> <li><code>__init__.py</code>: Contains code intended to run in the browser.</li> </ul>"},{"location":"quick/first_app/#building-the-application","title":"Building the Application","text":"<pre><code>zenaura build\n</code></pre> <p>This command generates the <code>index.html</code> file for your application.</p>"},{"location":"quick/first_app/#running-the-development-server","title":"Running the Development Server","text":"<pre><code>zenaura run\n</code></pre> <p>Runs the server on <code>localhost:5000</code>. Open the URL in your browser to see the rendered HTML.</p>"},{"location":"quick/first_app/#example-your-first-zenaura-app","title":"Example: Your First Zenaura App","text":"<p>Below is an example of a basic Zenaura application using the new <code>zenaura.ui</code> tags for creating components and pages.</p>"},{"location":"quick/first_app/#define-the-component","title":"Define the Component","text":"<pre><code>from zenaura.client.component import Component\nfrom zenaura.ui import div, h1, h2, img\n\nclass ZenauraStarter(Component):\n    def render(self):\n        return div(\n            div(\n                img(src=\"./public/logo.png\", width=255, height=255, alt=\"starterLogo\"),\n                h1(\"The Python Framework For\"),\n                h2(\"Building Modern Web User Interface\"),\n            ),\n            class_=\"zenaura\"\n        )\n</code></pre>"},{"location":"quick/first_app/#configure-the-app-and-routing","title":"Configure the App and Routing","text":"<pre><code>from zenaura.client.app import Route, App\nfrom zenaura.client.page import Page\n\nstarter = ZenauraStarter()\n\n# App and routing\napp = App()\nhome_page = Page([starter])\n\napp.add_route(Route(\n    title=\"Developer-Focused | Zenaura\",\n    path=\"/\",\n    page=home_page\n))\n\napp.run()\n</code></pre>"},{"location":"quick/first_app/#rendered-html-output","title":"Rendered HTML Output","text":"<pre><code>&lt;div class=\"zenaura\"&gt;\n  &lt;div&gt;\n    &lt;img src=\"./public/logo.png\" width=\"255\" height=\"255\" alt=\"starterLogo\" /&gt;\n    &lt;h1&gt;The Python Framework For&lt;/h1&gt;\n    &lt;h2&gt;Building Modern Web User Interface&lt;/h2&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>The application is live with hot-reloading enabled, ensuring that any code changes automatically refresh the page.</p>"},{"location":"quick/first_app/#adding-new-components","title":"Adding New Components","text":"<p>To extend the application, you can define additional components and add them to your pages.</p>"},{"location":"quick/first_app/#define-a-new-component","title":"Define a New Component","text":"<pre><code>from zenaura.client.component import Component\nfrom zenaura.ui import h1\n\nclass SimpleHeader(Component):\n    def render(self):\n        return h1(\"Welcome to Zenaura!\")\n</code></pre>"},{"location":"quick/first_app/#add-the-component-to-the-page","title":"Add the Component to the Page","text":"<pre><code>header = SimpleHeader()\nhome_page = Page([starter, header])  # Add new component to the page\n</code></pre>"},{"location":"quick/first_app/#rendered-html-output_1","title":"Rendered HTML Output","text":"<pre><code>&lt;div class=\"zenaura\"&gt;\n  &lt;div&gt;\n    &lt;img src=\"./public/logo.png\" width=\"255\" height=\"255\" alt=\"starterLogo\" /&gt;\n    &lt;h1&gt;The Python Framework For&lt;/h1&gt;\n    &lt;h2&gt;Building Modern Web User Interface&lt;/h2&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n&lt;h1&gt;Welcome to Zenaura!&lt;/h1&gt;\n</code></pre>"},{"location":"quick/installation/","title":"Installing zenaura","text":"<p>prerequisits: - Python 3.12 or above. - pip - devolopment server requirements: + flask==2.3.3 + watchdog==4.0.1 + flask-sock==0.7.0</p> <pre><code>pip install zenaura flask==2.3.3 watchdog==4.0.1 flask-sock==0.7.0\n</code></pre> <ul> <li>watchdog flask, flask-sock are used for hot-reloading dev server.</li> </ul> <p>This command will install zenaura library, client and server, CLI.</p>"},{"location":"releases/0.11.122/","title":"Introduction","text":"<p>The following release introduces two minor, backward-compatible changes. The first change allows users to add attributes to page wrapper div:</p> <pre><code>&lt;div data-zenaura=\"72e7e09f\" hidden=\"\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"releases/0.11.122/#adding-attributes-to-pages","title":"Adding Attributes to Pages","text":"<p>The updated implementation now allows adding class names for styling purposes:</p> <pre><code>&lt;div data-zenaura=\"72e7e09f\" hidden=\"\" class=\"flex\"&gt;&lt;/div&gt;\n</code></pre> <p>Users can specify class names for the pages when configuring the router:</p> <pre><code>home_page = Page([intro_section], attributes={\"class\": \"flex\"}) # Optional class name\n</code></pre>"},{"location":"releases/0.11.122/#layout","title":"Layout","text":"<p>Support for higher-order components will remain unchanged. However, this release introduces a custom app hydration method called <code>hydrate_app_layou</code>, for the hydration of the app and pages.</p> <p>For example, consider this layout: nav \u2192 page content \u2192 footer. Using higher-order components and pages, this results in the following structure, using  <code>@Reuseable</code> on nav component, footer and passing new instance for each page  will yield the expected behavior but with html redundancy  : </p> <pre><code>&lt;div&gt;\n    &lt;div data-zenaura=\"72e7e09f\" hidden=\"\"&gt;\n        &lt;nav&gt;&lt;/nav&gt;\n        &lt;div&gt;content&lt;/div&gt;\n        &lt;footer&gt;&lt;/footer&gt;\n    &lt;/div&gt;\n    &lt;div data-zenaura=\"72e7e09f\" hidden=\"\"&gt;\n        &lt;nav&gt;&lt;/nav&gt;\n        &lt;div&gt;content&lt;/div&gt;\n        &lt;footer&gt;&lt;/footer&gt;\n    &lt;/div&gt;\n    &lt;div data-zenaura=\"72e7e09f\" hidden=\"\"&gt;\n        &lt;nav&gt;&lt;/nav&gt;\n        &lt;div&gt;content&lt;/div&gt;\n        &lt;footer&gt;&lt;/footer&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"releases/0.11.122/#solution","title":"Solution","text":"<p>Instead of users passing the router class to the build process, they now use <code>ZenauraServer.hydrate_app_layout</code>, which allows them to pass multiple components and a list of pages in the order they want them to be rendered. Here is an example using higher-order components:</p> <pre><code>from zenaura.client.app import Route, App\nfrom zenaura.client.page import Page\nfrom public.routes import ClientRoutes\nfrom public.components.header import Header\nfrom public.components.intro import IntroSection\nfrom public.components.footer import Footer\nfrom public.components.examples import Example\n\nnav_bar_header = Header(router)\nintro_section = IntroSection()\nfooter = Footer()\nexample = Example()\n\n# Higher-order component\ndef AppLayout(page_children):\n    return [\n        nav_bar_header,\n        *page_children,\n        footer,\n    ]\n\n# App and routing\nhome_page = Page(AppLayout([intro_section]))\n\nrouter.add_route(Route(\n    title=\"components\",\n    path=ClientRoutes.components.value,\n    page=components_page\n))\n</code></pre> <p>This approach is now replaced with:</p> <pre><code>from zenaura.client.app import Route, App\nfrom zenaura.client.page import Page\nfrom zenaura.client.layout import Layout  # Change\nfrom public.routes import ClientRoutes\nfrom public.components.header import Header\nfrom public.components.intro import IntroSection\nfrom public.components.footer import Footer\nfrom public.components.examples import Example\n\nnav_bar_header = Header(router)\nintro_section = IntroSection()\nfooter = Footer()\nexample = Example()\n# No higher-order component needed\n\n# App and routing\nhome_page = Page([intro_section])\nexample_page = Page([example])\n\nrouter.add_route(Route(\n    title=\"Developer-Focused | Zenaura\",\n    path=ClientRoutes.home.value,\n    page=home_page\n))\n\nrouter.add_route(Route(\n    title=\"example\",\n    path=ClientRoutes.examples.value,\n    page=example_page\n))\n\n# Adding app layout\nmy_app_layout = Layout(\n    top= [nav_bar_header], # first child component to root div\n    routes=app.routes,  # Pages stored here\n    bottom=[footer] # last child components to root div\n)\n</code></pre> <p>Updating <code>build.py</code>:</p> <pre><code>from public.main import my_app_layout\nZenauraServer.hydrate_app_layout(my_app_layout, scripts=[\n    '&lt;link rel=\"stylesheet\" href=\"public/gigavolt.min.css\"&gt;',\n    '&lt;link rel=\"stylesheet\" href=\"public/output.css\"&gt;',\n    '&lt;script src=\"public/highlight.min.js\"&gt;&lt;/script&gt;',\n    '&lt;script src=\"public/python.min.js\"&gt;&lt;/script&gt;',\n    '&lt;script&gt;hljs.highlightAll();&lt;/script&gt;',\n    \"\"\"\n    &lt;script&gt;\n        const ws = new WebSocket(\"ws://localhost:5000/refresh\");\n        ws.onmessage = () =&gt; {\n        console.log(\"Reloading...\");\n        location.reload();\n        };\n    &lt;/script&gt;\n    \"\"\"\n])\n</code></pre> <p>This change ensures that global components are included within the root div, not within every page:</p> <pre><code>&lt;div id=\"root\"&gt;\n    &lt;nav&gt;&lt;/nav&gt; &lt;!-- Global top of pages nav component --&gt;\n    &lt;div id=\"page1\"&gt;&lt;/div&gt;\n    &lt;div id=\"page2\" hidden&gt;&lt;/div&gt;\n    &lt;div id=\"page3\" hidden&gt;&lt;/div&gt;\n    &lt;div id=\"page4\" hidden&gt;&lt;/div&gt;\n    &lt;footer&gt;&lt;/footer&gt; &lt;!-- Global bottom of pages footer component --&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"releases/0.11.125/","title":"Introduction","text":"<p>The following release introduces a minor fix, for layout, users can optionally pass layout to the router if they want the component life cycle methods to be synced on every mount. <pre><code>from zenaura.client.app import Route, App\nfrom zenaura.client.page import Page\nfrom zenaura.client.layout import Layout\nfrom public.routes import ClientRoutes\nfrom public.components.header import Header\nfrom public.components.intro import IntroSection\nfrom public.components.footer import Footer\nfrom public.components.examples import Example\n\n# Instantiate components\nnav_bar_header = Header(router)\nintro_section = IntroSection()\nfooter = Footer()\nexample = Example()\n\n# Define pages\nhome_page = Page([intro_section])\nexample_page = Page([example])\n\n# Define routes\nrouter.add_route(Route(\n    title=\"Developer-Focused | Zenaura\",\n    path=ClientRoutes.home.value,\n    page=home_page\n))\n\nrouter.add_route(Route(\n    title=\"Example\",\n    path=ClientRoutes.examples.value,\n    page=example_page\n))\n\n# Create the app layout\nmy_app_layout = Layout(\n    top=[nav_bar_header],    # Components to appear before the routes\n    routes=app.routes,       # Application routes (pages)\n    bottom=[footer]          # Components to appear after the routes\n)\n\n# optional : pass layout to router to trigger global components attached lifecycle method\nrouter.layout = my_app_layout\n</code></pre></p>"},{"location":"releases/0.12.0/","title":"Introduction","text":"<p>The following release introduces a zenaura-ui which is integration with tailwind css inside the frameowrk, with a starter components that we plan to extend in the future. </p> <p>example of component usage : </p> <pre><code>from zenaura.ui.commons import *\nfrom zenaura.ui.badge import Badge\nfrom zenaura.client.component import Component\n\nclass BadgeExample(Component):\n  def render(self):\n    return Badge(\"La ilaha illa Allah\", {})\n</code></pre> <p>The following component display a badge.</p>"},{"location":"releases/0.13.0/","title":"Introduction","text":"<p>The following release introduces a zenaura-ui charts which is integration with chartjs inside the frameowrk, with a starter charts  that we plan to extend in the future. </p> <p>example of component usage : </p> <pre><code>from zenaura.client.mutator import mutator\nfrom zenaura.graph.charts import ChartThis, Canvas\nfrom zenaura.client.component import Component\n\n# Data for the chart\nlabels = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\"]\ndata = {\n    \"labels\": labels,\n    \"datasets\": [{\n        \"label\": \"My First Dataset\",\n        \"backgroundColor\": \"rgba(255, 99, 132, 0.2)\",\n        \"borderColor\": \"rgb(255, 99, 132)\",\n        \"data\": [65, 59, 80, 81, 56, 55, 40],\n    }]\n}\n\n# Configuration options\nconfig = {\n    \"type\": \"bar\",\n    \"data\": data,\n    \"options\": {}\n}\n\nclass Chart(Component):\n  def __init__(self):\n    self.chart_name = \"barchart\"\n\n  @mutator\n  async def attached(self):\n    ChartThis(config, self.chart_name)\n\n\n  def render(self):\n    return  Canvas(self.chart_name)\n</code></pre>"},{"location":"releases/0.15.0/","title":"0.15.0","text":"<p>The following release focuses on making zenaura more beginner friendly through trageted changes. </p>"},{"location":"releases/0.15.0/#asyncdispacher","title":"AsyncDispacher","text":"<p>Now zenaura developers don't need to fully understand how coroutines and asycio work. They can simply call dispacher to dispach asynchrhouns events within the event loop.</p> <p>Also we made zenaura event driven through dispacher.bind, users now can hook components callback to events in the document, window, or by id.</p> <pre><code>dispatcher.bind(\"counter\", \"click\", counter.increment)\n</code></pre> <p>This will allow to more cleaner event managmenent, and simplified version than it used to be. </p> <p>Also I have simplified the app router running by a facade , users now only have to add app.run() instead of importing asyncio </p> <pre><code>app = App()\napp.run()\n</code></pre> <p>Following this change, I updated mutator, also added mutates and graceful error handling. Mutator remain as is for asynchrouns callbacks like api fetching and so on. mutates for regular python call backs</p> <pre><code>@mutator\nasync def coroutine():\n  pass\n\n@mutates\ndef callback():\n  pass\n</code></pre>"},{"location":"releases/0.15.19/","title":"Zenaura Version 0.15.0 Release Notes","text":"<p>This release focuses on making Zenaura more beginner-friendly with targeted improvements, simplifying development and enhancing usability.</p>"},{"location":"releases/0.15.19/#key-improvements","title":"Key Improvements","text":""},{"location":"releases/0.15.19/#asyncdispatcher","title":"AsyncDispatcher","text":"<ul> <li>Simplified Event Management: Developers can now dispatch asynchronous events without needing deep knowledge of <code>asyncio</code> or coroutines.</li> <li>Event-Driven Architecture: Introduced <code>dispatcher.bind</code> for hooking component callbacks to events (e.g., document, window, or element by ID):   <pre><code>dispatcher.bind(\"counter\", \"click\", counter.increment)\n</code></pre>   This enables cleaner, more intuitive event management.</li> </ul>"},{"location":"releases/0.15.19/#simplified-app-routing","title":"Simplified App Routing","text":"<ul> <li>Added a facade for app initialization. Developers now only need:   <pre><code>app = App()\napp.run()\n</code></pre>   No need to manually import or configure <code>asyncio</code>.</li> </ul>"},{"location":"releases/0.15.19/#improved-mutator-handling","title":"Improved Mutator Handling","text":"<ul> <li>Introduced <code>@mutator</code> for asynchronous callbacks (e.g., API fetching) and <code>@mutates</code> for regular Python callbacks:</li> </ul> <pre><code>@mutator\nasync def coroutine():\n    pass\n\n@mutates\ndef callback():\n    pass\n</code></pre>"},{"location":"releases/0.15.19/#streamlined-initialization","title":"Streamlined Initialization","text":"<ul> <li>Reduced the number of required files and dependencies for Zenaura initialization.</li> <li>Enhanced HTML tag support for cleaner, modern code.</li> <li>Now you can include only init.py in config.json, and import all needed zenaura logic in there to be used within the browser.</li> </ul> <pre><code>{\n    \"type\": \"app\",\n    \"schema_version\": 1,\n    \"runtimes\": [],\n    \"interpreters\": [\n        {\n            \"src\": \"https://cdn.jsdelivr.net/pyodide/dev/full/\",\n            \"name\": \"pyodide-0.22.1\",\n            \"lang\": \"python\"\n        }\n    ],\n    \"packages\": [\n        \"zenaura==0.15.19\"\n    ],\n    \"fetch\": [\n        {\n            \"files\": [\n                \"./public/__init__.py\" // here\n            ]\n        }\n    ],\n    \"plugins\": [],\n    \"pyscript\": {\n        \"version\": \"2022.12.1.dev\",\n        \"time\": \"2024-12-21T13:13:08.980141Z\"\n    }\n}\n</code></pre>"},{"location":"releases/0.15.19/#updated-example-code","title":"Updated Example Code","text":"<p>Here's how these improvements simplify app setup:</p> <pre><code>from zenaura.client.app import Route, App\nfrom zenaura.client.page import Page\nfrom zenaura.client.component import Component\nfrom zenaura.ui import div, h1, h2, img\n\nclass ZenauraStarter(Component):\n    def render(self):\n        return div(\n            div(\n                img(src=\"./public/logo.png\", width=255, height=255, alt=\"starterLogo\"),\n                h1(\"The Python Framework For\"),\n                h2(\"Building Modern Web User Interface\"),\n            ),\n            class_=\"zenaura\"\n        )\n\nstarter = ZenauraStarter()\n\n# App and routing\napp = App()\nhome_page = Page([starter])\n\napp.add_route(Route(\n    title=\"Developer-Focused | Zenaura\",\n    path=\"/\",\n    page=home_page\n))\n\napp.run()\n</code></pre>"},{"location":"releases/0.15.19/#bug-fixes-enhancements","title":"Bug Fixes &amp; Enhancements","text":"<ul> <li>Improved error handling for mutators and event dispatching.</li> <li>Fixed app router issues and refined dispatcher logic for better stability.</li> <li>General performance and reliability improvements.</li> </ul>"},{"location":"releases/0.9.118/","title":"First offocial release 0.9.118","text":"<p>The release contain the core functioanlity of zenaura as framework for building UI using python. This core functioanlity include the following features :</p> <ul> <li>Exceptional Developer Experience: Intuitive and efficient development workflow.</li> <li>Smooth Learning Curve: Easy to learn and get started.</li> <li>Modular Code Structure: Write clean, readable, and maintainable code.</li> <li>Component-Based Architecture: Build reusable and scalable components.</li> <li>Page Management: Simplify page creation and navigation.</li> <li>Built-in Router: Seamless client-side routing.</li> <li>State and Props Management: Efficiently handle component states and properties.</li> <li>Dependency Injection: Manage dependencies effortlessly.</li> <li>Global States and Components: Share states and components across the application.</li> <li>Optimized Virtual DOM: Enhance application performance with a highly efficient virtual DOM.</li> <li>Component Lifecycle Methods: Control component behavior at different stages.</li> <li>Form Support: Easily manage form inputs and validation.</li> <li>API Integration: Integrate external APIs using the requests module.</li> </ul>"},{"location":"releases/0.9.122/","title":"0.9.122","text":"<ul> <li>Fix '/' path logic in app:<ul> <li>if the route is defined and linked to a page, on app first render, this page is shown, the rest of the pages are hidden.</li> <li>if the route '/' is not defined and not linked to a page, the first route in the router stack will be shown, the rest are hidden.</li> </ul> </li> <li>Added CLI documentation.</li> <li>Added releases section to documentation.</li> <li>Added Data binding model to documentation.</li> </ul>"},{"location":"zenaura-ui/charts/","title":"Intro","text":"<p>Zenaura/UI Chart is built on top of Chart.js, enabling Python developers to leverage Python's superior data manipulation capabilities and display data using Chart.js. With simple easy to learn APIS.</p> <p>Including a chart is of three steps: 1. Create chart.js configuration https://www.chartjs.org/docs/latest/configuration/ 2. use <code>ChartThis</code> api and pass chart unique id. 3. pass chart unique id to the chart Canvas. </p> <p>For more complex usage feel free to review chartJS documentation, pydide: 1. chartjs: https://www.chartjs.org/ 2. pyodide : https://pyodide.org/en/stable/</p>"},{"location":"zenaura-ui/charts/#installation","title":"Installation","text":"<p>prerequisits:     - Python 3.12 or above.     - zenaura v0.13.0</p>"},{"location":"zenaura-ui/charts/#steps-to-use","title":"Steps to use","text":"<ol> <li> <p>Add chartjs to <code>build.py</code> to be able to use chartjs within zenaura component <pre><code>from zenaura.server import ZenauraServer\nfrom public.main import my_app_layout\n\nZenauraServer.hydrate_app_layout(my_app_layout, scripts=[\n        # your scripts, style sheets.\n        \"\"\"    &lt;script src=\"https://cdn.jsdelivr.net/npm/chart.js\"&gt;&lt;/script&gt;\"\"\"\n\n])\n</code></pre></p> </li> <li> <p>Creating a chart is of three steps </p> </li> </ol> <pre><code>from zenaura.client.mutator import mutator\nfrom zenaura.ui.charts import ChartThis, Canvas\nfrom zenaura.client.component import Component\n\n# Data for the chart\nlabels = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\"]\ndata = {\n    \"labels\": labels,\n    \"datasets\": [{\n        \"label\": \"My First Dataset\",\n        \"backgroundColor\": \"rgba(255, 99, 132, 0.2)\",\n        \"borderColor\": \"rgb(255, 99, 132)\",\n        \"data\": [65, 59, 80, 81, 56, 55, 40],\n    }]\n}\n\n# Configuration options\nconfig = {\n    \"type\": \"bar\",\n    \"data\": data,\n    \"options\": {}\n}\n\nclass Chart(Component):\n  def __init__(self):\n    self.chart_name = \"barchart\"\n\n  @mutator\n  async def attached(self):\n    ChartThis(config, self.chart_name)\n\n\n  def render(self):\n    return  Canvas(self.chart_name)\n</code></pre> <p>Now you can use this component within a page, you can as well create presentational component and use it within larger component. </p>"},{"location":"zenaura-ui/installation/","title":"Intro","text":"<p>Zenaura/ui is built on top of tailwindcss that provide styled ui components for zenaura developer to increase the development pace.</p>"},{"location":"zenaura-ui/installation/#installing-zenaura","title":"Installing zenaura","text":"<p>prerequisits:     - Python 3.12 or above.     - node     - zenaura v0.12.0</p>"},{"location":"zenaura-ui/installation/#step-1-install-zenaura","title":"Step 1 : install zenaura","text":"<pre><code>pip zenaura==0.12.0\n</code></pre>"},{"location":"zenaura-ui/installation/#step-2-configure-tailwind-css-for-use-in-zenaura","title":"step 2 : Configure tailwind css for use in zenaura","text":""},{"location":"zenaura-ui/installation/#1-install-tailwind-and-init-configuration","title":"1. Install tailwind and init configuration","text":"<pre><code>npm install -D tailwindcss\nnpx tailwindcss init\n</code></pre>"},{"location":"zenaura-ui/installation/#adding-paths","title":"adding paths","text":"<p>Add the paths to all of your template files in your tailwind.config.js file, as follow: <pre><code>module.exports = {\n  content: [\n    './public/index.html', \"./public/**/*.py\"\n  ],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}\n</code></pre></p>"},{"location":"zenaura-ui/installation/#configure-maincss","title":"Configure main.css","text":"<p>add the following directives to your main css file.</p> <pre><code>@tailwind base;\n@tailwind components;\n@tailwind utilities;\n</code></pre>"},{"location":"zenaura-ui/installation/#add-components","title":"add components","text":"<p>create components folder inside your puplic folder, add compomonents files into config.json e.g. components/common.py</p> <pre><code>{\n    / ... same\n    \"fetch\": [\n      {\n        \"files\": [\n          / ... same \n\n          \"./public/components/common.py\",\n\n\n        ]\n      }\n    ],\n    / ... same\n    }\n  }\n</code></pre>"},{"location":"zenaura-ui/installation/#run-zenaura-with-tailwind-css","title":"run zenaura with tailwind css","text":"<p>open terminal and use zenaura cli to run build and run zenaura application.</p> <pre><code>zenaura build\nzenaura run\n</code></pre> <p>add output.css to your build.py stylesheets</p> <p><pre><code>from zenaura.server import ZenauraServer\nfrom public.main import my_app_layout\n\nZenauraServer.hydrate_app_layout(my_app_layout, scripts=[\n        # same\n        '&lt;link rel=\"stylesheet\" href=\"public/output.css\"&gt;',\n        # same\n])\n</code></pre> open terminal and run tailwind css watch to create output.css  <pre><code>npx tailwindcss -i ./src/input.css -o ./src/output.css --watch\n</code></pre></p> <p>Done ! Now when you start coding and add class names to your zenaura components tailwind css will add those styles to output.css</p>"}]}